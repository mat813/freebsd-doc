<!--
     The FreeBSD Documentation Project
     The FreeBSD Chinese Documentation Project

     Original Revision: 1.142
     $FreeBSD$
-->

<chapter id="kernelconfig">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Updated and restructured by </contrib>
	<!-- Mar 2000 -->
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jake</firstname>
	<surname>Hamby</surname>
	<contrib>Originally contributed by </contrib>
	<!-- 6 Oct 1995 -->
      </author>
    </authorgroup>
  </chapterinfo>

  <title>配置FreeBSD的内核</title>

  <sect1 id="kernelconfig-synopsis">
    <title>概述</title>

    <indexterm>
      <primary>内核</primary>
      <secondary>建立一个定制的内核</secondary>
    </indexterm>

    <para>内核是 &os; 操作系统的核心。 它负责管理内存、 执行安全控制、
    网络、 磁盘访问等等。 尽管 &os; 可以动态修改的现在已经越来越多，
    但有时您还是需要重新配置和编译您的内核。</para>

    <para>读完这章，您将了解：</para>

    <itemizedlist>
      <listitem>
	<para>为什么需要建立定制的内核。</para>
      </listitem>

      <listitem>
	<para>如何编写内核配置文件，或修改已存在的配置文件。</para>
      </listitem>

      <listitem>
	<para>如何使用内核配置文件创建和联编新的内核。</para>
      </listitem>

      <listitem>
	<para>如何安装新内核。</para>
      </listitem>

      <listitem>
	<para>如何在 <filename>/dev</filename> 中创建设备节点。</para>
      </listitem>

      <listitem>
	<para>如何出现问题怎么办。</para>
      </listitem>
    </itemizedlist>

    <para>这一章给出的命令应该以 <username>root</username> 身份执行，
      否则可能会不成功。</para>
  </sect1>

  <sect1 id="kernelconfig-custom-kernel">
    <title>为什么需要建立定制的内核?</title>

    <para>过去， &os; 采用称作 <quote>单片式</quote> 的内核。
      这句话的意思是说内核是一个大的程序， 支持固定的设备，
      如果您希望改变内核的行为则必须编译一个新的，
      并重新启动计算机来引导它。</para>

    <para>今天， &os; 已经迅速地转移到了一个新的模型，
      其重要特征是内核功能可以由能够根据需要动态加载和卸载的模块来提供。
      这是的内核能够迅速地适应硬件的调整 (例如笔记本电脑的 PCMICA)，
      或为内核增加在最初编译它时所不具备的新的功能。
      这一模式成为模块化内核。</para>

    <para>尽管如此， 一些功能仍然需要静态地连编进内核。
      一些情况是因为这些功能于内核的结合十分紧密，
      而不可能将它们做成可以动态加载的。
      另一种情况是因为没有人有时间来编写实现那个功能的可以动态加载的内核模块。</para>

    <para>建造定制的内核是几乎每一个 BSD 用户所必须经历的一关。
      尽管这项工作可能比较耗时， 但它能够为使用 &os; 系统带来很多好处。
      与必须支持大量各式硬件的 <filename>GENERIC</filename>
      内核不同， 定制的内核可以只包含对于
      <emphasis>您的</emphasis> PC 硬件的支持。
      这有很多好处， 例如：</para>

    <itemizedlist>
      <listitem>
	<para>更快地启动。 因为内核只需要检测您系统上的硬件，
	启动时所花费的时间将大大缩短。</para>
      </listitem>

      <listitem>
	<para>使用更少的内存。 定制的内核通常会比
	  <filename>GENERIC</filename> 内核使用更少的内存，
	  由于内核必须时刻处于物理内存中， 因此这就显得更加重要。
	  给予这样的原因， 对于内存较小的系统来说，
	  定制内核将发挥更大的作用。</para>
      </listitem>

      <listitem>
	<para>支持更多的硬件。 定制的内核允许您增加类似声卡这样的
	  <filename>GENERIC</filename> 内核没有提供内建支持的硬件。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="kernelconfig-building">
    <title>建立并安装一个定制的内核</title>
    <indexterm>
      <primary>内核</primary>
      <secondary>建立/安装</secondary>
    </indexterm>

    <para>首先对内核构建目录做一个快速的浏览。
      这里所提到的所有目录都在
      <filename>/usr/src/sys</filename> 目录中； 也可以通过
      <filename>/sys</filename> 来访问它。
      这里的众多子目录包含了内核的不同部分，
      但对我们所要完成的任务最重要的目录是
      <filename><replaceable>arch</replaceable>/conf</filename>，
      您将在这里编辑定制的内核配置； 以及
      <filename>compile</filename>， 编译过程中的文件将放置在这里。
      <replaceable>arch</replaceable> 表示
      <filename>i386</filename>、 <filename>alpha</filename>、
      <filename>amd64</filename>、 <filename>ia64</filename>、
      <filename>powerpc</filename>、 <filename>sparc64</filename>， 或
      <filename>pc98</filename> (在日本比较流行的另一种
      PC 硬件开发分支)。 在特定硬件架构目录中的文件只和特定的硬件有关；
      而其余代码则是与机器无关的， 则所有已经或将要移植并运行 &os;
      的平台上都共享这些代码。
      文件目录是按照逻辑组织的， 所支持的硬件设备、
      文件系统， 以及可选的组件通常都在它们自己的目录中。
      5.X 版之前的 &os; 只支持
      <filename>i386</filename>、 <filename>alpha</filename>
      和 <filename>pc98</filename> 这三种硬件架构。</para>

    <para>这一章提供的例子假定您使用 i386 架构的计算机。
      如果您的情况不是这样， 只需对目录名作相应的调整即可。</para>

    <note>
      <para>如果在您的系统上 <emphasis>没有</emphasis> <filename>/usr/src/sys</filename> 这个目录，
	则说明没有安装内核源代码。
	最简单的方法是以 <username>root</username> 身份执行
	<command>/stand/sysinstall</command>，
	选择<guimenuitem>Configure</guimenuitem>，
	接着是<guimenuitem>Distributions</guimenuitem>，
	下来<guimenuitem>src</guimenuitem>，
	最后<guimenuitem>sys</guimenuitem>。
	如果您已经有一张<quote>官方</quote>&os;系统安装盘;并且您有权限使用
	光驱,那么您也可以通过下面命令行来安装源代码:</para>
      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>mkdir -p /usr/src/sys</userinput>
&prompt.root; <userinput>ln -s /usr/src/sys /sys</userinput>
&prompt.root; <userinput>cat /cdrom/src/ssys.[a-d]* | tar -xzvf -</userinput></screen>
</note>

    <para>接下来， 进入 <filename><replaceable>arch</replaceable>/conf</filename>
	目录下面， 复制 <filename>GENERIC</filename> 配置文件，
	并给这个文件起一个容易辨认的名称， 它就是您的内核名称。例如：</para>
    <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf</userinput>
&prompt.root; <userinput>cp GENERIC MYKERNEL</userinput></screen>

    <para>通常，这个名称是大写的，如果您正维护着多台不同硬件的&os;机器，
    以您机器的域名来命名是非常好的主意。我们把它命名为<filename>MYKERNEL</filename>就是这个原因。
    </para>

    <tip>
      <para>将您的内核配置文件直接保存在
	<filename>/usr/src</filename> 可能不是一个好主意。
	如果您遇到问题， 删掉
	<filename>/usr/src</filename> 并重新开始很可能是一个诱人的选择。
	一旦开始做这件事，
	您可能几秒钟之后才会意识到您同时会删除定制的内核配置文件。
	另外， 也不要直接编辑 <filename>GENERIC</filename>，
	因为下次您
	<link linkend="cutting-edge">更新代码</link> 时它会被覆盖，
	而您的修改也就随之丢失了。</para>

      <para>您可以考虑将内核配置文件放到别的地方，
	然后在 <filename><replaceable>i386</replaceable></filename>
	目录中建立一个符号连接指向它。</para>

      <para>例如：</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf</userinput>
&prompt.root; <userinput>mkdir /root/kernels</userinput>
&prompt.root; <userinput>cp GENERIC /root/kernels/<replaceable>MYKERNEL</replaceable></userinput>	
&prompt.root; <userinput>ln -s /root/kernels/<replaceable>MYKERNEL</replaceable></userinput></screen>
    </tip>

    <note>
      <para>必须以 <username>root</username> 身份执行这些和接下来命令，
	否则就会得到 <errortype>permission denied</errortype> 的错误提示。
      </para>
    </note>

    <para>现在就可以用您喜欢的文本编辑器来编辑 <filename>MYKERNEL</filename> 了。
      如果您刚刚开始使用 FreeBSD， 唯一可用的编辑器很可能是
      <application>vi</application>， 它的使用比较复杂， 限于篇幅，
      这里不予介绍， 您可以在 <link
      linkend="bibliography">参考书目</link> 一章中找到很多相关书籍。
      不过， &os; 也提供了一个更好用的编辑器，
      它叫做 <application>ee</application>， 对于新手来说，
      这很可能是一个不错的选择。
      您可以修改配置文件中的注释以反映您的配置，
      或其他与 <filename>GENERIC</filename> 不同的地方。</para>
    <indexterm><primary>SunOS</primary></indexterm>

    <para>如果您在&sunos;或者其他BSD系统下定制过内核，那这个文件中的绝大部分将对您非常熟悉。
     如果您使用的是诸如DOS这样的系统，那<filename>GENERIC</filename>配置文件看起来就非常困难，
     所以在下面的 <link linkend="kernelconfig-config">配置文件</link>章节将慢慢地、仔细地进行介绍。
      </para>

    <note>
      <para>如果您和 &os; project 进行了 <link
        linkend="cutting-edge">代码同步</link>，
        则一定要在进行任何更新之前查看
        <filename>/usr/src/UPDATING</filename>。
        这个文件中描述了更新过的代码中出现的重大问题或需要注意的地方。
        <filename>/usr/src/UPDATING</filename> 总是和您的
        &os; 源代码对应， 因此能够提供比手册更具时效性的新内容。</para>
    </note>

    <para>现在应该编译内核的源代码了。 一共有两种方法来完成这项工作，
      使用哪一种取决于您为什么要重新编译内核， 以及所运行的 &os;
      版本。</para>

    <itemizedlist>
      <listitem>
	<para>如果您<emphasis>只</emphasis>安装内核源代码，使用方法1。
	</para>
      </listitem>

      <listitem>
	<para>如果您运行的是&os;4.0以前的版本的话，而且您<emphasis>不</emphasis>升级到
	&os;&nbsp;4.0或更高版本，只要使用方法1。
        </para>
      </listitem>

      <listitem>
	<para> 如果您在没有升级源代码的情况下编译一个新内核（也许您只想为内核添加一个新的选项，
	如<literal>IPFIREWALL</literal>），可以使用任何一种方法。
	  </para>
      </listitem>

      <listitem>
	<para>如果您正在重建的内核是作为<maketarget>make world</maketarget>进程的一部分，需要使用方法2。
        </para>
      </listitem>
    </itemizedlist>
    
    <indexterm>
      <primary><command>cvsup</command></primary>
    </indexterm>
    <indexterm><primary>匿名 CVS</primary></indexterm>
    <indexterm><primary>CTM</primary></indexterm>
    <indexterm>
      <primary>CVS</primary>
      <secondary>匿名</secondary>
    </indexterm>

    <para>如果从上次成功地完成 <maketarget>buildworld</maketarget>-<maketarget>installworld</maketarget>
      以来您还 <emphasis>没有</emphasis> 升级过代码
      (也就是没有运行 <application>CVSup</application>、
      <application>CTM</application>， 或使用
      <application>anoncvs</application>)， 则可以放心使用
      <command>config</command>、 <maketarget>make depend</maketarget>、
      <command>make</command>、 <maketarget>make install</maketarget>。
    </para>

    <procedure>
      <title>方法1. 用<quote>传统</quote>方法建立一个内核</title>
      
      <step>
	<para>运行&man.config.8;来产生内核源代码。</para>
	
	<screen>&prompt.root; <userinput>/usr/sbin/config <replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>进入编译内核的目录。 &man.config.8; 将在像上面一样显示执行它所在的目录的名字。</para>

	<screen>&prompt.root; <userinput>cd ../compile/<replaceable>MYKERNEL</replaceable></userinput></screen>

	<para>对于 &os; 5.0 以及更早的版本， 使用下面的形式：</para>

	<screen>&prompt.root; <userinput>cd ../../compile/<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>编译内核。</para>
	
	<screen>&prompt.root; <userinput>make depend</userinput>
&prompt.root; <userinput>make</userinput></screen>
      </step>

      <step>
	<para>安装新内核。</para>
	
	<screen>&prompt.root; <userinput>make install</userinput></screen>
      </step>
    </procedure>

    <procedure>
      <title>方法2. 用<quote>新的</quote>方法建立一个内核</title>
      
      <step>
	<para>切换到<filename>/usr/src</filename> 目录。</para>
	
	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
      </step>

      <step>
	<para>编译内核。</para>
	
	<screen>&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>安装新内核。</para>

	<screen>&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>
    </procedure>
    
    <note>
      <para>在&os;&nbsp;4.2老版本里面您必须用<literal>KERNEL=</literal>
      来替换<literal>KERNCONF=</literal>。2001年2月2日以后生成的4.2-STABLE
      就可以认出<literal>KERNCONF=</literal>。</para>
    </note>

    <indexterm>
      <primary><filename class="directory">/boot/kernel.old</filename></primary>
    </indexterm> 

    <para>新内核将会被复制到 <filename
        class="directory">/boot/kernel</filename> 目录中成为
      <filename>/boot/kernel/kernel</filename> 而旧的则被移到
      <filename>/boot/kernel.old/kernel</filename>。
      现在关闭系统， 然后用新的内核启动计算机。 如果出现问题，
      后面的一些 <link linkend="kernelconfig-trouble">故障排除方法</link>
      将帮您摆脱困境。 如果您的内核 <link
      linkend="kernelconfig-noboot">无法启动</link>， 请参考那一节。</para>

    <note>
      <para>在 &os; 4.X 以及更早的版本中， 内核被安装到
	<filename>/kernel</filename> 而模块则放到 <filename
          class="directory">/modules</filename>， 旧的内核则被备份到
	<filename>/kernel.old</filename>。
	其他与启动过程相关的文件， 如
	&man.loader.8; 以及配置则放在
	<filename>/boot</filename>。 第三方或定制的模块也可以放在
	<filename class="directory">/modules</filename>，
	不过应该注意保持模块和内核的同步时很重要的，
	否则会导致不稳定和错误。</para>
    </note>

    <note>
      <para>如果添加了新设备 (例如声卡)
	并在运行 &os;&nbsp;4.X 或更早的版本，
	则可能好需要在
	<filename class="directory">/dev</filename> 目录中添加它们的设备节点之后才能使用。
	欲了解详情，请参考本章稍后的 <link
	linkend="kernelconfig-nodes">制作设备节点</link>
	一节。</para>
    </note>
  </sect1>

  <sect1 id="kernelconfig-config">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Joel</firstname>
	  <surname>Dahl</surname>
	  <contrib>Updated for &os; 5.X by </contrib>
	  <!-- August 2004, PR docs/70674 -->
	</author>
	<!--  <editor><othername role="freefall login">ceri</othername></editor> -->
      </authorgroup>
    </sect1info>
    <title>配置文件</title>
    <indexterm>
      <primary>内核</primary>
      <secondary>NOTES</secondary>
    </indexterm>
    <indexterm>
      <primary>kernel</primary>
      <secondary>LINT</secondary>
    </indexterm>
    <indexterm><primary>NOTES</primary></indexterm>
    <indexterm><primary>LINT</primary></indexterm>
    <indexterm>
      <primary>内核</primary>
      <secondary>配置文件</secondary>
    </indexterm>

    <para>配置文件的格式是非常简单的。
      每一行都包括一个关键词， 以及一个或多个参数。
      实际上， 绝大多数行都只包括一个参数。
      在 <literal>#</literal> 之后的内容会被认为是注释而忽略掉。
      下面的每个小节，将依次介绍每个列在
      <filename>GENERIC</filename> 中的选项，
      当然， 一些相关的关键词 (如网络) 将被放在一起，
      尽管在 <filename>GENERIC</filename> 中可能分散在各处。 <anchor
      id="kernelconfig-options"> 如果需要与平台有关的选项和设备的详细列表，
      请参考与 <filename>GENERIC</filename> 在同一个目录中的那个<filename>NOTES</filename>，
      而平台无关的选项， 则可以在
      <filename>/usr/src/sys/conf/NOTES</filename>
      找到。</para>

    <note>
      <para><filename>NOTES</filename> 在 &os;&nbsp;4.X 中并不存在。
        与此相反， 请参考 <filename>LINT</filename> 文件来获得关于
        <filename>GENERIC</filename> 中的选项和设备详细介绍。
        <filename>LINT</filename> 在 4.X 中完成了两项使命：
        为构建定制内核提供可选的选项， 以及提供尽可能多的调整为非默认值的选项。
        这么做背后的原因是这种配置文件能够帮助 (并且仍然能)
        测试新代码以及现有代码的修改是否会造成与内核其他部分的冲突。
        然而， 内核配置的架构在 5.X 中经历了巨大的变化；
        其中的一个例子是设备驱动的选项被移到了 <literal>hints</literal>
        中， 从而可以随时修改并在启动时动态加载，
        而 <filename>LINT</filename> 不能再包含这些 hints 了。
        由于这个以及许多其他原因，
        决定将 <filename>LINT</filename> 改名为
        <filename>NOTES</filename>， 而保留它的主要是为了前面所说的第一个原因：
        给出可用的选项， 为用户提供方便。</para>

      <para>在 &os; 5.X 和以后的版本中您仍然可以通过下面的命令生成
	<filename>LINT</filename> 文件：</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf && make LINT</userinput></screen>
    </note>

    <indexterm>
      <primary>内核</primary>
      <secondary>配置文件例子</secondary>
    </indexterm>

    <para>下面是一个 <filename>GENERIC</filename>
      内核配置文件的例子， 它包括了一些需要解释的注释。
      这个例子应该和您复制的
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/GENERIC</filename>
      非常接近。</para>

    <programlisting>#
# GENERIC -- Generic kernel configuration file for &os;/i386
#
# For more information on this file, please read the handbook section on
# Kernel Configuration Files:
#
#    http://www.&os;.org/doc/en_US.ISO8859-1/books/handbook/kernelconfig-config.html
#
# The handbook is also available locally in /usr/share/doc/handbook
# if you've installed the doc distribution, otherwise always see the
# &os; World Wide Web server (http://www.FreeBSD.org/) for the
# latest information.
#
# An exhaustive list of options and more detailed explanations of the
# device lines is also present in the ../../conf/NOTES and NOTES files. 
# If you are in doubt as to the purpose or necessity of a line, check first 
# in NOTES.
#
# &dollar;FreeBSD: /repoman/r/ncvs/src/sys/i386/conf/GENERIC,v 1.413 2004/08/11 01:34:18 rwatson Exp &dollar;</programlisting>

    <para>下面这个选项在<emphasis>每个</emphasis>中都要有：</para>
    <indexterm>
      <primary>内核选项</primary>
      <secondary>机器</secondary>
    </indexterm>

    <programlisting>machine		i386</programlisting>

    <para>这是机器的架构， 他只能是
      <literal>alpha</literal>, <literal>amd64</literal>,
      <literal>i386</literal>, <literal>ia64</literal>,
      <literal>pc98</literal>, <literal>powerpc</literal>, 或
      <literal>sparc64</literal> 中的一种。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>cpu</secondary>
    </indexterm>
    <programlisting>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</programlisting>

    <para>上面的选项指定了您系统中所使用的 CPU 类型。
      您可以使用多个 CPU 类型 (例如，
      您不确定是应该指定
      <literal>I586_CPU</literal> 或 <literal>I686_CPU</literal>)。
      然而对于定制的内核， 最好能够只指定您使用的那种 CPU。
      如果您对于自己使用的 CPU 类型没有把握， 可以通过查看
      <filename>/var/run/dmesg.boot</filename> 中的启动信息来了解。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>cpu类型</secondary>
    </indexterm>
    <para>在&os;的内核里面仍然支持<literal>I386_CPU</literal>，但是在-STABLE和
      -CURRENT里面缺省已经被禁用了。这就意味着安装&os;在386-class的cpu， 
      一般有下面几种情况：</para>

    <itemizedlist>
      <listitem>
        <para>安装一个老的&os; release并且按照<xref linkend="kernelconfig-building">从源码重建系统.</para>
      </listitem>

      <listitem>
        <para>在一个新的机器上构建用户和内核程序，然后用已经编译好的<filename>/usr/obj</filename>下的文件
	安装到386的机器上(详细情况看<xref linkend="small-lan">)。</para>
      </listitem>

      <listitem>
        <para>定制您自己的 &os; 发行版本， 其中的安装光盘包含
          <literal>I386_CPU</literal> 支持。</para>
      </listitem>
    </itemizedlist>

    <para>第一种情况可能是最容易的， 但您需要大量的磁盘空间，
      而 386-级别拥有这种配置的计算机可能很难找到。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>ident</secondary>
    </indexterm>

    <programlisting>ident          GENERIC</programlisting>

    <para>这是内核的名字。 您应该取一个自己的名字，
      例如取名叫 <literal>MYKERNEL</literal>，
      如果您一直在按照前面的说明做的话。
      您放在
      <literal>ident</literal> 后面的字符串在启动内核时会显示出来，
      因此如果希望能够容易区分常用的内核和刚刚定制的内核，
      就应该采取不同的名字 (例如， 您想定制一个试验性的内核)。</para>
    <indexterm>
      <primary>内核选项</primary>
      <secondary>maxusers</secondary>
    </indexterm>

    <programlisting>maxusers          <replaceable>n</replaceable></programlisting>

    <para>这个 <literal>maxusers</literal> 选项设置了重要系统表的大小。
      这个数值粗略地假设您的机器同时会有多少用户。</para>

    <para>从&os;&nbsp;4.5开始，如果手动设置这个值为<literal>0</literal>系统将会自动赋值。<footnote>
	<para>自动赋值算法是设置<literal>maxusers</literal>等于系统的内存总量，最小到32，最大到384。
	</para></footnote>.
      在&os;&nbsp; 5.X 和更高版本中，<literal>maxusers</literal> 如果没有定义，将缺省为
      <literal>0</literal>。如果您使用的&os;早于4.5, 或者您想自己设置这个值，
     那么您至少要设置<literal>maxusers</literal>为4, 特别是您要执行X Window或是编译程序。
     原因是<literal>maxusers</literal>值决定了系统同时可有多少个进程(process)，
     其算法是<literal>20 + 16 * maxusers</literal>，所以如果您设置<literal>maxusers</literal>为1，
      则您的系统只能同时存在36个进程，包括18个(或更多)系统启动要占去的进程。
      如果您执行了X Window，则又要用掉15个以上。甚至阅读一个man page也会使用九个进程来过滤、解压缩、然后显示文件。
     设置<literal>maxusers</literal>到64将允许您有1044个进程，对任何人应该都是足够的。
     当您执行程序时， 得到像是<errortype>proc table full</errortype>这样的错误信息，
     或者您要建一个同时会有很多人来访问的网站（比如<hostid role="fqdn">ftp.FreeBSD.org</hostid>）时，
     您就要增加这个设置的值，然后重新编译内核。</para>

    <note>
      <para><literal>maxusers</literal> 并 <emphasis>不会</emphasis>
	限制能够登录到您机器上的用户数量。
	它只是简单地设置一些系统表的尺寸，
	以适应您的系统中登录这样多的用户时能够执行的最大进程数。
	<emphasis>确实</emphasis> 会限制同时能够登录的远程用户以及
	X 终端窗口的关键字是 <link
	linkend="kernelconfig-ptys"><literal>pseudo-device pty
	16</literal></link>。 在 &os;&nbsp;5.X 中， 您并不需要担心这个数值，	因为 &man.pty.4; 驱动提供了
	<quote>自动克隆(auto-cloning)</quote> 的能力；
	在配置文件中您只需简单地指定
	<literal>device pty</literal> 就可以了。</para>
    </note>
    
    <programlisting># Floating point support - do not disable.
device          npx</programlisting>
    
    <para><literal>npx</literal> 是 &os; 中浮点运算单元的接口，
      用于支持硬件的浮点运算协处理器， 以及软件仿真程序。
      这个设置 <emphasis>不是</emphasis>
      可有可无的。</para>

    <programlisting># Pseudo devices
device   loop          # Network loopback</programlisting>

    <para>这是 TCP/IP 的通用回环设备。 如果您 telnet
      或 FTP 到 <hostid>localhost</hostid> (也就是 <hostid
      role="ipaddr">127.0.0.1</hostid>) 则将通过这个设备回到本机。
      这个设备是 <emphasis>必需的</emphasis>。 在
      &os;&nbsp;4.X 中， 则应使用 <literal>pseudo-device
      loop</literal>。</para>

    <para>接下来的那些项有一个或多个选项，关于每个选项的更多的信息参考下面注释。</para>

    <programlisting>#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         # Default places to look for devices.</programlisting>

    <para>在&os; 5.X和更新的版本里面，&man.device.hints.5;被用来配置设备驱动选项。
    在启动的时候&man.loader.8;将会检查缺省位置<filename>/boot/devicehints</filename>。 
    使用<literal>hints</literal>选项您就可以把这些hints静态编译进内核。
    这样就没有必要在<filename>/boot</filename>下创建<filename>devicehints</filename>。
    </para>

    <!-- XXX: Add a comment here that explains when compiling hints into
      the kernel is a good idea and why. -->

    <programlisting>#makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</programlisting>

    <para>一般的 &os; 构建过程并不包括调试信息，
      在构建内核时， 绝大多数符号会在最终的内核连接之后剔除出去，
      以节省安装时所需的空间。 如果您打算测试 -CURRENT 分支的内核，
      或开发您自己的 &os; 内核功能， 则可能会需要去掉这一行的注释。
      这将启用 <option>-g</option> 选项， 它会在 &man.gcc.1;
      中打开调试信息。 如果您使用 <quote>传统</quote>
      方法来构建内核， 也可以通过 &man.config.8; 的
      <option>-g</option> 选项来达到同样的目的
      (参见 <xref linkend="kernelconfig-building">
      了解进一步的信息)。</para>

    <programlisting>options          SCHED_4BSD         # 4BSD scheduler</programlisting>

    <para>这是 &os; 的传统调度器。 取决于您系统的工作负荷，
      使用新的 ULE 调度器通常可以获得更好的性能。 它是专门为
      &os; 在 SMP 上运行而设计的调度器， 但在 UP
      系统上也能工作得很好。 如果您想试验这个功能，
      则应把配置文件中的 <literal>SCHED_4BSD</literal>
      改为 <literal>SCHED_ULE</literal>。</para>

    <programlisting>options          INET              # InterNETworking</programlisting>

    <para>网络支持，即使您不打算连网，也请保留它，大部分的程序至少需要回环网络（就是和本机进行网络连接），所以强烈要求保留它。
    </para>

    <programlisting>options          INET6             # IPv6 communications protocols</programlisting>

    <para>这将打开IPv6连接协议。</para>

    <programlisting>options          FFS               # Berkeley Fast Filesystem</programlisting>

    <para>这是最基本的硬盘文件系统，如果打算从本地硬盘启动，请保留它。</para>

    <programlisting>options          UFS_ACL           # Support for access control lists</programlisting>

    <para>这个选项只能在 &os;&nbsp;5.X 和更高版本中使用，
      它将启用内核中的访问控制表的支持。
      这依赖于扩展属性以及 <acronym>UFS2</acronym>，
      以及在 <xref linkend="fs-acl"> 中所介绍的那些特性。
      <acronym>ACL</acronym> 默认是启用的，
      并且如果已经在文件系统上使用了这一特性，
      就不应再关掉它， 因为这会去掉文件的访问控制表，
      并以不可预期的方式改变受保护的文件的访问方式。</para>

    <programlisting>options          UFS_DIRHASH       # Improve performance on big directories</programlisting>

    <para>通过使用额外的内存，这个选项可以加速在大目录上的磁盘操作。
    您应该在大型服务器和频繁使用的工作站上打开这个选项，而在磁盘操作不是很重要的
    小型系统上关闭它，比如防火墙。</para>

    <programlisting>options          SOFTUPDATES       # Enable FFS Soft Updates support</programlisting>

    <para>这个选项将启用内核的 Soft Updates，
      它有助于提高磁盘的写操作速度。
      尽管这个功能是内核提供的， 仍然需要对具体的磁盘打开它。
      请查看 &man.mount.8; 的输出以了解
      Soft Updates 是否已经在您的系统磁盘上启用了。
      如果您没有看到 <literal>soft-updates</literal>
      挂接选项， 则需要通过使用 &man.tunefs.8; (对于已经存在的文件系统)
      或 &man.newfs.8; (对于新的文件系统) 命令来激活它。</para>

    <programlisting>options          MD_ROOT           # MD is a potential root device</programlisting>

    <para>这个选项将打开以基于内存的虚拟磁盘作为根设备的支持。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>NFS</secondary>
    </indexterm>
    <indexterm>
      <primary>内核选项</primary>
      <secondary>NFS_ROOT</secondary>
    </indexterm>
    <programlisting>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</programlisting>

    <para>网络文件系统。 如果您不打算通过 TCP/IP 挂接
      &unix; 文件服务器的分区， 就可以注释掉它。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>MSDOSFS</secondary>
    </indexterm>
    <programlisting>options          MSDOSFS           # MSDOS Filesystem</programlisting>

    <para>&ms-dos; 文件系统。 只要您不打算在启动时挂接由 DOS 格式化的硬盘分区，
      就可以把它注释掉。
      如前面所介绍的那样， 在您第一次挂接 DOS 分区时，
      内核会自动加载需要的模块。 此外，
      <filename role="package">emulators/mtools</filename>
      软件提供了一个很方便的功能，
      通过它您可以直接访问 DOS 软盘而无需挂接或卸下它们
      (而且也完全不需要 <literal>MSDOSFS</literal>)。</para>

    <programlisting>options          CD9660            # ISO 9660 Filesystem</programlisting>

    <para>用于 CDROM 的 ISO 9660 文件系统。 如果没有 CDROM
      驱动器或很少挂接光盘数据 (因为在首次使用数据 CD 时会自动加载)，
      就可以把它注释掉。 音乐 CD 并不需要这个选项。</para>

    <programlisting>options          PROCFS            # Process filesystem</programlisting>

    <para>进程文件系统。 这是一个挂接在 <filename>/proc</filename>
      的一个 <quote>伪装的</quote> 文件系统，
      允许类似 &man.ps.1; 这样的程序给出正在运行的进程的更多信息。
      在 &os; 5.X 和更高版本中， 绝大多数情况下都不再需要
      <literal>PROCFS</literal>，
      因为绝大多数调试和监视工具都已经进行了修改，
      不再需要 <literal>PROCFS</literal>： 与 &os; 4.X
      不同， 新安装的 &os; 5.X 默认情况下并不挂接它。
      此外， 6.X-CURRENT 内核在使用
      <literal>PROCFS</literal> 时还必须加入
      <literal>PSEUDOFS</literal> 的支持：</para>

    <programlisting>options          PSEUDOFS          # Pseudo-filesystem framework</programlisting>

    <para><literal>PSEUDOFS</literal> 在 &os; 4.X 上不可用。</para>

    <programlisting>options          GEOM_GPT          # GUID Partition Tables.</programlisting>

    <para>这个选项提供了在一个磁盘上使用大量的分区的能力。</para>

    <programlisting>options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]</programlisting>

    <para>使系统兼容4.3BSD。不要去掉这一行，不然有些程序将无法正常运行。
    </para>

    <programlisting>options          COMPAT_FREEBSD4   # Compatible with &os;4</programlisting>

    <para>为了支持在旧版本的&os;下编译的程序，该选项在&os;&nbsp;5.X &i386;和Alpha systems下需要打开。
    最好在所有的&i386;和Alpha systems下打开这个选项，因为可能要运行老应用程序。
    在5.X才开始支持的平台，比如ia64和&sparc64;，就不需要这个选项。</para>

    <programlisting>options          SCSI_DELAY=15000  # Delay (in ms) before probing SCSI</programlisting>

    <para>这将让内核在探测每个 SCSI 设备之前等待 15 秒。
      如果您只有 IDE 硬盘驱动器， 则可以不管它，
      反之您可能会想降低这个数值， 可能减少到 5 秒，
      以加速启动过程。 当然， 如果您这么做之后
      &os; 在识别您的 SCSI 设备时遇到问题，
      则您还需要再把它改回去。</para>

    <programlisting>options          KTRACE            # ktrace(1) support</programlisting>

    <para>这个选项打开内核进程跟踪，在调试时很有用。
    </para>

    <programlisting>options          SYSVSHM           # SYSV-style shared memory</programlisting>

    <para>提供System&nbsp;V共享内存(SHM)的支持，最常用到SHM的应该是X Window的XSHM延伸，
    不少绘图相关程序会自动使用SHM来提供额外的速度。如果您要使用X Window，您最好加入这个选项。
    </para>

    <programlisting>options          SYSVSEM           # SYSV-style semaphores</programlisting>

    <para>支持System&nbsp;V 信号量，不常用到，只在kernel中占用几百个字节的空间。</para>

    <programlisting>options          SYSVMSG           # SYSV-style message queues</programlisting>

    <para>支持 System&nbsp;V 消息。 同样地， 这只会在内核中增加数百字节的空间占用。</para>

    <note>
      <para>&man.ipcs.1; 命令的 <option>-p</option> 选项可以显示出任何用到这些
	System&nbsp;V 机制的进程。</para>
    </note>

    <programlisting>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</programlisting>

    <para>在1993年&posix;添加的实时扩展.  在ports collection中某些应用程序会用到这些
    （比如<application>&staroffice;</application>）。
    </para>

    <programlisting>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</programlisting>

    <para>这个选项与键盘有关。 它在 <filename>/dev</filename>
      中安装一个 CDEV 项。</para>

    <programlisting>options          AHC_REG_PRETTY_PRINT     # Print register bitfields in debug
                                          # output.  Adds ~128k to driver.
options          AHD_REG_PRETTY_PRINT     # Print register bitfields in debug
                                          # output.  Adds ~215k to driver.</programlisting>

    <para>这个选项主要用于帮助调试， 它能够给出更容易阅读的寄存器数值。</para>

    <programlisting>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</programlisting>

    <para>这个选项使得内核全局锁 (Giant) 按照和其它 mutex 类似的方式自适应地自旋。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>SMP</secondary>
    </indexterm>
    <programlisting># To make an SMP kernel, the next two are needed
options         SMP                # Symmetric MultiProcessor Kernel
device          apic               # I/O APIC</programlisting>

    <para>上述两个选项是 SMP 支持所必需的，
      在单处理器的机器上可以去掉它们。</para>

    <programlisting>device          isa</programlisting>

    <para>所有为 &os; 所支持的 PC 都需要这个设置，
      即使没有 ISA 插槽也是一样。 如果您使用
      IBM PS/2 (微通道架构) 的计算机， &os; 目前只能提供有限的支持。
      要了解关于 MCA 支持的详情， 请参考
      <filename>/usr/src/sys/i386/conf/NOTES</filename>。</para>

    <programlisting>device          eisa</programlisting>

    <para>如果您的主机板上有EISA总线，加入这个设置。使用这个选项可以自动扫描并设置所有连接在EISA总线上的设备。</para>

    <programlisting>device          pci</programlisting>

    <para>如果您的主板有PCI总线，就加入这个选项。使用这个选项可以自动扫描PCI卡，并在PCI到ISA之间建立通路。</para>

    <programlisting>device          agp</programlisting>

    <para>如果您有图形加速卡（AGP card），这个选项将打开图形加速支持。</para>

    <programlisting># Floppy drives
device          fdc</programlisting>

    <para>这是软驱控制器。</para>

    <programlisting># ATA and ATAPI devices
device          ata</programlisting>

    <para>这个驱动器支持所有ATA和ATAPI设备。您只要在内核中加入<literal>device ata</literal>选项，
    就可以让内核支持现代计算机上的所有PCI ATA/ATAPI设备。
    </para>

    <programlisting>device          atadisk                 # ATA disk drives</programlisting>

    <para>这个是ATAPI 磁盘驱动器所必须的。</para>

    <programlisting>device          ataraid                 # ATA RAID drives</programlisting>

    <para>这个选项需要 <literal>device ata</literal>， 它用于 ATA
      RAID 驱动。</para>

    <programlisting><anchor id="kernelconfig-atapi">
device          atapicd                 # ATAPI CDROM drives</programlisting>

    <para>这个是ATAPI CDROM驱动器所必须的。</para>

    <programlisting>device          atapifd                 # ATAPI floppy drives</programlisting>

    <para>这个是ATAPI 磁盘驱动器所必须的。</para>

    <programlisting>device          atapist                 # ATAPI tape drives</programlisting>

    <para>这个是ATAPI 磁带机驱动器所必须的.</para>

    <programlisting>options         ATA_STATIC_ID           # Static device numbering</programlisting>

    <para>这指定对控制器使用其静态的编号； 如果没有这个选项，
      则会动态地分配设备的编号。</para>

    <programlisting># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets)
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</programlisting>

    <para>SCSI控制器。可以注释掉您系统中没有的设备。如果您只有IDE设备，您可以把这些一起删掉。</para>

    <programlisting># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</programlisting>

    <para>SSCSI外围设备。也可以像上面一样操作。</para>

    <note>
      <para>目前系统提供的 USB &man.umass.4; 驱动 (以及少量其它驱动) 使用了
	SCSI 子系统， 尽管它们并不是真的 SCSI 设备。
	因此， 如果在内核配置使用了这类驱动程序， 请务必不要删除
	SCSI 支持。</para>
    </note>

    <programlisting># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</programlisting>

    <para>支持RAID控制器。如果您没有这些，可以把它们注释掉或是删掉。</para>

    <programlisting># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</programlisting>

    <para>键盘控制器（<literal>atkbdc</literal>）提供AT键盘输入以及PS/2指针设备的I/O服务。
    键盘驱动程序（<literal>atkbd</literal>）与PS/2鼠标驱动程序（<literal>psm</literal>）需要这个控制器，所以不要删除它。
    </para>

    <programlisting>device          atkbd      # AT keyboard</programlisting>

    <para><literal>atkbd</literal>驱动程序，与<literal>atkbdc</literal>控制器一起使用，
    提供连接到AT键盘控制器的AT 84键盘与AT加强型键盘的访问服务。
   </para>

    <programlisting>device          psm        # PS/2 mouse</programlisting>

    <para>如果您的鼠标连接到PS/2鼠标端口，就使用这个设备驱动程序。</para>

    <programlisting>device          vga        # VGA video card driver</programlisting>

    <para>显卡驱动。</para>

    <programlisting># splash screen/screen saver
device          splash     # Splash screen and screen saver support</programlisting>

    <para>启动时出现了 splash 画面！屏幕保护程序也需要它。
      在 &os;&nbsp;4.X 中，应写作 <literal>pseudo-device splash</literal> 。</para>

    <programlisting># syscons is the default console driver, resembling an SCO console
device          sc</programlisting>

    <para><literal>sc</literal> 是默认的控制台驱动程序， 类似 SCO 控制台。
      由于绝大部分全屏幕程序都通过类似
      <filename>termcap</filename> 这样的终端数据库函数库赖访问控制台，
      因此无论您使用这个或与 <literal>VT220</literal> 兼容的
      <literal>vt</literal> 都没有什么关系。
      如果您在运行这种控制台时使用全屏幕程序时发生问题， 清在登录之后将
      <envar>TERM</envar> 变量设置为 <literal>scoansi</literal>。</para>

    <programlisting># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</programlisting>

    <para>这是一个兼容 VT220 的控制台驱动， 它同时能够向下兼容
      VT100/102。 在同 <literal>sc</literal>
      硬件不兼容的一些笔记本上它能够运行的很好。
      当然， 登录系统时请把
      <envar>TERM</envar> 变量设置为 <literal>vt100</literal> 或
      <literal>vt220</literal>。
      此驱动在连接网络上大量不同的机器时也被证明非常有用，
      因为此时 <filename>termcap</filename> 或
      <filename>terminfo</filename> 通常没有可用的
      <literal>sc</literal> 设备 &mdash; 而 <literal>vt100</literal>
      则几乎每种平台都支持。</para>

    <programlisting># Power management support (see NOTES for more options)
#device          apm</programlisting>

    <para>Advanced Power Management support.  Useful for laptops,
      although in &os; 5.X and above this is disabled in
      <filename>GENERIC</filename> by default.</para>

    <programlisting># Add suspend/resume support for the i8254.
device           pmtimer</programlisting>

    <para>用于电源管理事件， 例如 APM 和 ACPI 的时钟设备驱动。</para>

    <programlisting># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</programlisting>

    <para>PCMCIA支持。如果您使用膝上型计算机，您需要这个。</para>

    <programlisting># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</programlisting>

    <para>这些串口在 &ms-dos;/&windows; 的世界中称为
      <devicename>COM</devicename> 口。</para>

    <note>
      <para>如果使用内置式的调制解调器， 并占用 <devicename>COM4</devicename>
	而您另有一个串口在 <devicename>COM2</devicename>， 则必须把调制解调器的
	IRQ 改为 2 (由于晦涩的技术原因，
	IRQ2 = IRQ 9) 才能够在 &os; 中访问它。
	如果有多口的串口卡， 请参考 &man.sio.4; 以了解需要在
	<filename>/boot/device.hints</filename> 中进行的设置。
	某些显卡 (特别是基于 S3 芯片的卡) 使用形如 <literal>0x*2e8</literal>
	的 IO 地址， 而许多廉价的串口卡不能够正确地对 16-位
	IO 地址空间进行解码， 因此它们会产生冲突，
	并造成 <devicename>COM4</devicename> 实际上无法使用。</para>

      <para>每一个串口都需要有一个唯一的 IRQ (除非您使用支持中断分享的串口卡)，
        因此默认的 <devicename>COM3</devicename>
	和 <devicename>COM4</devicename> IRQ 是不能使用的。</para>
    </note>

    <programlisting># Parallel port
device          ppc</programlisting>

    <para>ISA-bus并行接口。</para>

    <programlisting>device          ppbus      # Parallel port bus (required)</programlisting>

    <para>提供并行总线的支持。</para>

    <programlisting>device          lpt        # Printer</programlisting>

    <para>提供并口打印机的支持。</para>

    <note>
      <para>要使用并口打印机，就必须同时加入上面三行设置。</para>
    </note>

    <programlisting>device          plip       # TCP/IP over parallel</programlisting>

    <para>这是针对并行网络接口的驱动器。</para>

    <programlisting>device          ppi        # Parallel port interface device</programlisting>

    <para>普通用途的I/O (<quote>geek port</quote>) + IEEE1284 I/O.</para>

    <programlisting>#device         vpo        # Requires scbus and da</programlisting>

    <indexterm><primary>zip drive</primary></indexterm>
    <para>这是针对Iomega Zip驱动器的。它要求<literal>scbus</literal>和<literal>da</literal>的支持。
    最好的执行效果是工作在EPP 1.9模式。
    </para>

    <programlisting>#device         puc</programlisting>

    <para>如果您有由 &man.puc.4; 支持的 <quote>哑</quote>
      串行或并行 PCI 卡， 则应去掉这一行的注释。</para>

    <programlisting># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (<quote>Tulip</quote>)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (<quote>Typhoon</quote>)
device          vx         # 3Com 3c590, 3c595 (<quote>Vortex</quote>)</programlisting>

    <para>多种PCI网卡驱动器。注释或删除您系统中没有的设备.</para>

    <programlisting># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support</programlisting>

    <para>MII总线支持对于一些PCI 10/100 Ethernet NIC来说是必需的。
    </para>

    <programlisting>device          dc         # DEC/Intel 21143 and various workalikes
device          miibus     # MII bus support
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (<quote>Starfire</quote>)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x & SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 <quote>EPIC</quote>)
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (<quote>Boomerang</quote>, <quote>Cyclone</quote>)</programlisting>

    <para>使用MII总线控制器代码的驱动器。</para>

    <programlisting># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</programlisting>

    <para>ISA 以太网卡驱动。 参见
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/NOTES</filename>
      以了解关于哪个驱动程序能够驱动您的网卡的细节。</para>

    <programlisting># Wireless NIC cards
device          wlan       # 802.11 support
device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          awi        # BayStack 660 and others
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</programlisting>

    <para>Support for various wireless cards.</para>

    <programlisting>device   mem           # Memory and kernel memory devices</programlisting>

    <para>The system memory devices.</para>

    <programlisting>device   io            # I/O device</programlisting>

    <para>This option allows a process to gain I/O privileges. This is
      useful in order to write userland programs that can handle hardware
      directly.  This is required to run the X Window system.</para>

    <programlisting>device   random        # Entropy device</programlisting>

    <para>Cryptographically secure random number generator.</para>

    <programlisting>device   ether         # Ethernet support</programlisting>

    <para><literal>ether</literal> 只有在使用以太网卡时才需要。
      它包含了通用的以太网协议代码。在
      &os;&nbsp;4.X 中应写作 <literal>pseudo-device
      ether</literal>.</para>

    <programlisting>device   sl            # Kernel SLIP</programlisting>

    <para><literal>sl</literal> 用以提供 SLIP 支持。
      目前它几乎已经完全被 PPP 取代了， 因为后者更容易配置，
      而且更适合调制解调器之间的连接， 并提供了更强大的功能。
      在 &os;&nbsp;4.X 中， 这一行应写作 <literal>pseudo-device
      sl</literal>.</para>

    <programlisting>device   ppp           # Kernel PPP</programlisting>

    <para>这一选项用以提供内核级的 PPP 支持， 用于拨号连接。
      也有以用户模式运行的 PPP 实现， 使用
      <literal>tun</literal> 并提供包括按需拨号在内的更为灵活的功能。
      在 &os;&nbsp;4.X 中应写作
      <literal>pseudo-device ppp</literal>.</para>

    <programlisting>device   tun           # Packet tunnel.</programlisting>

    <para>它会被用户模式的 PPP 软件用到。
      参考本书的 <link linkend="userppp">PPP</link> 以了解更多的细节。
      在 &os;&nbsp;4.X 中则应使用 <literal>pseudo-device
      tun</literal>。</para>

    <programlisting><anchor id="kernelconfig-ptys">
device   pty           # Pseudo-ttys (telnet etc)</programlisting>

    <para>这是一个 <quote>pseudo-terminal</quote> 或模拟登入端口。
      它用来接收连入的 <command>telnet</command> 以及
      <command>rlogin</command> 会话、
      <application>xterm</application>， 以及一些其它程序如
      <application>Emacs</application> 等。</para>

    <note><para>在 &os;&nbsp;4.X 中，
      您应该使用 <literal>pseudo-device pty
      <replaceable>number</replaceable></literal>。 <literal>pty</literal>
      后面的 <replaceable>number</replaceable> 用于指定要创建的
      <literal>pty</literal> 数量。 如果您需要多于默认的同时
      16 个 <application>xterm</application> 窗口或远程登录会话，
      则应相应的提高这个值， 其上限是 256。</para></note>

    <programlisting>device   md            # Memory <quote>disks</quote></programlisting>

    <para>Memory disk pseudo-devices.  With &os;&nbsp;4.X use the
      line <literal>pseudo-device md</literal>.</para>

    <programlisting>device   gif           # IPv6 and IPv4 tunneling</programlisting>

    <para>它实现了在 IPv4 上的 IPv6 隧道、 IPv6 上的 IPv4 隧道、
      IPv4 上的 IPv4 隧道、 以及IPv6 上的 IPv6隧道。
      从 &os;&nbsp;4.4 开始 <literal>gif</literal> 设备具有了
      <quote>自动克隆</quote> 能力， 因此只需指定
      <literal>pseudo-device gif</literal>。
      更早版本的 &os;&nbsp;4.X 需要手工指定一个数字， 例如
      <literal>pseudo-device gif 4</literal>。</para>

    <programlisting>device   faith         # IPv6-to-IPv4 relaying (translation)</programlisting>

    <para>这个伪设备能捕捉发给它的数据包，并把它们转发给
      IPv4/IPv6 翻译服务程序。在
      &os;&nbsp;4.X 中，应写作
      <literal>pseudo-device faith 1</literal>。</para>

    <programlisting># The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
device   bpf           # Berkeley packet filter</programlisting>

    <para>这是 Berkeley 包过滤器。这个伪设备允许网络接口被置于混杂模式，
      从而，截获广播网 (例如，以太网) 上的每一个数据包。
      截获的数据报可以保存到磁盘上，也可以使用 &man.tcpdump.1; 程序来分析。
      在 &os;&nbsp;4.X 中，应写作
      <literal>pseudo-device bpf</literal>。</para>

    <note>
      <para>&man.bpf.4; 设备也被用于
	&man.dhclient.8; 来获取默认路由器(网关)的 IP 地址。如果使用DHCP，就不要注释掉这行。</para>
    </note>

    <programlisting># USB support
#device         uhci          # UHCI PCI-&gt;USB interface
#device         ohci          # OHCI PCI-&gt;USB interface
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # <quote>Human Interface Devices</quote>
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</programlisting>

    <para>支持各类 USB 设备。</para>

    <programlisting># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</programlisting>

    <para>支持各类火线设备。</para>

    <para>要了解 &os; 所支持的设备的其他情况， 请参考
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/NOTES</filename>。</para>

      <sect2>
        <title>大内存支持(<acronym>PAE</acronym>)</title>
	<indexterm>
	  <primary>
	    物理地址扩展 (<acronym>PAE</acronym>)
	  </primary>
	  <secondary>
	    大内存支持的配置
	  </secondary>
	</indexterm>

	<para>大内存配置的机器需要超过４GB的虚拟地址。
	因为4GB的限制，Intel在&pentium;及后续的CPUs上增加了36位物理地址的支持。
	</para>
	
	<para>&intel; &pentium; Pro和后续的CPUs允许内存地址扩展到64GB.(<acronym>PAE</acronym>)
	  &os;通过<option>PAE</option>选项来支持这个能力。
	 在&os; 4.X系列里面，4.9-RELEASE开始支持，&os; 5.X系列里面，从5.1-RELEASE开始支持。
	  in the 4.X series of &os; beginning with 4.9-RELEASE and
	  in the 5.X series of &os; beginning with 5.1-RELEASE。因为Intel架构的限制，
	  高于或低于4GB都没有什么区别，内存分配到大于4GB仅仅是增加了可利用的内存池。
	  </para>

	<para>为了让内核支持<acronym>PAE</acronym>，只要增加下面这一行到配置文件：</para>
	
	<programlisting>options		    PAE</programlisting>

	<note>
	  <para><acronym>PAE</acronym>在&os;里面现在只能支持 &intel; IA-32处理器。
	  同时，还应该注意，&os;的<acronym>PAE</acronym>支持没有经过广泛的测试，
	  和其他稳定的特性相比只能当作是beta版。</para>
	</note>

	<para><acronym>PAE</acronym>在&os;下有如下的一些限制：</para>
	
	<itemizedlist>
	  <listitem>
	    <para>进程不能接触大于4GB的VM空间。</para>
	  </listitem>

	  <listitem>
	    <para><acronym>KLD</acronym> 模块不能加载到一个打开了<acronym>PAE</acronym>支持的内核里面，
	    这是因为内核模块和内核的建立框架不一样。</para>
	  </listitem>

	  <listitem>
	    <para>没有使用&man.bus.dma.9;界面的设备驱动程序在打开了<acronym>PAE</acronym>支持的内核里面
	    会导致数据腐化（corruption）。因为这个原因，&os; 5.X的<filename>PAE</filename>内核配置文件
	      把所有在打开了<acronym>PAE</acronym>的内核上不能工作的驱动程序排除在外。
	      </para>
	  </listitem>

	  <listitem>
	    <para>一些系统打开了探测系统内存资源使用能力的功能，因为打开了
	    <acronym>PAE</acronym>支持，这些功能可能会被覆盖掉。
	      其中一个例子就是内核参数<option>kern.maxvnodes</option>，它是控制
	      内核能使用的最大vnodes数目的，建议重新调整它及其他类似参数到合适的值。</para>
	  </listitem>

	  <listitem>
	    <para>为了避免<acronym>KVA</acronym>的消耗，很有必要增加系统的内核虚拟地址，
	    或者减少很耗系统资源的内核选项的总量（看上面）。<option>KVA_PAGES</option>选项
	    可以用来增加<acronym>KVA</acronym>空间。
	    </para>
	  </listitem>
	</itemizedlist>

	<para>为了稳定和高性能，建议查看&man.tuning.7;手册页。&man.pae.4;手册页包含
	&os;'s<acronym>PAE</acronym>支持的最新信息。
        </para>
    </sect2>
  </sect1>

  <sect1 id="kernelconfig-nodes">
    <title>创建设备节点</title>

    <indexterm><primary>设备节点</primary></indexterm>
    <indexterm>
      <primary><command>MAKEDEV</command></primary>
    </indexterm>

    <para><emphasis>如果您在运行 &os;&nbsp;5.0 或更高版本，
      则可以略过这节。 新版本使用
      &man.devfs.5; 来分配设备节点， 这一过程对用户是透明的。</emphasis></para>

    <para>内核中的几乎每个设备在 <filename>/dev</filename> 目录中都有对应的
      <quote>节点</quote> 项。 这些节点看上去像是普通的文件，
      但事实上却是程序在使用对应的设备时， 与内核联系的入口。
      Shell 脚本 <filename>/dev/MAKEDEV</filename>
      在首次安装操作系统时会创建几乎所有能够支持的设备节点。
      然而， 它并不会创建 <emphasis>所有的</emphasis> 节点，
      因此当您增加了某些设备的支持时， 就需要检查这个目录中是否有对应的项了，
      如果没有， 就应该添加它们。 这有一个简单的例子：</para>

    <para>假定在内核中加入了IDE CD-ROM的支持。可以这样加入：</para>

    <programlisting>device acd0</programlisting>

    <para>这意味着您应当在<filename>/dev</filename>目录下找一些以<filename>acd0</filename>为起点的入口，
    通常后面有一个字母，像是以<literal>c</literal>，或者<literal>r</literal>开头，表示这是一个<quote>raw</quote>设备。
    如果那些文件不在那儿，就必须改变到<filename>/dev</filename>目录然后键入：</para>

    <indexterm>
      <primary><command>MAKEDEV</command></primary></indexterm>
    <screen>&prompt.root; <userinput>sh MAKEDEV acd0</userinput></screen>

    <para>这些脚本完成后，您要在<filename>/dev</filename>目录下确认有<filename>acd0c</filename>和
    <filename>racd0c</filename>等几个入口，这表示程序已经正确执行。
    </para>

    <para>以下是加入声卡节点的例子：</para>

    <screen>&prompt.root; <userinput>sh MAKEDEV snd0</userinput></screen>

    <note>
      <para>当创建完诸如声卡这样的设备节点时，如果其他人有权访问您的机器，
      可能有必要在<filename>/etc/fbtab</filename>文件中添加这些节点来保护系统安全。
      更多的信息参考&man.fbtab.5;
      </para>
    </note>

    <para>依上述的简单程序，建立任何不在<filename>GENERIC</filename>里的硬件设备节点
      </para>

    <note>
      <para> 所有的SCSI控制器都使用一样的设备节点，所以您无须重新建立节点。
      另外，网卡与SLIP/PPP虚拟设备并没有任何设备节点，所以您不必担心怎么建立节点。
      </para>
    </note>
  </sect1>

  <sect1 id="kernelconfig-trouble">
    <title>如果出现问题怎么办</title>

    <para>在定制一个内核时，可能会出现五种问题。它们是：</para>

    <variablelist>
      <varlistentry>
	<term><command>config</command>失败：</term>

	<listitem>
	  <para>如果 &man.config.8; 在给出您的内核描述时失败，
	    则可能在某些地方引入了一处小的错误。
	    幸运的是， &man.config.8; 会显示出它遇到问题的行号，
	    这样您就能够迅速地定位错误。 例如， 如果您看到：</para>

	  <screen>config: line 17: syntax error</screen>

	  <para>可以通过与 <filename>GENERIC</filename> 或其他参考资料对比，
	    来确定这里的关键词是否拼写正确。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>make</command>失败：</term>

	<listitem>
	  <para>如果 <command>make</command> 命令失败，
	    它通常表示内核描述中发生了 &man.config.8; 无法找出的的错误。
	    同样地， 仔细检查您的配置， 如果仍然不能解决问题，
	    发一封邮件到 &a.questions; 并附上您的内核配置，
	    则问题应该很快就能解决。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>安装新内核失败：</term>
	
	<listitem>
	  <para>如果内核编译得很顺利， 但安装失败
	    (即 <command>make install</command> 或
	    <command>make installkernel</command> 命令失败)，
	    第一件事是检查您的系统是否是以 1 或更高的安全级运行的
	    (参见 &man.init.8;)。 内核安装过程将尝试去掉原有内核的
	    immutable (不可改) 标志， 并在新的内核上设置它。
	    由于安全级 1 或更高的安全级会阻止修改系统中任何文件的这个标志，
	    因此安装内核需要 0 或者更低的安全级。</para>

	  <para>不过这只对 &os; 4.X 以及更早的版本有效。
	    &os; 5.X 以及之后的版本并不会给内核设置不可改标志，
	    因此安装失败可能说明发生了更深层次的问题。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>内核无法启动：<anchor
	  id="kernelconfig-noboot"></term>

	<listitem>
	  <para>如果您的内核无法启动， 或不识别您的设备， 千万别慌！
	    非常幸运的是， &os; 有一个很好的机制帮助您从不兼容的内核恢复。
	    在 &os; 启动加载器那里简单地选择一下要启动的内核就可以了。
	    当系统在引导菜单的 10 秒倒计时时进入它。 按下除了
            <keycap>Enter</keycap> 之外的任意键， <command>unload</command>
            然后输入
	    <command>boot /boot/<replaceable>kernel.old</replaceable>/kernel</command>，
            或者其他任何一个可以正确引导的内核即可。
            当重新配置内核时， 保持一个已经证明能够正常启动的内核永远是一个好习惯。</para>

	  <para>当使用好的内核启动之后您可以检查配置文件并重新尝试编译它。
	    比较有用的资源是 <filename>/var/log/messages</filename> 文件，
	    它会记录每次成功启动所产生的所有内核消息。
	    此外， &man.dmesg.8; 命令也会显示这次启动时产生的内核消息。</para>

	  <note>
	    <para>如果在编译内核时遇到麻烦， 请务必保留一个
	      <filename>GENERIC</filename> 或已知可用的其他内核，
	      并命名为别的名字以免在下次启动时被覆盖。
	      不要依赖 <filename>kernel.old</filename>
	      因为在安装新内核时， <filename>kernel.old</filename>
	      会被上次安装的那个可能不正常的内核覆盖掉。
	      另外， 尽快把可用的内核挪到
	      <filename class="directory">/boot/kernel</filename>
	      否则类似 &man.ps.1; 这样的命令可能无法正常工作。
	      为了完成这一点， 需要修改目录的名字：</para>

	    <screen>&prompt.root; <userinput>mv /boot/kernel /boot/kernel.bad</userinput>
&prompt.root; <userinput>mv /boot/<replaceable>kernel.good</replaceable> /boot/kernel</userinput></screen>

	    <para>对于 &os; 5.X 之前的版本， 正确的
	      <quote>解除</quote> <command>make</command>
	      所实施的保护的命令 (为了把另一个内核永久性地挪回来) 是：</para>

	    <screen>&prompt.root; <userinput>chflags noschg /kernel</userinput></screen>

	    <para>如果您发现您不能这样做，您的系统的安全级别可能大于0了。在<filename>/etc/rc.conf</filename>里面编辑
	      <literal>kern_securelevel</literal>并把它设置为<literal>-1</literal>然后重启。
	      当您很满意这个内核的时候，您可以再把设置改回去。</para>

	    <para>另外，如果您要<quote>锁住</quote>内核或其他文件，以致它不能被移动或修改，
	      可以用下面的命令：</para>

	    <screen>&prompt.root; <userinput>chflags schg /kernel</userinput></screen>
	  </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>内核工作，但是&man.ps.1;根本不工作:</term>

	<listitem>
	  <para>如果您安装了一个与系统中内建工具版本不同的内核，
	    例如在 4.x 系统上安装了 5.x 的内核， 许多用于检查系统状态的工具如
	    &man.ps.1; 和 &man.vmstat.8; 都将无法正常使用。
	    您应该 <link linkend="makeworld">重新编译一个和内核版本一致的系统</link>。
	    这也是为什么一般不鼓励使用与系统其他部分版本不同的内核的一个主要原因。</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
