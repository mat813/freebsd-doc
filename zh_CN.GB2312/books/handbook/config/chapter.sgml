<!--
     The FreeBSD Chinese Documentation Project

     Original Revision: 1.181
     $FreeBSD$
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Written by </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
        <firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Based on a tutorial written by </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
        <firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Also based on tuning(7) written by </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>设置和调整</title>

  <sect1 id="config-synopsis">
    <title>概述</title>

    <indexterm><primary>系统配置</primary></indexterm>
    <indexterm><primary>系统优化</primary></indexterm>

    <para>&os; 的一个重要问题是系统配置。
      正确地配置系统能充分地减少以后维护和升级系统所需的工作量。
      这章将解释一些 &os; 的配置过程，包括一些可以调整的 &os;
      系统的一些参数。</para>

    <para>阅读完本章之后您将会知道：</para>

    <itemizedlist>
      <listitem>
	<para>怎样有效的利用文件系统和交换分区。</para>
      </listitem>
      <listitem>
	<para><filename>rc.conf</filename> 的基本设置和
	  <filename>/usr/local/etc/rc.d</filename> 启动体系。</para>
      </listitem>
      <listitem>
	<para>怎样设置和测试一块网卡。</para>
      </listitem>
      <listitem>
	<para>怎样在您的网络设备上设置虚拟主机。</para>
      </listitem>
      <listitem>
	<para>怎样使用 <filename>/etc</filename> 下的各配置文件。</para>
      </listitem>
      <listitem>
	<para>怎样使用 <command>sysctl</command> 来调整 &os; 系统变量。</para>
      </listitem>
      <listitem>
	<para>怎样调整磁盘性能和修改内核限制。</para>
      </listitem>
    </itemizedlist>

    <para>在阅读本章之前，您应该了解：</para>

    <itemizedlist>
      <listitem>
	<para>了解 &unix; 和 &os; 的基础知识
	  (<xref linkend="basics">)。</para>
      </listitem>
      <listitem>
	<para>熟悉内核配置编译的基础知识
	  (<xref linkend="kernelconfig">)。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>初步配置</title>

    <sect2>
      <title>分区规划</title>

      <indexterm><primary>分区规划</primary></indexterm>
      <indexterm>
        <primary><filename>/etc</filename></primary>
      </indexterm>
      <indexterm>
        <primary><filename>/var</filename></primary>
      </indexterm>
      <indexterm>
        <primary><filename>/usr</filename></primary>
      </indexterm>

      <sect3>
	<title>基本分区</title>

	<para>当使用 &man.disklabel.8; 或者 &man.sysinstall.8;
	  来分割您的文件系统的时候，
	  要记住硬盘驱动器外磁道传输数据要比从内磁道传输数据快。
	  因此应该将小的和经常访问的文件系统放在驱动器靠外的位置，
	  一些大的分区比如 <filename>/usr</filename>
	  应该放在比较靠里的位置。
	  以类似这样的顺序建立分区是一个不错的主意：root，swap，
	  <filename>/var</filename>，<filename>/usr</filename>。</para>

	<para><filename>/var</filename> 的大小能反映您的机器使用情况。
	  它用来存储邮件，日志文件和打印队列缓存，
	  特别是邮箱和日志文件可能会达到无法预料的大小，
	  这主要取决于在您的系统上有多少用户和您的日志文件可以保存多长时间。
	  一般大多数用户不需要一个 G 以上的空间，但要记住
	  <filename>/var/tmp</filename> 应该足够大来以便存储一些
	  packages。</para>

	<para><filename>/usr</filename> 分区存储很多用来系统运行所需要的文件例如
	  &man.ports.7; (建议这样做) 和源代码 (可选的)。安装的时候这两项都是可选的。
	  这个分区至少要保留两个 G 的可用空间。</para>

	<para>当选择分区大小的时候，记住保留一些空间。
	  用完了一个分区的空间而在另一个分区上还有很多，
	  可能会导致出现一些错误。</para>

	<note><para>一些用户会发现 &man.sysinstall.8; 的
	  <literal>Auto-defaults</literal> 自动分区有时会分配给
	  <filename>/var</filename> 和 <filename>/</filename> 较小的分区空间。
	  分区应该精确一些并且大一些。</para></note>

      </sect3>

      <sect3 id="swap-design">
	<title>交换分区</title>

	<indexterm><primary>交换分区分配</primary></indexterm>
	<indexterm><primary>交换分区</primary></indexterm>

	<para>一般来讲，交换分区应该大约是系统内存 (RAM) 的两倍。
	  例如，如果机器有 128M 内存，交换文件应该是 256M。
	  较小内存的系统可以通过多一点地交换分区来提升性能。
	  不建议小于 256&nbsp;兆的交换分区，并且扩充您的内存应该被考虑一下。
	  当交换分区最少是主内存的两倍的时候，内核的 VM (虚拟内存)
	  页面调度算法可以将性能调整到最好。如果您给机器添加更多内存，
	  配置太小的交换分区会导致 VM 页面扫描的代码效率低下。</para>

	<para>在使用多块SCSI磁盘(或者不同控制器上的IDE磁盘)的大系统上，
	  建议在每个驱动器上建立交换分区(直到四个驱动器)。
	  交换分区应该大约一样大小。内核可以使用任意大小，
	  但内部数据结构则是最大交换分区的 4 倍。保持交换分区同样的大小，
	  可以允许内核最佳地调度交换空间来访问磁盘。
	  即使不太使用，分配大的交换分区也是好的，
	  在被迫重启之前它可以让您更容易的从一个失败的程序中恢复过来。</para>
      </sect3>

      <sect3>
	<title>为什么要分区？</title>

	<para>一些用户认为一个单独的大分区将会很好，
	  但是有很多原因会证明为什么这是个坏主意。首先，
	  每个分区有不同的分区特性，因此分开可以让文件系统调整它们。
	  例如，根系统和 <filename>/usr</filename> 一般只是读取，写入很少。
	  很多读写频繁的被放在 <filename>/var</filename> 和
	  <filename>/var/tmp</filename>中。</para>

	<para>适当的划分一个系统，用比较小的分区方法，
	  那些以写为主的分区将不会比以读为主的分区付出更高的代价。
	  将以写为主的分区放在靠近磁盘的边缘，
	  例如放在实际的大硬盘的前面代替放在分区表的后面，将会提高您需要的分区的
	  I/O 性能。现在可能也需要在比较大的分区上有很好的 I/O 性能，
	  把他们移动到磁盘外围不会带来多大的性能提升，反而把
	  <filename>/var</filename> 移到外面会有很好的效果。最后涉及到安全问题。
	  一个主要是只读的小的、整洁的根分区可以提高从一个严重的系统崩溃中恢复过来的机会。
</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>核心配置</title>

    <indexterm>
      <primary>rc 文件</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>系统的配置信息主要位于 <filename>/etc/rc.conf</filename>。
      这个文件包含了配置信息很大的一部分，主要在系统启动的时候来配置系统，
      这个名字直接说明了这点；它也是 <filename>rc*</filename>
      文件的配置信息。</para>

    <para>系统管理员应该在 <filename>rc.conf</filename> 文件中建立记录来覆盖
      <filename>/etc/defaults/rc.conf</filename> 中的默认设置。
      这个默认文件不应该被逐字的拷贝到
      <filename>/etc</filename> ―― 它包含的是默认值而不是一个例子。
      所有特定的改变应该在 <filename>rc.conf</filename> 中。</para>

    <para>为了降低管理成本，有很多策略可以应用在成群的应用程序中来从系统指定的配置中分离
      site-wide 配置。建议的方法是将 site-wide 配置放在另一个文件中，例如
      <filename>/etc/rc.conf.site</filename>，
      并且把它包含进然后把这个文件包括进只包含系统指定信息的
      <filename>/etc/rc.conf</filename>。</para>

    <para>由于 <filename>rc.conf</filename> 可以被 &man.sh.1;
      阅读，所以达到这个目的很简单，例如：</para>

    <itemizedlist>
      <listitem><para>rc.conf:</para>
<programlisting>	. rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"</programlisting></listitem>
      <listitem><para>rc.conf.site:</para>
<programlisting>	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"</programlisting></listitem>
    </itemizedlist>

    <para><filename>rc.conf.site</filename> 文件会被分发给每一个使用
      <command>rsync</command> 或相似程序的系统，同时
      <filename>rc.conf</filename> 文件仍然保持独立。</para>

    <para>使用 &man.sysinstall.8; 或者 <command>make world</command>
      来升级系统不会覆盖 <filename>rc.conf</filename>
      文件， 所以系统配置信息不会丢失。</para>

  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>应用程序配置</title>

    <para>典型的，被安装的应用程序有他自己的配置文件、语法等等。
      从基本系统中分开他们是很重要的以至于他们可以容易的被
      package 管理工具定位和管理</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>一般来说，这些文件被安装在
      <filename>/usr/local/etc</filename>。这个例子中，
      一个应用程序有很多配置文件并且创建了一个子目录来存放他们。</para>

    <para>通常，当一个 port 或者 package 被安装的时候，
      配置文件示例也同样被安装了。它们通常用 <filename>.default</filename>
      的后缀来标识。如果不存在这个应用程序的配置文件，它们会通过拷贝
      <filename>.default</filename> 文件来创建。</para>

    <para>例如，看一下这个目下的内容 <filename>/usr/local/etc/apache</filename>：</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>文件大小显示了只有 <filename>srm.conf</filename> 改变了。以后
      <application>Apache</application> 的升级就不会改变这个文件。</para>

  </sect1>

  <sect1 id="configtuning-starting-services">
    <sect1info>
      <authorgroup>
        <author>
	<firstname>Tom</firstname>
	<surname>Rhodes</surname>
	<contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>启动服务</title>

    <indexterm><primary>服务</primary></indexterm>

    <para>很多 &os; 用户选择用ports来安装第三方软件。
      大多数情况下需要一种方式来配置软件，
      这种方式可以让软件在系统初始化之后就启动。
      很多软件需要在系统初始化时就启动，类似于其中的两个
      <filename role="package">mail/postfix</filename> 或者
      <filename role="package">www/apache13</filename>。
      因此必须有一个行之有效的方法来配合第三方软件，
      偶然的出错会导致程序不能正确启动。</para>

    <para>&os; 包含的大多数服务，例如 &man.cron.8;，
      就是通过系统启动脚本启动的。 这些脚本也许会有些不同，
      这取决于 &os; 版本。 但是不管怎样，
      需要考虑的一个重要方面是他们的启动配置文件要能被基本启动脚本识别捕获。</para>

    <para>自从 rcNG 出现以来，系统为第三方软件初始化变得清晰而有条理了。
      应用程序将会把一个简单的启动脚本放在
      <filename role="directory">/usr/local/etc/rc.d</filename>
      目录，系统初始化脚本会读取这个目录下面的脚本。
      这些脚本在系统启动之后被执行。</para>

    <para>当很多人花费时间把旧的配置格式融入到新系统的时候，
      仍然残留有一些第三方软件需要把脚本放在上述目录中。
      这些脚本中的细微差别依赖于 rcNG 是否被使用。
      &os; 5.1 之前的所有版本并不需要额外的配置；
      当然，大多数情况下这些久经考验的脚本都会工作的很好。</para>

    <para>每个脚本都应该遵守 &os; 版本所需求的一些规定：
      每个脚本必须在文件名最后添加一个 <filename>.sh</filename>
      的扩展名，并且这个脚本能被系统执行。
      后者可以通过 <command>chmod</command> 把权限设置为
      <literal>755</literal>来实现。
      它还应该能接受 <literal>start</literal>
      选项来启动程序并且接受 <literal>stop</literal>
      选项来结束程序。</para>

    <para>一个简单的脚本看起来可能会像这样：</para>

    <programlisting>#!/bin/sh
echo -n ' utility'

case "$1" in
start)
        /usr/local/bin/utility
        ;;
stop)
        kill -9 `cat /var/run/utility.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0</programlisting>

    <para>这个脚本提供了一个 <literal>stop</literal> 和
      <literal>start</literal> 选项， 用于操作这里称之为
      <literal>utility</literal> 的应用程序。 可以在
      <filename>/etc/rc.conf</filename> 中加入这样一行：</para>

    <programlisting>utility_enable="YES"</programlisting>

    <para>可以用如下方法来启动：</para>

    <screen>&prompt.root; <userinput><filename>/usr/local/etc/rc.d/utility.sh</filename> start</userinput></screen>

    <para>现在不是所有第三方软件都需要在
      <filename>rc.conf</filename>有这么一行，
      不过几乎每天都有port被修改来接受这个配置。
      对于一个特定的应用程序来说，
      你可以查看安装的最终输出来获得更多信息。
      一些第三方软件仍然提供一个脚本来供 rcNG 来使用，
      这将在下一节介绍。</para>

    <sect2>
      <title>扩展应用程序配置</title>

      <para>现在 &os; 包含rcNG，软件启动配置更加理想了，
	当然也变得更深奥。
	用 <link linkend="configtuning-rcNG">rcNG</link>
	这章介绍的关键字，应用程序现在被配置为可以在某一个服务之后启动，
	例如<acronym>DNS</acronym>；
	可能还要在 <filename>rc.conf</filename>
	传递更多的参数给启动脚本。
	一个基本的脚本看起来有点象下面这个样子：</para>

      <programlisting>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# BEFORE: LOGIN
# KEYWORD: FreeBSD shutdown

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-"NO"}
utility_flags=${utility_flags-""}
utility_pidfile=${utility_pidfile-"/var/run/utility.pid"}

. /etc/rc.subr

name="utility"
rcvar=`set_rcvar`
command="/usr/local/sbin/utility"

load_rc_config $name

pidfile="${utility_pidfile}"

start_cmd="echo \"Starting ${name}.\"; /usr/bin/nice -5 ${command} ${utility_flags} ${command_args}"

run_rc_command "$1"</programlisting>

      <para>这个脚本将保证
	<application>utility</application> 能够在
	<literal>login</literal> 服务之前， 并且在
	<literal>daemon</literal> 服务之后启动。 它同时也提供了一个设置和跟踪
	<acronym>PID</acronym>， 也称作进程
	<acronym>ID</acronym> 文件的方法。</para>

      <para>这个新方法也使得命令行参数、包含 <filename>/etc/rc.subr</filename>
	中所提供的功能， 兼容 &man.rcorder.8; 工具并提供更简单的通过
	<filename>rc.conf</filename> 文件来配置的方法。 实际上它甚至可以放到
	<filename role="directory">/etc/rc.d</filename> 目录中。
	当然， 在使用 &man.mergemaster.8; 来完成软件升级时这会带来一些麻烦。</para>
    </sect2>

    <sect2>
      <title>使用服务来启动服务</title>

      <para>其他服务， 例如 <acronym>POP</acronym>3 服务器，
	<acronym>IMAP</acronym>， 等等， 可以通过
	&man.inetd.8; 来启动。 这样的过程包括从
	ports collection 安装相应的程序， 并把配置添加进
	<filename>/etc/inetd.conf</filename> 文件， 或去掉当前配置中的注释。
	如何使用 <command>inetd</command> 并进行配置在
	<link linkend="network-inetd">inetd</link> 一节中有深入的阐述。</para>

      <para>一些情况下， 通过
	&man.cron.8; 来启动系统服务也是一种可行的选择。
	这种方法有很多好处， 因为 <command>cron</command> 会以
	<command>crontab</command> 的文件属主身份执行那些进程。
	这使得普通用户也能够执行他们的应用。</para>

      <para><command>cron</command> 工具提供了一个独有的功能， 以
	<literal>@reboot</literal> 来指定时间。
	这样的设置将在 &man.cron.8; 启动时运行，
	通常这也是系统初始化的时候。</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-cron">
    <sect1info>
      <authorgroup>
        <author>
	<firstname>Tom</firstname>
	<surname>Rhodes</surname>
	<contrib>Contributed by </contrib>
	<!-- 20 May 2003 -->
	</author>
      </authorgroup>
    </sect1info>
    <title>配置 <command>cron</command></title>

    <indexterm><primary>cron</primary>
      <secondary>配置</secondary></indexterm>

    <para>&os; 最有用的软件包(utilities)中的一个是 &man.cron.8;。
      <command>cron</command> 软件在后台运行并且经常检查
      <filename>/etc/crontab</filename> 文件。<command>cron</command>
      软件也检查 <filename>/var/cron/tabs</filename> 目录，搜索新的
      <filename>crontab</filename> 文件。这些 <filename>crontab</filename>
      文件存储一些 <command>cron</command> 在特定时间执行任务的信息。</para>

    <para><command>cron</command> 程序使用两种不同类型的配置文件，
      即系统 crontab 和用户 crontabs。 两种格式的唯一区别是第六个字段。
      在系统 crontab 中，第六个字段是用于执行命令的用户名。
      这给予了系统 crontab 以任意用户身份执行命令的能力。
      在用户 crontab 中， 第六个字段是要执行的命令，
      所有的命令都会以这个用户自己的身份执行；
      这是一项重要的安全功能。</para>

    <note>
      <para>用户 crontabs 允许每一个用户在不需要 root 特权的前提下调度自己的任务。
	在用户的 crontab 中的命令将以该用户的权限执行。</para>

      <para>同任何其他用户一样， <username>root</username> 用户也可以有自己的 crontab。
	它不同于 <filename>/etc/crontab</filename> (也就是系统 crontab)。
	因为有系统 crontab 的存在，通常不需要给 <username>root</username>
	建立单独的 crontab。</para>
    </note>

    <para>让我们来看一下 <filename>/etc/crontab</filename> 文件：</para>


    <programlisting># /etc/crontab - root's crontab for &os;
#
# &dollar;&os;: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co id="co-comments">
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co id="co-env">
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <co id="co-field-descr">
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <co id="co-main">
</programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>像大多数 &os; 配置文件一样，<literal>#</literal> 字符是注释。
	  作为什么和为什么要执行，可以加一个注释来描述以便将来提醒您。
	  注释不能跟命令一样在同一行上否则他们会被看成命令的一部分。
	  注释应该另起一行。空行将会被忽略。</para>
      </callout>

      <callout arearefs="co-env">
	<para>首先应该定义环境变量。等号
	  (<literal>=</literal>) 字符用来定义任何环境变量，像这个例子用到了
	  <envar>SHELL</envar>，<envar>PATH</envar> 和 <envar>HOME</envar>
	  变量。如果 shell 行被忽略掉，<command>cron</command> 将会用默认值
	  <command>sh</command>。如果 <option>PATH</option> 变量被忽略，
	  那么就没有默认值并且需要指定文件绝对位置。如果 <option>HOME</option>
	  被忽略，<command>cron</command> 将用用执行者的 home 目录。</para>
      </callout>

      <callout arearefs="co-field-descr">
	<para>这一行定义了七个字段。它们是 <literal>minute</literal>、
	  <literal>hour</literal>、<literal>mday</literal>、
	  <literal>month</literal>、<literal>wday</literal>、
	  <literal>who</literal> 和 <literal>command</literal>。
	  它们差不多已经说明了各自的用处。Minute 是命令要运行时的分钟，Hour
	  跟 minute 差不多，只是用小时来表示。Mday 是每个月的天。Month 跟 hour
	  还有 minute 都差不多，用月份来表示。wday 字段表示星期几。
	  所有这些字段的值必须是数字并且用24小时制来表示。<quote>who</quote>
	  字段是特别的，并且只在 <filename>/etc/crontab</filename> 文件中存在。
	  这个字段指定了命令应该以哪个用户的身份来运行。当一个用户添加了他(她)的
	  <filename>crontab</filename> 文件的时候，他们就会没有这个字段选项。最后，是
	  <literal>command</literal> 字段。这是最后的一个字段，
	  所以自然就是它指定要运行的程序。</para>
      </callout>

      <callout arearefs="co-main">
	<para>最后一行定义了上面所说的值。注意这里我们有一个
	  <literal>*/5</literal> 列表，紧跟着是一些 <literal>*</literal>
	  字符。<literal>*</literal> 字符代表<quote>开始到最后</quote>，
	  也可以被解释成 <emphasis>每次</emphasis>。所以，根据这行，
	  显然表明了无论在何时每隔 5 分钟以 <username>root</username>
	  身份来运行 <command>atrun</command> 命令。查看 &man.atrun.8;
	  手册页以获得 <command>atrun</command> 的更多信息。</para>

	<para>命令可以有任意多个传递给它们的标志。无论怎样，
	  扩展到多行的命令应该用反斜线(<quote>\</quote>)来续行。</para>
      </callout>
    </calloutlist>

    <para>这是每个 <filename>crontab</filename> 文件的基本设置，
      虽然它们有一个不同。第六行我们指定的用户名只存在于系统
      <filename>/etc/crontab</filename> 文件。这个字段在普通用户的
      <filename>crontab</filename> 文件中应该被忽略。</para>


    <sect2 id="configtuning-installcrontab">
      <title>安装 Crontab</title>

      <important>
      <para>绝对不要用这种方法来编辑/安装系统 crontab。
	您需要做的只是使用自己喜欢的编辑器：
	<command>cron</command> 程序会注意到文件发生了变化，
	并立即开始使用新的版本。参见
	<ulink url="&url.books.faq;/admin.html#ROOT-NOT-FOUND-CRON-ERRORS">
	这个 FAQ 项目 </ulink> 以了解进一步的情况。</para>
      </important>

      <para>要安装刚写好的用户
	<filename>crontab</filename>，
	首先使用最习惯的编辑器来创建一个符合要求格式的文件，然后用
	<command>crontab</command> 程序来完成。最常见的用法是：</para>

      <screen>&prompt.user; <userinput>crontab crontab-file</userinput></screen>
      
      <para>In this example, <filename>crontab-file</filename> is the filename
    of a <filename>crontab</filename> that was previously created.</para>

      <para>还有一个选项用来列出安装的 <filename>crontab</filename> 文件：
	只要传递 <option>-l</option> 选项给 <command>crontab</command>
	然后看一下输出。</para>

      <para>用户想不用模板(已经存在的文件)而直接安装他的 crontab 文件，用
	<command>crontab -e</command> 选项也是可以的。
	它将会启动一个编辑器并且创建一个新文件，当这个文件被保存的时候，
	它会自动的用 <command>crontab</command> 来安装这个文件。
      </para>
      
      <para>如果您稍后想要彻底删除自己的用户 <filename>crontab</filename>
	可以使用 <command>crontab</command> 的 <option>-r</option>
	选项。
      </para>

    </sect2>
  </sect1>

  <sect1 id="configtuning-rcNG">
    <sect1info>
      <authorgroup>
        <author>
	 <firstname>Tom</firstname>
	 <surname>Rhodes</surname>
	 <contrib>Contributed by </contrib>
	 <!-- 16 May 2003 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>在 FreeBSD 5.X 下使用 rc</title>

    <indexterm><primary>rcNG</primary></indexterm>

    <para>&os; 最近整合了 NetBSD 的 <filename>rc.d</filename>
      系统以完成系统初始化。用户要注意 <filename>/etc/rc.d</filename>
      目录下的文件。这些文件中的很多都是可以接受 <option>start</option>、
      <option>stop</option> 和 <option>restart</option> 选项的基本服务。
      例如，&man.sshd.8; 可以用下面的命令重启：</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd restart</userinput></screen>

    <para>其它的服务跟这个过程相似。当然，在 &man.rc.conf.5;
      指定的服务通常可以自动启动。例如，让网络地址转换(NAT)
      守护进程在系统启动的时候启动可以简单的在
      <filename>/etc/rc.conf</filename> 中添加下面一行：</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>如果 <option>natd_enable="NO"</option> 行已经存在，
      只要简单的把 <option>NO</option> 改成 
      <option>YES</option> 即可。
      rc 脚本在下次重新启动的时候会自动的装载所需要的服务，
      像下面所描述的那样。</para>

    <para>由于 <filename>rc.d</filename>
      系统在系统启动/关闭时首先启动/停止服务，如果设置了适当的
      <filename>/etc/rc.conf</filename> 变量，标准的
      <option>start</option>、<option>stop</option> 和
      <option>restart</option> 选项将会执行他们的动作。例如
      <command>sshd restart</command> 命令只在 <filename>/etc/rc.conf</filename>
      中的 <varname>sshd_enable</varname> 设置成 <option>YES</option>
      的时候工作。不管是否在 <filename>/etc/rc.conf</filename> 中设置了，要
      <option>start</option>、<option>stop</option> 或者 <option>restart</option>
      一个服务，命令前可以加上一个<quote>force</quote>前缀。例如要不顾当前
      <filename>/etc/rc.conf</filename> 的设置重新启动
      <command>sshd</command>，执行下面的命令：
</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd forcerestart</userinput></screen>

    <para>用选项 <option>rcvar</option> 可以简单来的检查
      <filename>/etc/rc.conf</filename> 中用适当的 <filename>rc.d</filename>
      脚本启动的服务是否被启用。从而管理员可以运行这样的程序来检查
      <command>sshd</command> 是否真的在 <filename>/etc/rc.conf</filename>
      中被启动了：</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note>
      <para>第二行 (<literal># sshd</literal>) 是从
	<command>sshd</command> 命令中输出的，而不是
	<username>root</username> 控制台。</para>
    </note>

    <para>为了确定一个服务是否真的在运行，可以用 <option>status</option>
      选项。例如验证 <command>sshd</command> 是否真的启动了：</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd status</userinput>
sshd is running as pid 433.</screen>

    <para><option>reload</option> 一个服务也是可以的。
      这将要尝试发送一个信号给一个单独的服务，
      强制这个服务重新装载它的配置文件。大多数情况这意味着给服务发送一个
      <literal>SIGHUP</literal> 信号。
    </para>

    <para><application>rcNG</application> 结构不仅仅是给网络服务提供的，
      它也给很多系统初始化提供服务。例如，处理 <filename>bgfsck</filename>
      文件。当这个脚本执行的时候，它会输出下列信息：
    </para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>这个文件用做后台文件系统检查，系统初始化的时候完成。</para>

    <para>很多系统服务依赖其他服务提供的相应功能。例如，NIS 和其他基于
      RPC 的服务启动可能在 <command>rpcbind</command> 服务启动之前失败。
      要解决这个问题，依赖关系信息和其他头信息当作注释被包含在每个启动脚本文件的前面。
      程序在系统初始化时分析这些注释以决定调用其他系统服务来满足依赖关系。
      下面的字句可能会包含在每个启动脚本文件的前面：</para>

    <itemizedlist>
      <listitem>
	<para><literal>PROVIDE</literal>: Specifies the services this file provides.</para>
      </listitem>

      <listitem>
	<para><literal>REQUIRE</literal>: Lists services which are required for this
	  service.  This file will run <emphasis>after</emphasis>
	  the specified services.</para>
      </listitem>

      <listitem>
	<para><literal>BEFORE</literal>: Lists services which depend on this service.
	  This file will run <emphasis>before</emphasis>
	  the specified services.</para>
      </listitem>

      <listitem>
	<para>KEYWORD: &os; or NetBSD.  This is used for *BSD dependent features.</para>
      </listitem>
    </itemizedlist>

    <para>通过这种方法，系统管理员可以容易的控制系统而不用像其他一些
      &unix; 操作系统一样要用 <quote>runlevels</quote> 来控制。</para>

    <para>&os;5.X 的附加信息： <filename>rc.d</filename> 系统可以在
      &man.rc.8; 和 &man.rc.subr.8; 手册页中找到。</para>
  </sect1>

  <sect1 id="config-network-setup">
    <sect1info>
      <authorgroup>
        <author>
	 <firstname>Marc</firstname>
	 <surname>Fonvieille</surname>
	 <contrib>Contributed by </contrib>
	 <!-- 6 October 2002 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>设置网卡</title>

    <indexterm><primary>网卡配置</primary></indexterm>

    <para>现在我们不可想象一个计算机没有网络连接的情况。
      添加和配置一块网卡是任何 &os; 系统管理员的一项基本任务。
    </para>

    <sect2>
      <title>查找正确的驱动程序</title>

      <indexterm>
	<primary>网卡配置</primary>
	<secondary>查找驱动程序</secondary>
      </indexterm>

      <para>在开始之前，您应该知道您的网卡类型，它用的芯片和它是 PCI
	还是 ISA 网卡。&os; 支持很多种 PCI 和 ISA 网卡。
	可以查看您的版本硬件兼容性列表以确定您的网卡被支持。
      </para>

      <para>
      现在您已经确信您的网卡被支持了，您需要为这块网卡选择正确的驱动程序。
	<filename>/usr/src/sys/i386/conf/LINT</filename>
	文件将会给您一些被支持的芯片/网卡驱动信息的列表。
	如果您对哪个是正确的驱动有疑问，阅读驱动的使用手册。
	手册会提供所支持硬件的更多信息和相关可能产生的问题。</para>

      <para>如果您有一个普通的网卡，大多数时候您不需要为驱动浪费精力。
	常用的网卡在 <filename>GENERIC</filename> 内核中已经支持了，
	所以您的网卡在启动时就会显示出来，像是：</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</screen>

      <para>在这个例子中，我们看到有两块使用 &man.dc.4; 驱动的网卡在系统中。</para>

      <para>为了使用网卡，需要装载正确的驱动程序。这可能通过两种途径来完成。
	最简单的方法是简单的用 &man.kldload.8; 来装载一个驱动该网卡的内核模块。
	一个模块不是支持所有网卡驱动的(例如ISA 网卡用 &man.ed.4; 来驱动)。
	另一种可选择的方法是您可以把支持您网卡的驱动静态的编译进内核。查看
	<filename>/usr/src/sys/i386/conf/LINT</filename>
	和手册中的驱动部分来了解把什么添加到您的内核配置文件中。可以查看 <xref
	linkend="kernelconfig"> 以获得更多的重新编译内核的信息。
	如果您的网卡在启动时被您的内核 (<filename>GENERIC</filename>)
	检测到了，那么就没有必要建立一个新内核了。
      </para>
    </sect2>

    <sect2>
      <title>配置网卡</title>

      <indexterm>
	<primary>网卡配置</primary>
	<secondary>配置</secondary>
      </indexterm>

      <para>现在正确的网卡驱动程序已经装载，那么就应该配置它了。
	跟其他配置一样，网卡可以在安装时用
	<application> sysinstall </application> 来配置。</para>

      <para>要显示您系统上的网络接口的配置，输入下列命令：</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</screen>

      <note>
	<para>老版本的 &os; 可能需要在 &man.ifconfig.8; 后面接
	  <option>-a</option> 选项，需要了解更多的 &man.ifconfig.8;
	  语法请查阅使用手册。注意所有关于 IPv6 (<literal>inet6</literal>
	  等等) 的记录在这个例子里都被忽略了。</para>
      </note>

      <para>在这个例子中，显示出了下列设备：</para>

      <itemizedlist>
	<listitem>
	  <para><devicename>dc0</devicename>: The first Ethernet
	    interface</para>
	</listitem>

	<listitem>
	  <para><devicename>dc1</devicename>: The second Ethernet
	    interface</para>
	</listitem>

	<listitem>
	  <para><devicename>lp0</devicename>: The parallel port
	    interface</para>
	</listitem>

	<listitem>
	  <para><devicename>lo0</devicename>: The loopback device</para>
	</listitem>

	<listitem>
	  <para><devicename>tun0</devicename>: The tunnel device used by
	    <application>ppp</application></para>
	</listitem>
      </itemizedlist>

      <para>
	&os; 使用内核引导时检测到的网卡驱动顺序来命名网卡。例如
	<devicename>sis2</devicename> 是系统中使用 &man.sis.4;
	驱动的第三块网卡。
     </para>

      <para>在这个例子中，<devicename>dc0</devicename>
	设备启用了。主要表现在：</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> 表示这块网卡已经配置完成准备工作。</para>
	</listitem>

	<listitem>
	  <para>这块网卡有一个 Internet (<literal>inet</literal>) 地址
	    (这个例子中是 <hostid role="ipaddr">192.168.1.3</hostid>)。</para>
	</listitem>

	<listitem>
	  <para>它有一个有效的子网掩码 (<literal>netmask</literal>；
	    <hostid role="netmask">0xffffff00</hostid> 等同于
	    <hostid role="netmask">255.255.255.0</hostid>)。</para>
	</listitem>

	<listitem>
	  <para>它有一个有效的广播地址 (这个例子中是
	    <hostid role="ipaddr">192.168.1.255</hostid>)。</para>
	</listitem>

	<listitem>
	  <para>网卡的 MAC  (<literal>ether</literal>) 地址是
	    <hostid role="mac">00:a0:cc:da:da:da</hostid></para>
	</listitem>

	<listitem>
	  <para>物理传输媒介模式处于自动选择状态
	    (<literal>media: Ethernet autoselect
	    (100baseTX &lt;full-duplex&gt;)</literal>)。我们看到
	    <devicename>dc1</devicename> 被配置成运行在
	    <literal>10baseT/UTP</literal> 模式下。
	    要了解驱动媒介类型的更多信息，
	    请查阅它们的使用手册。</para>
	</listitem>

	<listitem>
	  <para>连接状态 (<literal>status</literal>)是
	    <literal>active</literal>，也就是说连接信号被检测到了。对于
	    <devicename>dc1</devicename>，我们看到
	    <literal>status: no carrier</literal>。
	    这通常是网线没有插好。</para>
	</listitem>
      </orderedlist>

      <para>如果 &man.ifconfig.8; 的输出显示了类似于：</para>

<screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
	        ether 00:a0:cc:da:da:da</screen>

      <para>的信息，那么就是还没有配置网卡。</para>

      <para>要配置网卡，您需要 <username>root</username> 权限。
	网卡配置可以通过使用 &man.ifconfig.8; 命令行方式来完成，
	但是这样每次启动都要做一遍。放置网卡配置信息的文件是
	<filename>/etc/rc.conf</filename>。</para>

      <para>用您自己喜欢的编辑器打开 <filename>/etc/rc.conf</filename>。
	并且您需要为每一块系统中存在的网卡添加一行，
	在我们的例子中，添加如下几行：</para>

<programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>用自己正确的设备名和地址来替换例子中的
	<devicename>dc0</devicename>，<devicename>dc1</devicename>
	等内容。您应该应该查阅网卡驱动和 &man.ifconfig.8;
	的手册页来了解各选项，也要查看一下 &man.rc.conf.5;
	帮助页来了解 <filename>/etc/rc.conf</filename> 的语法。</para>

      <para>
	如果在安装的时候配置了网络，关于网卡的一些行可能已经存在了。
	所以在添加新行前仔细检查一下 <filename>/etc/rc.conf</filename>。
     </para>

      <para>
	您也可能需要编辑 <filename>/etc/hosts</filename>
	来添加局域网中不同的机器名称和 IP 地址，如果它们不存在，查看
	&man.hosts.5; 帮助和 <filename>/usr/share/examples/etc/hosts</filename>
	以获得更多信息。</para>
    </sect2>

    <sect2>
      <title>测试和调试</title>

      <para>对 <filename>/etc/rc.conf</filename>
	做了必要的修改之后应该重启系统以应用对接口的修改，
	并且确认系统重启后没有任何配置错误。</para>

      <para>系统重启后就应该测试网络接口了。</para>

      <sect3>
	<title>测试以太网卡</title>

	<indexterm>
	  <primary>网卡配置</primary>
	  <secondary>测试网卡</secondary>
	</indexterm>

	<para>为了确认网卡被正确的配置了，在这里我们要做两件事情。首先，
	  ping 自己的网络接口，接着 ping 局域网内的其他机器。</para>

	<para>首先测试本地接口：</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

	<para>现在我们应该 ping 局域网内的其他机器：</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

	<para>您如果您设置了 <filename>/etc/hosts</filename>
	  文件，也可以用机器名来替换 <hostid role="ipaddr">192.168.1.2</hostid>。</para>
      </sect3>

      <sect3>
	<title>调试</title>

      <indexterm>
	<primary>网卡配置</primary>
	<secondary>调试</secondary>
      </indexterm>

      <para>调试硬件和软件配置一直是一件头痛的事情，
	从最简单的开始可以减轻一些痛苦。
	例如网线是否插好了？是否配置好了网络服务？防火墙配置正确吗？
	是否使用了被 & os; 支持的网卡？
	在发送错误报告之前您应该查看一下硬件说明，
	升级 &os; 到最新的 STABLE 版本，
	看一下邮件列表或者在 Internet 上搜索一下。</para>

      <para>如果网卡工作了，
	但性能低下，应该好好阅读一下 &man.tuning.7; 联机手册。
	您也可以检查一下网络配置，
	不正确的设置会导致慢速的网络连接。</para>

      <para>一些用户可能会在一些网卡上经历一到两次
	<errorname>device timeouts</errorname>， 这通常是正常现象。
	如果经常这样甚至引起麻烦， 则应确定一下它跟其他设备没有冲突。
	仔细检查网线连接， 或者换一块网卡。</para>

      <para>有时用户会看到少量 <errorname>watchdog timeout</errorname>
	错误。 这种情况要做的第一件事就是检查线缆连接。
	一些网卡需要支持总线控制的 PCI 插槽。
	在一些老的主板上，只有一个 PCI 插槽支持 (一般是 slot 0)。
	检查网卡和主板说明书来确定是不是这个问题。</para>

      <para><errorname>No route to host</errorname>
	通常发生在如果系统不能发送一个路由到目的主机的包的时候。
	这在没有指定默认路由或者网线没有插上时会发生。
	检查 <command>netstat -rn</command>
	的输出并确认有一个有效的路由能到达相应的主机。
	如果没有，请查阅 <xref linkend="advanced-networking">。</para>

      <para><errorname>ping: sendto: Permission denied</errorname>
	错误信息经常由防火墙的配置错误引起。
	如果 <command>ipfw</command> 在内核中启用了但是没有定义规则，
	那么默认的规则就是拒绝所有通讯，甚至 ping 请求！
	查阅 <xref linkend="firewalls"> 以了解更多信息。</para>

      <para>有时网卡性能低下或者低于平均水平，
	这种情况最好把传输媒介模式从 <literal>autoselect</literal>
	改变为正确的传输介质模式。
	这通常对大多数硬件有用， 但可能不会解决所有人的问题。
	接着，检查所有网络设置，并且阅读 &man.tuning.7; 手册页。</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>虚拟主机</title>

    <indexterm><primary>虚拟主机</primary></indexterm>
    <indexterm><primary>IP 别名</primary></indexterm>

    <para> &os;  的一个很普通的用途是虚拟主机站点，
      一个服务器虚拟成很多服务器一样提供网络服务。
      这通过在一个接口上绑定多个网络地址来实现。</para>

    <para>一个特定的网络接口有一个<quote>真实</quote>的地址，
      也可能有一些<quote>别名</quote>地址。这些别名通常用
      <filename>/etc/rc.conf</filename> 中的记录来添加。</para>

    <para>一个 <devicename>fxp0</devicename> 的别名记录类似于：</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>
      记住别名记录必须从 <literal>alias0</literal>
      开始并且按顺序递增(例如 <literal>_alias1</literal>、
      <literal>_alias2</literal>)。
      配置程序将会停止在第一个缺少的数字的地方。</para>

    <para>
      计算别名的子网掩码是很重要的，幸运的是它很简单。
      对于一个接口来说，必须有一个描述子网掩码的地址。
      任何在这个网段下的地址必须有一个全是 <literal>1</literal>
      的子网掩码(通常表示为
      <hostid role="netmask">255.255.255.255</hostid> 或
      <hostid role="netmask">0xffffffff</hostid>。</para>

    <para>例如，假设 <devicename>fxp0</devicename> 连接到两个网段，
      子网掩码是 <hostid role="netmask">255.255.255.0</hostid> 的
      <hostid role="ipaddr">10.1.1.0</hostid> 和子网掩码是
      <hostid role="netmask">255.255.255.240</hostid> 的
      <hostid role="ipaddr">202.0.75.16</hostid>。我们将要系统使用从
      <hostid role="ipaddr">10.1.1.1</hostid> 到
      <hostid role="ipaddr">10.1.1.5</hostid> 和从
      <hostid role="ipaddr">202.0.75.17</hostid> 到
      <hostid role="ipaddr">202.0.75.20</hostid> 的地址)。
      如前面说明的那样， 只有给定网络范围内的第一个地址 (在这个例子中，
      <hostid role="ipaddr">10.0.1.1</hostid> 和
      <hostid role="ipaddr">202.0.75.17</hostid>) 需要有实际的子网掩码；
      所有其它地址 (<hostid role="ipaddr">10.1.1.2</hostid>
      到 <hostid role="ipaddr">10.1.1.5</hostid> 以及
      <hostid role="ipaddr">202.0.75.18</hostid> 到
      <hostid role="ipaddr">202.0.75.20</hostid>) 必须配置为使用掩码
      <hostid role="netmask">255.255.255.255</hostid>。</para>

    <para>下面的记录会正确的设置这个适配器：</para>

<programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>配置文件</title>

    <sect2>
      <title><filename>/etc</filename> 布局</title>
      <para>在配置信息中有很多的目录，这些包括：</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="2*">

	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>一般的系统配置信息。这儿的数据是与特定系统相关的。</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>系统配置文件的默认版本。</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>额外的 &man.sendmail.8; 配置信息，其他 MTA 配置文件。
	      </entry>
	    </row>
	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>用于用户级和内核级 ppp 程序的配置。
	      </entry>
	    </row>
	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>&man.named.8; 数据的默认位置。通常 <filename>named.conf</filename> 和区域文件存放在这里。</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc</filename></entry>
	      <entry>被安装的应用程序配置文件。可以参考每个应用程序的子目录。</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>被安装程序的 启动/停止 脚本。</entry>
	    </row>
	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>特定系统自动产生的数据库文件，像 package 数据库，位置数据库等等。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>主机名</title>

      <indexterm><primary>主机名</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm>
	  <primary><filename>resolv.conf</filename></primary>
	</indexterm>

	<para><filename>/etc/resolv.conf</filename> 指示了 &os; 如何访问域名系统(DNS)。</para>

	<para><filename>resolv.conf</filename> 中最常见的记录是：
	</para>

	<informaltable frame="none">
	  <tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="2*">

	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>
		<entry>按顺序要查询的名字服务器的 IP 地址，最多三个。</entry>
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>
		搜索机器名的列表。这通常由本地机器名的域决定。</entry>
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>本地域名。</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>一个典型的 <filename>resolv.conf</filename> 文件：</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note><para>只能使用一个 <literal>search</literal> 和
	  <literal>domain</literal> 选项。</para></note>

	<para>如果您在使用 DHCP，&man.dhclient.8; 经常使用从 DHCP
	  服务器接受来的信息重写 <filename>resolv.conf</filename>。</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>主机</primary></indexterm>

	<para><filename>/etc/hosts</filename> 是 Internet
	  早期使用的一个简单文本数据库。
	  它结合 DNS 和 NIS 提供名字到 IP 地址的映射。
	  通过局域网连接的机器可以用这个简单的命名方案来替代设置一个
	  &man.named.8; 服务器。另外，<filename>/etc/hosts</filename>
	  也可以提供一个 Internet 名称的本地纪录以减轻需要从外部查询带来的负担。</para>

	<programlisting># &dollar;&os;&dollar;
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#</programlisting>

	<para><filename>/etc/hosts</filename> 用简单的格式：</para>

	<programlisting>[Internet address] [official hostname] [alias1] [alias2] ...</programlisting>

	<para>例如：</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>参考 &man.hosts.5; 以获得更多信息。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>日志文件配置</title>

      <indexterm><primary>日志文件</primary></indexterm>

      <sect3>
	<title><filename>syslog.conf</filename></title>

	<indexterm><primary>syslog.conf</primary></indexterm>

	<para><filename>syslog.conf</filename> 是 &man.syslogd.8; 程序的配置文件。
	它指出了的  <command>syslog</command> 哪种信息类型被存储在特定的日志文件中。</para>

	<programlisting># &dollar;&os;&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

	<para>参考 &man.syslog.conf.5; 手册页以获得更多信息</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>

	<para><filename>newsyslog.conf</filename> 是一个通常用
	  &man.cron.8; 计划运行的 &man.newsyslog.8; 程序的配置文件。
	  &man.newsyslog.8; 指出了什么时候日志文件需要打包或者重新整理。
	  比如 <filename>logfile</filename> 被移动到
	  <filename>logfile.0</filename>，<filename>logfile.0</filename>
	  被移动到 <filename>logfile.1</filename> 等等。另外，日志文件可以用
	  &man.gzip.1; 来压缩，它们是这样的命名格式：
	  <filename>logfile.0.gz</filename>，<filename>logfile.1.gz</filename>
	  等等。</para>

	<para><filename>newsyslog.conf</filename>
	  指出了哪个日志文件要被管理，要保留多少和它们什么时候被创建。
	  日志文件可以在它们达到一定大小或者在特定的日期被重新整理。</para>

	<programlisting># configuration file for newsyslog
# &dollar;&os;&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

	<para>参考 &man.newsyslog.8; 手册页以获得更多信息。</para>
      </sect3>
    </sect2>

    <sect2 id="configtuning-sysctlconf">
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> 看起来很像
	<filename>rc.conf</filename>。它用 <literal>variable=value</literal>
	的形式来设定值。指定的值在系统进入多用户模式之后被设定。
	并不是所有的变量都可以在这个模式下设定。</para>

      <para> 一个简单的例子举明了在 <filename>sysctl.conf</filename>
	中关闭了重要的退出信号的日志并且让 Linux 程序知道他们其实运行在
	&os; 下面：</para>

      <programlisting>kern.logsigexit=0       # Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=&os;
compat.linux.osrelease=4.3-STABLE</programlisting>
    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>用 sysctl 进行调整</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm>
      <primary>调整</primary>
      <secondary>以 sysctl</secondary>
    </indexterm>

    <para>&man.sysctl.8; 是一个允许您改变正在运行中的 &os;
      系统的接口。它包含一些 TCP/IP 堆栈和虚拟内存系统的高级选项，
      这可以让有经验的管理员提高引人注目的系统性能。用
      &man.sysctl.8; 可以读取设置超过五百个系统变量。</para>

    <para>基于这点，&man.sysctl.8; 提供两个功能：读取和修改系统设置。</para>

    <para>查看所有可读变量：</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>读一个指定的变量，例如 <varname>kern.maxproc</varname>：</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>要设置一个指定的变量，直接用
      <replaceable>variable</replaceable>=<replaceable>value</replaceable>
      这样的语法：</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>sysctl 变量的设置通常是字符串、数字或者布尔型。
      (布尔型用 <literal>1</literal> 来表示'yes'，用
      <literal>0</literal> 来表示'no')。</para>

    <para>If you want to set automatically some variables each time
      the machine boots, add them to the
      <filename>/etc/sysctl.conf</filename> file.  For more information
      see the &man.sysctl.conf.5; manual page and the
      <xref linkend="configtuning-sysctlconf">.</para>

  <sect2 id="sysctl-readonly">
    <sect2info>
      <authorgroup>
        <author>
	 <firstname>Tom</firstname>
	 <surname>Rhodes</surname>
	 <contrib>Contributed by </contrib>
	 <!-- 31 January 2003 -->
        </author>
      </authorgroup>
    </sect2info>
    <title>只读的 &man.sysctl.8;</title>

    <para>有时想要修改只读的 &man.sysctl.8; 的值。
      有时这不被推荐，有时也是不可避免的。</para>

    <para>例如一些膝上型电脑的 &man.cardbus.4;
      设备不会探测内存范围，并且产生看似于这样的错误：</para>

    <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

    <para>像上面的错误通常需要修改一些只读的 &man.sysctl.8;
      默认设置。要实现这点，用户可以在本地的
      <filename>/boot/loader.conf.local</filename> 里面放一个
      &man.sysctl.8; <quote>OIDs</quote>。那些设置定位在
      <filename>/boot/defaults/loader.conf</filename> 文件中。</para>

    <para>修复上面的问题用户需要在刚才所说的文件中设置
      <option>hw.pci.allow_unsupported_io_range=1</option>。现在
      &man.cardbus.4; 就会正常的工作了。</para>

    </sect2>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>调整磁盘</title>

    <sect2>
      <title>Sysctl 变量</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>

	<para><varname>vfs.vmiodirenable</varname> sysctl
	  变量可以设置成0(关)或者1(开)；默认是1。
	  这个变量控制目录是否被系统缓存。大多数目录是小的，
	  在系统中只使用单个片断(典型的是1K)并且在缓存中使用的更小
	  (典型的是512字节)。当这个变量设置为关闭 (0) 时，
	  缓存器仅仅缓存固定数量的目录，即使您有很大的内存。
	  而将其开启 (设置为1) 时， 则允许缓存器用 VM
	  页面缓存来缓存这些目录，让所有可用内存来缓存目录。
	  不利的是最小的用来缓存目录的核心内存是大于 512
	  字节的物理页面大小(通常是 4k)。
	  我们建议如果您在运行任何操作大量文件的程序时保持这个选项打开的默认值。
	  这些服务包括 web 缓存，大容量邮件系统和新闻系统。
	  尽管可能会浪费一些内存，但打开这个选项通常不会降低性能。
	  但还是应该检验一下。</para>
      </sect3>

     <sect3>
 	<title><varname>vfs.write_behind</varname></title>

 	<indexterm>
 	  <primary><varname>vfs.write_behind</varname></primary>
 	</indexterm>

 	<para><varname>vfs.write_behind</varname> sysctl
	  变量默认是 <literal>1</literal> (打开)。
	  它告诉文件系统簇被收集满的时候把内容写进介质，
	  典型的是在写入大的连续的文件时。
	  主要的想法是， 如果可能对 I/O 性能会产生负面影响时，
 	  应尽量避免让缓冲缓存被未同步缓冲区充满。
	  然而它可能降低处理速度并且在某些情况下您可能想要关闭它。</para>
       </sect3>

       <sect3>
 	<title><varname>vfs.hirunningspace</varname></title>

 	<indexterm>
 	  <primary><varname>vfs.hirunningspace</varname></primary>
 	</indexterm>

 	<para><varname>vfs.hirunningspace</varname> sysctl
	  变量决定了在任何场合多少写 I/O 被排进队列以给系统的磁盘控制器。
	  默认值一般是足够的，但是对有很多磁盘的机器来说您可能需要把它设置成
	  4M 或 5M。注意这个设置成很高的值(超过缓存器的写极限)会导致坏的性能。
	  不要盲目的把它设置太高！高的数值会导致同时发生的读操作的迟延。</para>

 	<para>sysctl 中还有许多与 buffer cache 和 VM页面 cache
	  有关的值， 一般不推荐修改它们。 从 &os;&nbsp;4.3
	  开始，虚拟内存系统已经能够很好地进行自动调整了。</para>
       </sect3>

       <sect3>
 	<title><varname>vm.swap_idle_enabled</varname></title>

 	<indexterm>
 	  <primary><varname>vm.swap_idle_enabled</varname></primary>
 	</indexterm>

 	<para><varname>vm.swap_idle_enabled</varname> sysctl
	  变量在有很多用户进入、离开系统和有很多空闲进程的大的多用户系统中很有用。
	  这些系统注重在空闲的内存中间产生连续压力的处理。通过
	  <varname>vm.swap_idle_threshold1</varname> 和
	  <varname>vm.swap_idle_threshold2</varname> 打开这个特性并且调整交换滞后
	  (在空闲时)允许您降低内存页中空闲进程的优先权，从而比正常的出页
	  (pageout)算法更快。这给出页守护进程带来了帮助。
	  除非您需要否则不要把这个选项打开，因为您所权衡的是更快地进入内存，
	  因而它会吃掉更多的交换和磁盘带宽。在小的系统上它会有决定性的效果，
	  但是在大的系统上它已经做了合适的页面调度这个选项允许 VM
	  系统容易的让全部的进程进出内存。</para>
       </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>&os;&nbsp;4.3  IDE 写缓存关掉了。这降低了到 IDE
	  磁盘的带宽但是保证了传进磁盘数据的严格完整性。这个问题是因为
	  IDE 驱动器当写完成的时候无所事事。IDE 写缓存打开的时候，IDE
	  驱动器不按顺序把数据写进磁盘。当有很重的磁盘负载的时候它有时迟延写入一些块。
	  当机或者掉电会引起严重的文件系统讹误。&os; 的默认值改变成安全的模式。
	  不幸的是结果是带来了很大的性能损失，所以我们在发行版之后把写缓存的默认值改成了
	  on。您应该注意 <varname>hw.ata.wc</varname> sysctl 变量来检查一下系统中的默认值。
	  如果 IDE 写缓存被关闭了，您可以通过设置内核变量为 1 来打开它。这必须在启动时通过
	  boot loader 来完成。在内核启动之后尝试这么做将会没有效果。</para>

	<para>要了解更多的信息，请查阅 &man.ata.4;。</para>
      </sect3>

      <sect3>
	<title><literal>SCSI_DELAY</literal>
	(<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm>
	  <primary><literal>SCSI_DELAY</literal></primary>
	  <secondary><varname>kern.cam.scsi_delay</varname></secondary>
	</indexterm>

	<para><literal>SCSI_DELAY</literal> 内核配置会缩短系统启动时间。
	  默认值在系统启动过程中有 <literal>15</literal> 秒的迟延时间，
	  这是一个足够多且可靠的值。把它减少到 <literal>5</literal>
	  通常也能工作(特别是现代的驱动器)。新一些的 &os;
	  (5.0 或更高版本) 应该用启动时刻可调整
	  <varname>kern.cam.scsi_delay</varname>。
	  这个可调整的和内核配置选项接受的值是
	  <emphasis>毫秒</emphasis> <emphasis>不是
	  </emphasis> <emphasis>秒</emphasis> 。</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>&man.tunefs.8; 程序能够用来很好的调整文件系统。
	这个程序有很多不同的选项，但是现在只介绍 Soft Updates
	的打开和关闭，这样做：</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>在文件系统被挂载之后不能用 &man.tunefs.8; 来修改。打开
	Soft Updates 的最佳时机是在单用户模式下任何分区被被挂载前。</para>

      <note><para>像 &os;&nbsp;4.5，在文件系统创建时也可以打开
	Soft Updates，通过 &man.newfs.8; 的 <literal>-U</literal> 选项。</para></note>

      <para>
	Soft Updates 彻底的改善了数据描述(meta-data)的性能，
	主要是文件创建和删除，通过内存缓存。我们建议您在所有的文件系统上使用
	Soft Updates。应该知道 Soft Updates 的两点：首先， Soft Updates
	保证了崩溃后的文件系统完整性，但是很可能有几秒钟 (甚至一分钟！)
	之前的数据没有写到物理磁盘。如果您的系统崩溃了您可能会丢失很多工作。
	第二，SoftUpdates 推迟文件系统块的释放时间。如果在文件系统
	(例如根文件系统)快满了的情况下对系统进行大规模的升级比如
	<command>make installworld</command>，
	可能会引起磁盘空间不足从而造成升级失败。
      </para>

      <sect3>
	<title>Soft Updates 的详细资料</title>

	<indexterm>
	  <primary>Soft Updates</primary>
	  <secondary>详细资料</secondary>
	</indexterm>

	<para>
	  有两种传统的方法来把文件系统的元数据 (meta-data) 写入磁盘。
	  (Meta-data更新是更新类似 inodes 或者目录这些没有内容的数据)</para>

	<para>
	  从前，默认方法是同步更新这些元数据(meta-data)。
	  如果一个目录改变了，系统在真正写到磁盘之前一直等待。
	  文件数据缓存(文件内容)在这之后以非同步形式写入。
	  这么做有利的一点是操作安全。如果更新时发生错误，元数据(meta-data)
	  一直处于完整状态。文件要不就被完整的创建要不根本就不创建。
	  如果崩溃时找不到文件的数据块，&man.fsck.8;
	  可以找到并且依靠把文件大小设置为 0 来修复文件系统。
	  另外，这么做既清楚又简单。缺点是元数据(meta-data)更新很慢。例如
	  <command>rm -r</command> 命令，从而改变目录下的所有文件，
	  但是每个目录的改变(删除一个文件)都要同步写入磁盘。
	  这包含它自己更新目录，inode 表和可能对文件分散的块的更新。
	  同样问题出现大的文件操作上(比如 <command>tar -x</command>)。</para>

	<para>
	  第二种方法是非同步元数据更新。这是 Linux/ext2fs 和 *BSD ufs 的
	  <command>mount -o async</command> 默认的方法。所有元数据更新也是通过缓存。
	  也就是它们会混合在文件内容数据更新中。
	  这个方法的优点是不需要等待每个元数据更新都写到磁盘上，
	  所以所有引起元数据更新大的操作比同步方式更快。同样，
	  这个方法也是清楚且简单的，所以代码中的漏洞风险很小。
	  缺点是不能保证文件系统的状态一致性。如果更新大量元数据时失败
	  (例如掉电或者按了重启按钮)，文件系统会处在不可预知的状态。
	  系统再启动时没有机会检查文件系统的状态；inode
	  表更新的时候可能文件的数据块已经写入磁盘了但是相关联的目录没有，却不能用
	  <command>fsck</command>  命令来清理(因为磁盘上没有所需要的信息)。
	  如果文件系统修复后损坏了，唯一的选择是使用 &man.newfs.8; 并且从备份中恢复它。
	</para>

	<para>
	  这个问题通常的解决办法是使用 <emphasis>dirty region logging</emphasis>
	  或者 <emphasis>journaling</emphasis>
	  尽管它不是一贯的被使用并且有时候应用到其他的事务纪录中更好。
	  这种方法元数据更新依然同步写入，但是只写到磁盘的一个小区域。
	  过后他们将会被移动到正确的位置。因为纪录区很小，
	  磁盘上接近的区域磁头不需要移动很长的距离，所以这些比写同步快一些。
	  另外这个方法的复杂性有限，所以出现错误的机会也很少。缺点是元数据要写两次
	  (一次写到纪录区域，一次写到正确的区域)。正常情况下，
	  悲观的性能可能会发生。从另一方面来讲，
	  崩溃的时候所有未发生的元数据操作可以很快的在系统启动之后从记录中恢复过来。
	</para>

	<para>Kirk McKusick，伯克利 FFS 的开发者，用 Soft Updates
	  解决了这个问题：元数据更新保存在内存中并且按照排列的顺序写入到磁盘
	  (<quote>有序的元数据更新</quote>)。这样的结果是，在繁重的元数据操作中，
	  如果先前的更新还在内存中没有别写进磁盘，后来的更新就会捕捉到。
	  所以所有的目录操作在写进磁盘的时候首先在内存中执行
	  (数据块按照它们的位置来排列，所以它们不会在元数据前被写入)。
	  如果系统崩溃了这将导致一个固定的 <quote>日志回朔</quote>：
	  所有不知如何写入磁盘的操作都像没有发生过一样。文件系统的一致性保持在
	  30 到 60 秒之前。它保证了所有正在使用的资源被标记例如块和 inodes。崩溃之后，
	  唯一的资源分配错误是一个实际是<quote>空闲</quote>的资源的资源被标记为<quote>使用</quote>。
	  &man.fsck.8; 可以认出这种情况并且释放不再使用的资源。它对于忽略崩溃后用
	  <command>mount -f</command> 强制挂上的文件系统的错误状态是安全的。
	  为了释放可能没有使用的资源，&man.fsck.8; 需要在过后的时间运行。一个主意是用
	  <emphasis>后台 fsck</emphasis>：系统启动的时候只有一个文件系统的
	  <emphasis>快照</emphasis> 被记录下来。<command>fsck</command>
	  可以在过后运行。所有文件系统可以在<quote>有错误</quote>的时候被挂接，
	  所以系统可以在多用户模式下启动。接着，后台 <command>fsck</command>
	  可以在所有文件系统需要的时候启动来释放可能没有使用的资源。
	  (尽管这样，不用 Soft Updates 的文件系统依然需要通常的
	  <command>fsck</command>。)
	</para>

	<para>
	  它的优点是元数据操作几乎跟非同步一样快
	  (也就是比需要两次元数据写操作的 <emphasis>logging</emphasis>
	  更快)。缺点是代码的复杂性(意味着对于丢失用户敏感数据有更多的风险)
	  和高的内存使用量。另外它有些特点需要知道。崩溃之后，
	  文件系统状态会<quote>落后</quote>一些。同步的方法用
	  <command>fsck</command> 后在一些地方可能产生一些零字节的文件，
	  这些文件在用 Soft Updates 文件系统之后不会存在，
	  因为元数据和文件内容根本没有写进磁盘(可能发生在运行
	  <command>rm</command> 之后)。这可能在文件系统上安装大量数据时候引发问题，
	  没有足够的剩余空间来两次存储所有文件。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>调整内核限制</title>

    <indexterm>
      <primary>调整</primary>
      <secondary>内核限制</secondary>
    </indexterm>

    <sect2 id="file-process-limits">
      <title>文件/进程限制</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>

	<para><varname>kern.maxfiles</varname> 可以根据系统的需求加大或者减小。
	  这个变量指出了在系统上文件描述符的最大数量。当文件描述符表曼的时候，
	  用 <command>dmesg</command> 命令可以看到
	  <errorname>file: table is full</errorname>
	  将会在系统信息缓存里反复的出现。</para>

	<para>每个打开的文件、套接字、fifo 都使用一个描述符。
	  一个大规模的服务器很容易使用上千个文件描述符，
	  这取决于系统中同时运行着的服务的数量和类型。</para>

	<para>
	  <varname>kern.maxfile</varname> 的默认值以系统配置文件中的
	  <option>MAXUSERS</option> 选项来决定。<varname>kern.maxfiles</varname>
	  同 <option>MAXUSERS</option> 的值成比例的增长。编译一个自定义内核的时候，
	  按照您系统中用户的数量来设置这个值是个好主意。
	  从这个数字可以确定内核很多先前定义的限制。即使一台机器不会真有
	  256 个用户同时连接，所需要的资源也可能跟一个高负荷的 web
	  服务器差不多。
	</para>

	<note><para>像是 &os;&nbsp;4.5，在您的内核配置中设置
	  <option>MAXUSERS</option> 为会通过系统中内存的数量来选择一个合适的值。</para></note>

      </sect3>

      <sect3>
	<title><varname>kern.ipc.somaxconn</varname></title>

	<indexterm>
	  <primary><varname>kern.ipc.somaxconn</varname></primary>
	</indexterm>

	<para><varname>kern.ipc.somaxconn</varname> sysctl 变量
	  限制了接收新 TCP 连接侦听队列的大小。对于一个经常处理新连接的高负载
	  web服务环境来说，默认的 <literal>128</literal> 太小了。
	  大多数环境这个值建议增加到 <literal>1024</literal> 或者更多。
	  服务进程会自己限制侦听队列的大小(例如 &man.sendmail.8;
	  或者 <application>Apache</application>)，
	  常常在它们的配置文件中有设置队列大小的选项。
	  大的侦听队列对防止拒绝服务 <abbrev>DoS</abbrev> 攻击也会有所帮助。</para>
      </sect3>

    </sect2>
    <sect2>
      <title>网络限制</title>

      <para><literal>NMBCLUSTERS</literal> 内核配置选项指出了系统可用的网络Mbuf的数量。
	一个高流量的服务器使用一个小数目的网络缓存会影响 &os; 的性能。
	每个 cluster 可能需要2K内存，所以一个1024的值需要在内核中给网络缓存保留2M内存。
	可以用简单的方法计算出来需要多少网络缓存。
	如果您有一个同时发生1000个以上连接的web服务器，
	并且每个连接用掉16K接收和发送缓存， 就需要大概32M网络缓存来确保web服务器的工作。
	一个好的简单计算方法是乘以2，所以2x32Mb/2Kb=64MB/2kb=32768。
	我们建议在有大量内存的机器上把这个值设置在4096到32768之间。
	没有必要把它设置成任意太高的值，它会在启动时引起崩溃。
	&man.netstat.1; 的 <option>-m</option> 选项可以用来观察网络cluster使用情况。</para>

      <para><varname>kern.ipc.nmbclusters</varname> 可以用来在启动时刻调节这个。
	仅仅在旧版本的 &os; 需要使用 <literal>NMBCLUSTERS</literal>
	&man.config.8; 选项。</para>

      <para>经常使用 &man.sendfile.2; 系统调用的繁忙的服务器，
	有必要通过 <literal>NSFBUFS</literal> 内核选项或者在
	<filename>/boot/loader.conf</filename> (查看 &man.loader.8; 以获得更多细节)
	中设置它的值来调节 &man.sendfile.2; 缓存数量。
	这个参数需要调节的普通原因是在进程中看到 <literal>sfbufa</literal>
	状态。sysctl <varname>kern.ipc.nsfbufs</varname>
	变量在内核配置变量中是只读的。 这个参数是由 <varname>kern.maxusers</varname>
	决定的，然而它可能有必有因此而调整。</para>

      <important>
	<para>
	  即使一个套接字被标记成非阻塞，在这个非阻塞的套接字上呼叫
	  &man.sendfile.2; 可能导致 &man.sendfile.2; 呼叫阻塞直到有足够的
	  <literal>struct sf_buf</literal> 可用。
	</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm>
	  <primary>net.inet.ip.portrange.*</primary>
	</indexterm>

	<para><varname>net.inet.ip.portrange.*</varname> sysctl
	  变量自动的控制绑定在 TCP 和 UDP 套接字上的端口范围。
	  这里有三个范围：一个低端范围，一个默认范围和一个高端范围。
	  大多数网络程序分别使用由 <varname>net.inet.ip.portrange.first</varname>
	  和 <varname>net.inet.ip.portrange.last</varname> 控制的从 1024 到 5000
	  的默认范围。端口范围用作对外连接，并且某些情况可能用完系统的端口，
	  这经常发生在运行一个高负荷 web 代理服务器的时候。
	  这个端口范围不是用来限制主要的例如 web
	  服务器进入连接或者有固定端口例如邮件传递对外连接的。
	  有时您可能用完了端口，那就建议适当的增加
	  <varname>net.inet.ip.portrange.last</varname>。
	  <literal>10000</literal>、<literal>20000</literal> 或者
	  <literal>30000</literal> 可能是适当的值。
	  更改端口范围的时候也要考虑到防火墙。一些防火墙会阻止端口的大部分范围
	  (通常是低范围的端口)并且用高端口进行对外连接(&mdash;)。
	  基于这个问题建议把 <varname>net.inet.ip.portrange.first</varname>
	  设置的小一点。</para>
      </sect3>

      <sect3>
	<title>TCP 带宽迟延(Bandwidth Delay Product)</title>

	<indexterm>
	  <primary>TCP 带宽迟延限制</primary>
	  <secondary><varname>net.inet.tcp.inflight_enable</varname></secondary>
	</indexterm>

	<para>The TCP Bandwidth Delay Product Limiting 类似于 NetBSD 的TCP/Vegas。
	  它可以通过设置 <varname>net.inet.tcp.inflight_enable</varname> sysctl
	  变量为 <literal>1</literal> 来启动。
	  系统将会为每个连接尝试带宽迟延并且限制发送到网络中的队列中的数据数量以维持适当的吞吐量。</para>

	<para>
	  如果您在使用调制解调器，千兆以太网或者高速的广域网连接
	  (或者其他有高的带宽迟延的产品)提供数据服务，这个特性就会很有用。
	  特别是您在使用窗口缩放或者配置一个大的发送窗口。如果启用了这个选项，
	  同时要确信设置 <varname>net.inet.tcp.inflight_debug</varname> 为
	  <literal>0</literal>(关闭调试)，对于生产用来说，设置
	  <varname>net.inet.tcp.inflight_min</varname> 至少为
	  <literal>6144</literal> 可能会受益。然而，
	  注意设置一个高的最小值能有效的关闭依赖连接的带宽限制。
	  这个限制特性减少了在路由和交换包队列的堵塞数据数量，
	  也减少了在本地主机接口队列阻塞的数据的数量。在少数的等候队列中、
	  交互式连接，尤其是通过慢速的调制解调器，也能用低的
	  <emphasis>往返时间</emphasis>操作。但是，注意这只影响到数据发送
	  (上载/服务端)。对数据接收(下载)没有效果。</para>

	<para>调整 <varname>net.inet.tcp.inflight_stab</varname>
	  是 <emphasis>不</emphasis> 被建议的。这个参数的默认值是 20，
	  它代表两个最大的包被添加到带宽迟延窗口考虑。
	  另外的窗口是稳定算法和改善改变条件时的应答所需要的，
	  但是它也能导致通过慢速连接产生高的 ping 时间(虽然比您不用这个算法还慢)。
	  这些情况下，您可能想试着把这个参数减小到 15，10 或者 5；
	  并且也可能需要减小 <varname>net.inet.tcp.inflight_min</varname>
	  (例如3500)来达到效果。减少这些参数应该是最后的唯一手段。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>添加交换空间</title>

    <para>
      不管您计划的如何好，有时候系统并不像您所期待的那样运行。
      如果您发现需要更多的交换空间，添加它很简单。
      有三种方法增加交换空间：添加一块新的硬盘驱动器、通过
      NFS 使用交换空间和在一个现有的分区上创建一个交换文件。</para>

    <sect2 id="new-drive-swap">
      <title>在新的硬盘驱动器上使用交换空间</title>

      <para>这是添加交换空间最好的方法，
	当然为了达到这个目的需要添加一块硬盘。
	毕竟您总是可以使用另一块磁盘。如果能这么做，
	重新阅读一下手册中关于交换空间的 <xref
	linkend="configtuning-initial"> 来了解如何最优地安排交换空间。</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>通过 NFS 交换</title>

      <para>
	通过 NFS 来交换只在您没有本地硬盘交换的时候被建议。在
	&os; 4.X 以前的版本中使用NFS交换速度很慢并且效率低下。4.0-RELEASE
	和更新的版本中他的速度和效率还是可以接受的。即使使用新版本的
	&os;，NFS 交换也会被可用的网络带宽限制并且增加 NFS 服务器的负担。</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>交换文件</title>

      <para>
	您可以创建一个指定大小的文件用来当作交换文件。
	在我们的例子中我们将会使用叫做 <filename>/usr/swap0</filename>
	的 64MB 大小的文件。当然您也可以使用任何您所希望的名字。</para>

      <example>
        <title>在 &os; 4.X 上创建一个交换文件</title>

      <orderedlist>
	<listitem>
	  <para>确认您的内核配置包含了 vnode 驱动。
	  它不包含在最近版本的 <filename>GENERIC</filename>。</para>

          <programlisting>pseudo-device   vn 1   #Vnode driver (turns a file into a device)</programlisting>
        </listitem>

	<listitem>
	  <para>创建一个 vn-device 设备：</para>
	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
	</listitem>

	<listitem>
	  <para>创建一个交换文件 (<filename>/usr/swap0</filename>)：</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	</listitem>

	<listitem>
	  <para>赋予它(<filename>/usr/swap0</filename>)一个适当的权限：</para>

	  <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	</listitem>

	<listitem>
	  <para>在 <filename>/etc/rc.conf</filename> 中启用交换文件：</para>

	  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	</listitem>

	<listitem>

          <para>通过重新启动机器或下面的命令使交换文件立刻生效：</para>

          <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
        </listitem>
      </orderedlist>

      </example>
      <example>
	<title>在 &os; 5.X 上创建一个交换文件：</title>

      <orderedlist>
	<listitem>
	  <para>确认您的内核配置包含虚拟磁盘(Memory disk)驱动
	    (&man.md.4;)。它在 <filename>GENERIC</filename> 内核中是默认的。</para>

	  <programlisting>device   md   # Memory "disks"</programlisting>
	</listitem>

	<listitem>
	  <para>创建一个交换文件(<filename>/usr/swap0</filename>)：</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	</listitem>

	<listitem>
	  <para>赋予它(<filename>/usr/swap0</filename>)一个适当的权限：</para>

	  <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	</listitem>

	<listitem>
	  <para>在 <filename>/etc/rc.conf</filename> 中启用交换文件：</para>

	  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	</listitem>

	<listitem>

	  <para>通过重新启动机器或下面的命令使交换文件立刻生效：</para>

	  <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 && swapon /dev/md0</userinput></screen>
        </listitem>
      </orderedlist>

      </example>
    </sect2>
  </sect1>

  <sect1 id="acpi-overview">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Hiten</firstname>
	  <surname>Pandya</surname>
	  <contrib>Written by </contrib>
	</author>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>电源和资源管理</title>

    <para>
      以有效的方式利用硬件资源是非常重要的。在提出 <acronym>ACPI</acronym>
      之前，管理电源使用和系统散热对操作系统是很困难的。硬件被嵌入的
      <acronym>BIOS</acronym> 接口管理，例如<emphasis>可插拔 BIOS
      (PNPBIOS)</emphasis>或者<emphasis>高级电源管理(APM)</emphasis>
      等等。电源和资源管理是现代操作系统的关键组成部分。
      例如您可能当系统温度过高的时候让您的操作系统能监视到
      (并且可能提醒您)。
    </para>

    <para>
      在 &os; 使用手册的这一章节，我们将提供 <acronym>ACPI</acronym>
      全面的信息。参考资料会在末尾。<acronym>ACPI</acronym> 在
      &os; 5.X 及以上的操作系统中作为一个默认的内核模块被支持。对于
      &os; 4.9，<acronym>ACPI</acronym> 可以通过在内核配置文件中添加
      <literal>device acpica</literal> 并且重新编译内核来启用。
    </para>

    <sect2 id="acpi-intro">
      <title>什么是 ACPI？</title>

      <para>高级配置和电源接口(<acronym>ACPI</acronym>)
	是一个业界标准的硬件资源和电源管理接口(因此而得名)。它是
	<emphasis>操作系统控制的配置和电源管理(Operating System-directed
	configuration and Power Management)</emphasis>，也就是说，
	它给操作系统(<acronym>OS</acronym>)提供了更多的控制和弹性。
	现代操作系统<quote>延伸</quote>了当前即插即用接口(像是 &os;4.X
	中使用的 APM)的限制，在 <acronym>ACPI</acronym> 的介绍之前。
	<acronym>ACPI</acronym> 是 <acronym>APM(高级电源管理)</acronym>
	的直接继承者。</para>
    </sect2>

    <sect2 id="acpi-old-spec">
      <title>高级电源管理 (APM) 的缺点</title>

      <para><emphasis>高级电源管理 (APM)</emphasis>
      是一种基于系统目前的活动控制其电源使用的机制。
      APM BIOS 由 (系统的) 制造商提供， 并且是硬件平台专属的。
      在 OS 中的 APM 驱动作为中介来访问 <emphasis>APM 软件接口</emphasis>，
      从而实现对电源使用的管理。</para>

      <para>APM 有四个主要的问题。 首先， 电源管理是通过
      (制造商专属的) BIOS 实现的， 而 OS 则完全不了解其细节。
      例如， 用户在 APM BIOS 中设置了硬盘驱动器的空闲等待数值，
      当超过这一空闲时间的限制时， 它 (BIOS) 将会减慢硬盘驱动器的速度，
      而不会征求 OS 的同意。 第二， APM 逻辑是嵌入
      BIOS 的， 因此它是在 OS 的控制之外运转的。
      这意味着用户只能通过通过刷新他们 ROM 中的 APM BIOS
      才能够解决某些问题； 而这是一个很危险的操作，
      因为它可能使系统进入一个无法恢复的状态。 第三， APM
      是一种制造商专属的技术， 也就是说有很多第三方的
      (重复的工作) 以及 bugs， 如果在一个制造商的 BIOS 中有，
      也未必会在其他的产品中解决。 最后但绝不是最小的问题， APM
      BIOS 没有为实现复杂的电源策略提供足够的余地，
      也无法实现能够非常适合具体机器的策略。</para>

      <para><emphasis>即插即用 BIOS (PNPBIOS)</emphasis>
      在很多时候都是不可靠的。 PNPBIOS 是 16-位 的技术，
      因此 OS 不得不使用 16-位 模拟才能够与 PNPBIOS 的方法
      <quote>接口</quote>。</para>

      <para>&os; <acronym>APM</acronym> 驱动在 &man.apm.4; 手册页中有描述。</para>
    </sect2>

    <sect2 id="acpi-config">
      <title>配置 <acronym>ACPI</acronym></title>

      <para><filename>acpi.ko</filename> 驱动默认的在启动时通过
	&man.loader.8; 被加载并且 <emphasis>不应该</emphasis>
	被编译进内核。原因是这个模块跟系统很容易的工作在一起，比方说不用为了
	<filename>acpi.ko</filename> 而重新编译内核。
	这对更简单的测试来说很有利。另一个原因是系统启动后再启动
	<acronym>ACPI</acronym> 不是很有用，并且在一些情况下会失败。
	拿不准的话只要全部禁止 <acronym>ACPI</acronym> 即可。
	这个驱动不应该而且不能被卸载，因为系统通过它跟各种各样的硬件打交道。
	<acronym>ACPI</acronym> 可以通过 &man.acpiconf.8; 来禁止。实际上通过
	<acronym>ACPI</acronym> 的交互可以通过 &man.acpiconf.8; 来完成。
	简单的说，如果任何关于 <acronym>ACPI</acronym> 的信息在
	&man.dmesg.8; 的输出中，那么它很可能已经运行了。</para>

      <note><para><acronym>ACPI</acronym> 和 <acronym>APM</acronym>
	不能共存并且应该份开始用。后来装载的如果注意到另一个在运行将会终止执行。</para></note>

      <para>最简单的表现形式是，<acronym>ACPI</acronym> 可以通过
	&man.acpiconf.8; 的 <option>-s</option> 标志和一个
	<literal>1-5</literal> 的选项来使系统进入休眠状态。
	<literal>5</literal> 选项将会像下面动作一样让系统软关机：</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>

      <para>其他选项也是可行的。查看 &man.acpiconf.8; 手册页以获得更多信息。</para>
    </sect2>
  </sect1>

  <sect1 id="ACPI-debug">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Nate</firstname>
          <surname>Lawson</surname>
          <contrib>撰写人：</contrib>
        </author>
      </authorgroup>
      <authorgroup>
        <author>
          <firstname>Peter</firstname>
          <surname>Schultz</surname>
          <contrib>协力：</contrib>
        </author>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
        </author>
      </authorgroup>
    </sect1info>

    <title>使用和调试 &os; <acronym>ACPI</acronym></title>

    <para><acronym>ACPI</acronym> 是一种全新的发现设备、 管理电源使用，
      提供过去由 <acronym>BIOS</acronym> 管理的访问不同硬件的标准化方法。
      让 <acronym>ACPI</acronym> 在各种系统上都能正确使用的工作一直在进行，
      但许多主板的 <firstterm><acronym>ACPI</acronym> 机器语言</firstterm>
      (<acronym>AML</acronym>) 字节代码中的 bug，  &os; 的内核中资系统设计的不完善，
      以及  &intel;
      <acronym>ACPI-CA</acronym> 解释器中的 bug 仍然不时会出现。</para>

    <para>这份文档期望能够帮助您协助 &os;
      <acronym>ACPI</acronym> 的维护人员来找到您所观察到的问题的根源，
      并通过调试找到其解决方法。 感谢您阅读这份文档，
      我们也希望能够解决您的系统上的问题。</para>

    <sect2 id="ACPI-submitdebug">
      <title>提交调试信息</title>

      <note>
	<para>在提交问题之前， 请确认您已经在运行最新的
	  <acronym>BIOS</acronym> 版本， 此外， 也包括嵌入式控制器的固件版本。</para>
      </note>

      <para>如果您希望提交一个问题，
	请确保将下述信息法到
	<ulink url="mailto:freebsd-acpi@FreeBSD.org">
	freebsd-acpi@FreeBSD.org</ulink>:</para>

      <itemizedlist>
	<listitem>
	  <para>问题行为的描述， 包括系统类型、型号，以及任何触发问题的相关信息。
	    另外， 请注意尽可能准确地描述这一问题是否对您是陌生的。</para>
	</listitem>

	<listitem>
	  <para>在 <quote>boot
	    <option>-v</option></quote> 之后得到的 &man.dmesg.8; 输出， 以及任何在重现
	    bug 时出现的错误信息。</para>
	</listitem>

	<listitem>
	  <para>在禁用了 <acronym>ACPI</acronym> 之后的 <quote>boot
	    <option>-v</option></quote> 的 &man.dmesg.8; 输出， 如果您发现禁用 ACPI
	    能够帮助消除问题。</para>
	</listitem>

	<listitem>
	  <para>来自 <quote>sysctl hw.acpi</quote> 的输出。 这也是找到您的系统所提供的功能的一种好办法。</para>
	</listitem>

	<listitem>
	  <para>能够得到您的 <firstterm><acronym>ACPI</acronym> Source Language</firstterm>
	    (<acronym>ASL</acronym>) 的 <acronym>URL</acronym>。
	    <emphasis>不要</emphasis> 把
	    <acronym>ASL</acronym> 直接发到邮件列表中，
	    因为它们可能非常大。
	    为了得到 <acronym>ASL</acronym>
	    您可以运行这个命令：</para>

	  <screen>&prompt.root; <userinput>acpidump -t -d &gt; <replaceable>name</replaceable>-<replaceable>system</replaceable>.asl</userinput></screen>

	  <para>(把
	    <replaceable>name</replaceable> 改为您的登录名，
	    并把
	    <replaceable>system</replaceable> 改为您的硬件制造商及其型号。 例如：
	    <filename>njl-FooCo6000.asl</filename>)</para>
	</listitem>
      </itemizedlist>

      <para>许多开发者也会订阅 &a.current;
        但还是请发到 &a.acpi.name; 这样它会被更多人看到。
	请耐心等待， 因为我们都有全职的其他工作。
	如果您的 bug 不是显而易见的， 我们可能会要求您通过
	&man.send-pr.1; 来提交一个 <acronym>PR</acronym>。
	在输入 <acronym>PR</acronym> 时，请将同样的信息包含进去。
	这将帮助我们来追踪和解决问题。
	不要在给 &a.acpi.name; 写信之前发送
	<acronym>PR</acronym> 因为我们把它当作已知文体的备忘录而不是报告机制。
	您的问题很可能已经被其他人报告过了。</para>
    </sect2>

    <sect2 id="ACPI-background">
      <title>背景</title>

      <para><acronym>ACPI</acronym> 存在于采用
	ia32 (x86)、 ia64 (安腾)、 以及 amd64 (AMD) 架构的所有现代计算机上。
	完整的标准具有大量的各式功能， 包括
	<acronym>CPU</acronym> 性能管理、 电源控制、 温度监控、
	电池系统、 嵌入式控制器以及总线枚举。
	绝大多数系统实现比完整标准的功能要少一些。 例如，
	桌面系统通常只实现总线枚举部分， 而笔记本则通常支持降温和电源管理功能。
	笔记本通常还提供休眠和唤醒支持， 并提供与此适应的复杂功能。</para>

      <para>符合 <acronym>ACPI</acronym> 的系统中有许多组件。
	<acronym>BIOS</acronym> 和芯片组制造商提供一些固定的表
	(例如， <acronym>FADT</acronym>) 在存储器中， 以提供类似
	<acronym>APIC</acronym> 映射 (用于 <acronym>SMP</acronym>)、
	配置寄存器、 以及简单的配置值等等。 另外，
	一个字节代码 (bytecode) 表
	(<firstterm>系统区别描述表</firstterm>
	<acronym>DSDT</acronym>)
	则提供了通过树状命名空间来指定设备及其功能的方法。</para>

      <para><acronym>ACPI</acronym> 驱动必须要处理固定表，
	实现字节码解释器， 并修改驱动程序和内核， 以接受来自
	<acronym>ACPI</acronym> 子系统的信息。 对于 &os;， &intel;
	提供了一个解释器 (<acronym>ACPI-CA</acronym>)，
	它在 Linux 和 NetBSD 也可以使用。
	<acronym>ACPI-CA</acronym> 源代码可以在
	<filename role="directory">src/sys/contrib/dev/acpica</filename>
	找到。 用于在 &os; 中允许 <acronym>ACPI-CA</acronym>
	正确运转的代码则在
	<filename>src/sys/dev/acpica/Osd</filename>。
	最后， 用于实现 <acronym>ACPI</acronym> 设备的驱动可以在
	<filename role="directory">src/sys/dev/acpica</filename> 找到。</para>
    </sect2>

    <sect2 id="ACPI-comprob">
      <title>常见问题</title>

      <para>为了使 <acronym>ACPI</acronym> 正常工作，
	它的每一部分都必须工作正常。 这里是一些常见的问题，
	按照出现的频繁程度顺序排序， 并提供了一些绕过或修正它们的方法。</para>

      <sect3>
	<title>休眠/唤醒</title>

	<para><acronym>ACPI</acronym> 提供了三种休眠到
	  <acronym>RAM</acronym> (<acronym>STR</acronym>) 的状态，
	  <literal>S1</literal>-<literal>S3</literal>，
	  以及一个休眠到磁盘的状态 (<literal>STD</literal>)，
	  称作 <literal>S4</literal>。 <literal>S5</literal> 是
	  <quote>软关机</quote> 同时也是系统接好电源但没有开机时的正常状态。
	  <literal>S4</literal> 实际上可以用两种不同的方法来实现。
	  <literal>S4</literal><acronym>BIOS</acronym> 是一种由
	  <acronym>BIOS</acronym> 辅助的挂起到磁盘方法， 而
	  <literal>S4</literal><acronym>OS</acronym>
	  则是完全由操作系统实现的。</para>

	<para>可以使用 <command>sysctl</command>
	  <option>hw.acpi</option> 来查看与休眠有关的项目。
	  这里是我的 Thinkpad 上得到的结果。</para>

	<screen>hw.acpi.supported_sleep_state: S3 S4 S5</screen>
	<screen>hw.acpi.s4bios: 0</screen>

	<para>这表示我可以使用 <command>acpiconf -s</command>
	  来测试 <literal>S3</literal>，
	  <literal>S4</literal><acronym>OS</acronym>， 以及
	  <literal>S5</literal>。 如果 <option>s4bios</option> 是一
	  (<literal>1</literal>)， 则可以使用
	  <literal>S4</literal><acronym>BIOS</acronym>
	  来代替 <literal>S4</literal>
	  <acronym>OS</acronym>。</para>

	<para>当测试休眠/唤醒时， 从
	  <literal>S1</literal> 开始， 如果它被支持的话。
	  这个状态是最可能正常工作的状态， 因为它不需要太多的驱动支持。
	  没有人实现 <literal>S2</literal> 但如果您有它的支持，
	  则应该和 <literal>S1</literal> 类似。 下一件值得尝试的是
	  <literal>S3</literal>。 这是最深的
	  <acronym>STR</acronym> 状态，
	  并需要一系列驱动的支持才能够正常地重新初始化您的硬件。
	  如果您在唤醒系统时遇到问题， 请不要吝惜发邮件给 &a.acpi.name;
	  邮件列表， 尽管不要指望问题一定会很快解决，
	  因为有许多驱动程序/硬件需要进行更多的测试和改进。</para>

	<para>为了帮助隔离问题， 请在内核中删去尽可能多的驱动。
	  如果这样做能够解决问题， 请尝试逐个加载驱动直到问题再次出现。
	  通常预编译的驱动程序如
	  <filename>nvidia.ko</filename>、 <application>X11</application>
	  显示驱动， 以及 <acronym>USB</acronym> 的问题最多，
	  而以太网卡的驱动则通常工作的很好。
	  如果您能够通过加载和卸载驱动使系统正常工作，
	  您可以通过将适当的命令放到
	  <filename>/etc/rc.suspend</filename> 和
	  <filename>/etc/rc.resume</filename> 来将这个过程自动化。
	  在这两个文件中有一个注释掉的卸载和加载驱动程序的例子供您参考。
	  另外您还可以将 <option>hw.acpi.reset_video</option> 设置为零
	  (0)， 如果您的显示在唤醒之后显得很混乱。
	  此外您还可以尝试更长或更短的
	  <option>hw.acpi.sleep_delay</option> 值看看是否有所助益。</para>

	<para>另一件值得一试的事情是使用一个比较新的包含
	  <acronym>ACPI</acronym> 支持的 Linux 发行版来试试看他们的
	  休眠/唤醒 功能是否在同样的硬件上能够正常工作。
	  如果在 Linux 下正常， 则很可能是 &os; 驱动程序的问题，
	  而隔离问题并找到存在问题的驱动有助于解决它。
	  需要注意的是 <acronym>ACPI</acronym> 的维护人员通常并不维护其他驱动
	  (例如 声音、 <acronym>ATA</acronym>， 等等)
	  因此如果最终发现是驱动的问题最好还是发到
	  &a.current.name; 邮件列表并发给驱动程序的维护者。
	  如果您喜欢冒险， 则可以加一些 &man.printf.3;
	  到有问题的驱动中， 以找到它的恢复功能发生问题的位置。</para>

	<para>最后， 试试看禁用 <acronym>ACPI</acronym>
	  并代之以启用 <acronym>APM</acronym>。
	  如果 休眠/唤醒 能够在 <acronym>APM</acronym> 下正常工作，
	  使用 <acronym>APM</acronym> 可能会更好，
	  特别是对于较老的硬件 (2000年以前)。
	  硬件制造商需要一些时间来让老硬件的
	  <acronym>ACPI</acronym> 工作正常，
	  而 <acronym>ACPI</acronym> 的问题十之八九是
	  <acronym>BIOS</acronym> 中的毛病引发的。</para>
      </sect3>

      <sect3>
	<title>系统停止响应 (暂时或永久性地)</title>

	<para>绝大多数系统停止响应是由于未能及时响应中断或发生了中断风暴导致的。
	  芯片组有很多问题最终会溯源到 <acronym>BIOS</acronym>
	  如何在引导系统之前配置中断， <acronym>APIC</acronym>
	  (<acronym>MADT</acronym>) 表的正确性， 以及
	  <firstterm>系统控制中断</firstterm>
	  (<acronym>SCI</acronym>) 如何路由。</para>

	<para>通过察看 <command>vmstat -i</command>
	  的输出中包括 <literal>acpi0</literal>
	  的那一行可以区分中断风暴和未能及时响应中断。
	  如果每秒计数器增长的速度多于一两个，
	  则您是遇到了中断风暴。 如果系统停止了响应，
	  您可以尝试停止内核并进入 <acronym>DDB</acronym>
	  (在控制台上按 <keycombo action="simul"><keycap>CTRL</keycap>
	  <keycap>ALT</keycap><keycap>ESC</keycap></keycombo>)
	  并输入 <option>show interrupts</option>。</para>

	<para>处理中断问题的救命稻草是尝试禁用
	  <acronym>APIC</acronym> 支持， 这是通过在
	  <filename>loader.conf</filename> 中加入
	  <literal>hint.apic.0.disabled="1"</literal>
	  完成的。</para>
      </sect3>

      <sect3>
	<title>崩溃</title>

	<para>崩溃对于 <acronym>ACPI</acronym> 是比较罕见的情况，
	  如果发现， 将会非常重视并很快修复。
	  您要做的第一件事是设法隔离出能够重现崩溃 (如果可能的话)
	  的操作并获取一份调用队战。 请启用
	  <option>options DDB</option> 并设置串行控制台
	  (参见 <xref linkend="serialconsole-ddb">)
	  或配置一个 &man.dump.8; 分区。 您将在
	  <acronym>DDB</acronym> 中通过 <option>tr</option>
	  得到调用队战。 如果您只能用手抄的方法记录它，
	  一定要记下头五 (5) 行和最后五 (5) 行。</para>

	<para>然后， 尝试通过在启动时禁用
	  <acronym>ACPI</acronym> 来隔离故障。 如果这样做能够正常工作，
	  请通过设置 <option>debug.acpi.disable</option>
	  的那组数值来隔离具体是哪个 <acronym>ACPI</acronym>
	  子系统的问题。 请参见
	  &man.acpi.4; 联机手册中给出的那些例子。</para>
      </sect3>

      <sect3>
	<title>系统在休眠或关机之后又启动了</title>
	<para>首先请尝试在 &man.loader.conf.5; 中设置
	  <option>hw.acpi.disable_on_poweroff=</option><quote>0</quote>。
	  这将让 <acronym>ACPI</acronym> 不再在关机过程中禁用一些事件。
	  基于同样的原因， 一些系统需要把这个值设置为 <quote>1</quote>
	  (这是默认值)。
	  这通常能够修复在休眠或关机时立即再次启动的问题。</para>
      </sect3>

      <sect3>
	<title>其他问题</title>

	<para>如果您有 <acronym>ACPI</acronym> 的其他问题
	  (同 docking station 协同工作、 无法检测设备， 等等)，
	  请把描述发给邮件列表； 不过， 这些问题也有可能和
	  <acronym>ACPI</acronym> 中尚未完成的部分有关，
	  它们可能需要时间才能被实现。 请保持耐心，
	  并准备测试我们可能会发给您的补丁。</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-aslanddump">
      <title><acronym>ASL</acronym>、<command>acpidump</command>， 以及
        <acronym>IASL</acronym></title>

      <para>最常见的问题是 <acronym>BIOS</acronym>
	制造商提供的不正确 (甚至完全错误的!) 字节代码。
	这通常会以类似下面这样的内核消息显示在控制台上：</para>

      <screen>ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND</screen>

      <para>通常您可以通过将
	<acronym>BIOS</acronym> 升级到最新版本来解决这类问题。
	绝大多数控制台消息是无害的， 但如果您有其他问题例如电池工作不正常，
	则从 <acronym>AML</acronym> 开始查找问题将是一条捷径。
	字节代码， 或常说的 <acronym>AML</acronym>， 是从一种称作
	<acronym>ASL</acronym> 语言的原代码编译得到的结果。
	<acronym>AML</acronym> 在
	<acronym>DSDT</acronym> 表中。 要得到您系统的
	<acronym>ASL</acronym>， 需要使用 &man.acpidump.8;。
	您应该使用 <option>-t</option> (显示固定表的内容)
	和 <option>-d</option> (将 <acronym>AML</acronym> 反汇编成
	<acronym>ASL</acronym>) 两个选项。 参考
	<link linkend="ACPI-submitdebug">如何提交调试信息</link>
	一节以获得示范用法。</para>

      <para>您可以检查的第一件事是重新编译
	<acronym>ASL</acronym> 来看看是否有错误。
	警告通常都可以忽略， 而错误通常会使导致
	<acronym>ACPI</acronym> 无法正常工作的原因。 要编译您的
	<acronym>ASL</acronym>， 使用下面的命令：</para>

      <screen>&prompt.root; <userinput>iasl your.asl</userinput></screen>
    </sect2>

    <sect2 id="ACPI-fixasl">
      <title>修复 <acronym>ASL</acronym></title>

      <para>我们的长期目标是让每一个人都能够在不需要任何用户干预的情况下使用
	<acronym>ACPI</acronym>。 然而， 目前我们仍然在开发绕过
	<acronym>BIOS</acronym> 制造商常见错误的方法。
	Microsoft 解释器 (<filename>acpi.sys</filename> 和
	<filename>acpiec.sys</filename>) 并不会严格地检查是否遵守了标准，
	因此许多只在 Windows 中测试 <acronym>ACPI</acronym> 的
	<acronym>BIOS</acronym> 制造商很可能永远不会修正他们的
	<acronym>ASL</acronym>。 我们希望不断地找出并用文档说明
	Microsoft 的解释器到底允许那些不标准的行为，
	并在 &os; 进行对应的修改使它能够正常工作而不需要用户修正
	<acronym>ASL</acronym>。 作为一项临时缓解问题的方法，
	并帮助我们确认其行为， 您可以手工修正
	<acronym>ASL</acronym>。 如果这样能够解决问题，
	请把新旧 <acronym>ASL</acronym> 的 &man.diff.1;
	发给我们， 这样我们就有可能绕过 <acronym>ACPI-CA</acronym>
	中的错误行为， 从而不再需要您来手工修正。</para>

      <para>下面是一些常见的错误信息， 它们的原因，
	以及如何修正。</para>

      <sect3>
	<title>_OS dependencies (_OS 依赖)</title>

	<para>某些 <acronym>AML</acronym> 假定世界是由不同版本的
	  Windows 组成的。 您可以让 &os; 声称自己是任意
	  <acronym>OS</acronym> 来看一看是否能够修正问题。
	  比较简单的办法是设置
	  <option>hw.acpi.osname</option>=<quote>Windows 2001</quote>
	  到 <filename>/boot/loader.conf</filename> 中， 或使用您在
	  <acronym>ASL</acronym> 中找到的其他字符串。</para>
      </sect3>

      <sect3>
	<title>Missing Return statements (缺少返回语句)</title>

	<para>一些方法可能没按照标准要求的那样显式地返回值。
	  尽管 <acronym>ACPI-CA</acronym> 无法处理它，
	  但 &os; 提供了一个绕过它并允许其暗含地返回值的方法。
	  您也可以增加一个显式的
	  Return 语句， 如果您知道那里需要返回一个值的话。
	  要强制 <command>iasl</command> 编译
	  <acronym>ASL</acronym>， 需要使用 <option>-f</option>
	  标志。</para>
      </sect3>

      <sect3>
	<title>替换默认的 <acronym>AML</acronym></title>

	<para>在定制 <filename>your.asl</filename> 之后，
	  您可以通过下面的命令编译它：</para>

	<screen>&prompt.root; <userinput>iasl your.asl</userinput></screen>

	<para>可以使用 <option>-f</option> 标志来强制创建
	  <acronym>AML</acronym>， 即使在编译过程中发生了错误。
	  请注意某些错误 (例如， 缺少 Return 语句)
	  会自动被解释器忽略掉。</para>

	<para><filename>DSDT.aml</filename> 是
	  <command>iasl</command> 命令的默认输出文件名。
	  可以加载它来取代您 <acronym>BIOS</acronym>
	  中存在问题的副本 (它仍然存在于闪存中)，
	  其方法是按下面的说明编辑
	  <filename>/boot/loader.conf</filename>：</para>

	<programlisting>acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"</programlisting>

	<para>一定要把您的 <filename>DSDT.aml</filename> 复制到
	  <filename role="directory">/boot</filename> 目录中。</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-debugoutput">
      <title>从
	<acronym>ACPI</acronym> 中获取调试输出信息</title>

      <para><acronym>ACPI</acronym> 驱动程序提供了非常灵活的调试机制。
	这允许您指定一组子系统， 以及所需要的详细信息。
	需要调试的子系统可以按 <quote>layers(层)</quote>
	来指定， 并分为	<acronym>ACPI-CA</acronym> 组件 (ACPI_ALL_COMPONENTS)
	和 <acronym>ACPI</acronym> 硬件支持 (ACPI_ALL_DRIVERS)。
	调试输出的详细程度可以通过
	<quote>level(详细度)</quote> 来指定， 其范围是
	ACPI_LV_ERROR (只报告错误) 到 ACPI_LV_VERBOSE (显示所有)。
	<quote>level</quote> 是一个位掩码因此可以一次设置多个选项，
	中间用空格分开。 实际使用中您应该考虑使用串行控制台来记录输出，
	如果它太长以至于冲掉了控制台消息缓冲的话。
	不同的层和输出详细度的完整列表可以在 &man.acpi.4; 联机手册中找到。</para>

      <para>调试输出默认并不开启。 要起用它， 您需要在内核设置中添加
	<option>options ACPI_DEBUG</option>， 如果您的内核中编入了
	<acronym>ACPI</acronym> 的话。 您还可以在
	<filename>/etc/make.conf</filename> 中加入
	<option>ACPI_DEBUG=1</option> 来在全局起用它。
	如果它只是模块， 您可以用下面的方法来重新编译
	<filename>acpi.ko</filename>：</para>

      <screen>&prompt.root; <userinput>cd /sys/modules/acpi/acpi
&amp;&amp; make clean &amp;&amp;
make ACPI_DEBUG=1</userinput></screen>

      <para>安装 <filename>acpi.ko</filename> 到
	<filename role="directory">/boot/kernel</filename>
	并把所需的详细度和层在 <filename>loader.conf</filename> 中指定。
	这个例子讲起用所有
	<acronym>ACPI-CA</acronym> 组件以及所有
	<acronym>ACPI</acronym> 硬件驱动
	(<acronym>CPU</acronym>、 <acronym>LID</acronym>， 等等) 的消息。
	只输出错误信息， 也就是最低的详细度。</para>

      <programlisting>debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"</programlisting>

      <para>如果您需要的信息是由某个特定的事件触发的
	(比如说， 休眠之后的唤醒)， 您可以不修改
	<filename>loader.conf</filename> 而转而使用
	<command>sysctl</command>
	来在启动和为那个事件准备系统之后再指定层和详细度。
	这些 <command>sysctl</command> 的名字和
	<filename>loader.conf</filename> 中的一致。</para>
    </sect2>

    <sect2 id="ACPI-References">
      <title>参考文献</title>

      <para>关于 <acronym>ACPI</acronym> 的更多信息可以从下面这些地方找到：</para>

      <itemizedlist>
	<listitem>
	  <para>The &a.acpi;</para>
	</listitem>

	<listitem>
	  <para><acronym>ACPI</acronym> 邮件列表存档
	    <ulink url="http://lists.freebsd.org/pipermail/freebsd-acpi/"></ulink></para>
	</listitem>

        <listitem>
          <para>旧的 <acronym>ACPI</acronym> 邮件列表存档
            <ulink url="http://home.jp.FreeBSD.org/mail-list/acpi-jp/"></ulink></para>
        </listitem>

	<listitem>
	  <para>The <acronym>ACPI</acronym> 2.0 标准
	    <ulink url="http://acpi.info/spec.htm"></ulink></para>
	</listitem>

	<listitem>
	  <para>&os; 手册页: &man.acpi.4;,
	    &man.acpi.thermal.4;, &man.acpidump.8;, &man.iasl.8;,
	    &man.acpidb.8;</para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt">
	    <acronym>DSDT</acronym> 调试资源</ulink>.
	    (使用 Compaq 作为例子但通常情况下都很有用。)</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
