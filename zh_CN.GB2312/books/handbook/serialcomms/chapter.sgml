<!--
     The FreeBSD Documentation Project
     The FreeBSD Simplified Chinese Project

     Original Revision: 1.95
     $FreeBSD$
-->

<chapter id="serialcomms">
  <title>串口通讯</title>

  <sect1 id="serial-synopsis">
    <title>概述</title>

    <indexterm><primary>串口通讯</primary></indexterm>
    <para>&unix; 一直都是支持串口通讯的。事实上，
      早期的 &unix; 系统就是利用串行线来输入和输出数据的。
      那时常见的 <quote>终端</quote> 包括一个每秒10个字符的串行打印机和键盘，
      现在这些已经发生了很大的变化。 这章将介绍一些利用 FreeBSD
      进行串行通讯的方法。</para>

    <para>读完这章，您将了解到：</para>
    <itemizedlist>
      <listitem><para>如何通过终端连接到您的FreeBSD系统。</para></listitem>
      <listitem><para>如何使用modem拨号到远程主机。</para></listitem>
      <listitem><para>如何允许远程用户通过modem登录到您的系统。</para></listitem>
      <listitem><para>如何从串行控制台引导您的系统。</para></listitem>
    </itemizedlist>

    <para>阅读这章之前，您应当了解：</para>
    <itemizedlist>
      <listitem><para>如何配置和安装一个新的内核。(<xref
        linkend="kernelconfig">)。</para></listitem>
      <listitem><para>理解UNIX的权限和进程(<xref linkend="basics">)。</para></listitem>
      <listitem><para>准备您打算使用的串行设备 (modem或多插口卡)
        的技术参考手册。</para></listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="serial">
    <title>介绍</title>

    <!-- XXX Write me! -->

    <sect2 id="serial-terminology">
      <title>术语</title>

      <variablelist>
        <indexterm><primary>bits-per-second</primary></indexterm>
	<varlistentry>
	  <term>bps</term>
	  <listitem>
	    <para>每秒位&mdash; 数据的传输速度</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DTE</term>
	  <indexterm><primary>DTE</primary></indexterm>
	  <listitem>
	    <para>数据终端设备 &mdash; 如您的计算机</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DCE</term>
	  <indexterm><primary>DCE</primary></indexterm>
	  <listitem>
	    <para>数据通讯设备 &mdash; 如您的modem</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RS-232</term>
	  <indexterm><primary>RS-232C cables</primary></indexterm>
	  <listitem>
	    <para>用于硬件串行通讯的EIA标准</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>当讨论通讯数据速度的时候，这节不会使用术语
	<quote>baud</quote>。Baud指电气标准传输率，它已经使用了很长时间，
	而 <quote>bps</quote> (bits per second) 才是正确使用的术语
	(至少它不会打扰那些爱争吵的家伙)。</para>
    </sect2>

    <sect2 id="serial-cables-ports">
      <title>线缆和端口</title>

      <para>要连接 modem 或终端到您的 FreeBSD 系统，
	您需要有一个串口以及连接到您串行设备所需的线缆。
	如果您比较熟悉硬件和它要求的线缆， 则可以跳过这节。</para>

      <sect3 id="term-cables">
	<title>线缆</title>

	<para>有好几种不同的串行线缆。 两个最普通的类型是 null-modem
	  线缆和标准RS-232线缆。 您硬件的规格说明会有详细描述。</para>

	<sect4 id="term-cables-null">
	  <title>Null-modem线缆</title>

	  <indexterm>
	    <primary>null-modem cable</primary>
	  </indexterm>
	  <para>一根null-modem线缆会直接通过像 <quote>地信号</quote>
	    这样的信号，而转换其他的信号。 例如，
	    <quote>数据发送</quote> 连到对端的
	    <quote>数据接收</quote> 引脚上。</para>

	  <para>如果需要， 您可以自己做一个null-modem的线缆。
	  下面这个表列出了这个线缆 DB-25 头上的 RS-232C 信号名和引脚标号。</para>

	  <informaltable frame="none">
	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry>信号</entry>
		  <entry>引脚 #</entry>
		  <entry></entry>
		  <entry>引脚 #</entry>
		  <entry>信号</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>SG</entry>
		  <entry>7</entry>
		  <entry>连接到</entry>
		  <entry>7</entry>
		  <entry>SG</entry>
		</row>

		<row>
		  <entry>TD</entry>
		  <entry>2</entry>
		  <entry>连接到</entry>
		  <entry>3</entry>
		  <entry>RD</entry>
		</row>

		<row>
		  <entry>RD</entry>
		  <entry>3</entry>
		  <entry>连接到</entry>
		  <entry>2</entry>
		  <entry>TD</entry>
		</row>

		<row>
		  <entry>RTS</entry>
		  <entry>4</entry>
		  <entry>连接到</entry>
		  <entry>5</entry>
		  <entry>CTS</entry>
		</row>

		<row>
		  <entry>CTS</entry>
		  <entry>5</entry>
		  <entry>连接到</entry>
		  <entry>4</entry>
		  <entry>RTS</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>连接到</entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DCD</entry>
		  <entry>8</entry>
		  <entry></entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DSR</entry>
		  <entry>6</entry>
		  <entry>连接到</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <note>
	    <para>在连接头里面连接好<quote>数据发送就绪</quote> (DSR)和
	      <quote>载波检测</quote> (DCD) 两个信号，然后连接到对端的
	      <quote>数据终端就绪</quote> (DTR)。</para>
	  </note>
	</sect4>

	<sect4 id="term-cables-std">
	  <title>标准RS-232C线缆</title>
	  <indexterm><primary>RS-232C cables</primary></indexterm>

	  <para>一个标准的串行线缆会直接通过所有的RS-232C信号。
	    这是连接一个modem到您的 FreeBSD 系统的线缆类型，
	    线缆的类型需要针对一些终端。</para>
	</sect4>
      </sect3>

      <sect3 id="term-ports">
	<title>端口</title>

	<para>串行端口是FreeBSD主机与终端传输数据的设备。
	  这节描述了端口的种类和它们在 FreeBSD 上是如何编址的。</para>

	<sect4 id="term-portkinds">
	  <title>端口的种类</title>

	  <para>存在好几种端口。 在购买和做线缆之前，
	    您需要确定它是否适合您机器的终端。</para>

	  <para>绝大多数的终端有DB25端口。个人计算机， 也包括运行 FreeBSD
	    的PC机， 通常都会有 DB25 或 DB9 插口。
	    如果您的计算机有一个多插口的串口卡，
	    则可以使用RJ-12 或RJ-45端口。</para>

	  <para>请仔细看看硬件的说明， 此外您也可以通过外观了解是什么插口。</para>
	</sect4>

	<sect4 id="term-portnames">
	  <title>端口名称Port Names</title>

	  <para>在FreeBSD中，您可以通过 <filename>/dev</filename>
	    目录中的一个记录来访问每个串行端口。有两种不同的记录：</para>

	  <itemizedlist>
	    <listitem>
	      <para>呼入端口被命名为<filename>/dev/ttyd<replaceable>N</replaceable></filename>，
		这里 <replaceable>N</replaceable> 是端口号，从零开始。
		通常，您使用呼入端口作为终端。呼入端口要求数据线使用载波检测
		(DCD) 信号来工作。</para>
	    </listitem>

	    <listitem>
	      <para>呼出端口被命名为 <filename>/dev/cuaa<replaceable>N</replaceable></filename>。
		您通常不使用呼出端口作为终端， 只使用modem。
		如果串行线或终端不支持载波检测数据传输，
		您可以使用呼出端口。</para>
	    </listitem>
	  </itemizedlist>

	  <para>如果您已经连接一个终端到第一个串行端口 (在 &ms-dos;
	    上是<devicename>COM1</devicename>)，
	    则可以使用 <filename>/dev/ttyd0</filename> 来作为终端。
	    如果它是在第二个串行端口 (<devicename>COM2</devicename>)，
	    那就是 <filename>/dev/ttyd1</filename>，等等。</para>

	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>内核配置</title>

      <para>FreeBSD默认支持4个串行端口。在&ms-dos;下，这些是
	<devicename>COM1</devicename>，
	<devicename>COM2</devicename>，
	<devicename>COM3</devicename>，
	和
	<devicename>COM4</devicename>。FreeBSD当前支持 <quote>dumb</quote>
	多插口串行接口卡，如 BocaBoard 1008 和 2016，与许多 Digiboard
	和 Stallion Technologies 制造的智能多接口卡一样好。 然而，
	默认的内核只会寻找标准的COM端口。</para>

      <para>要看看您的内核是否支持您的串口，只要在内核启动时查看一下启动信息，
	或使用 <command>/sbin/dmesg</command> 命令重新检测内核启动信息。
	特别的，寻找以<literal>sio</literal>字符启动的信息。</para>

      <tip><para>提示：要看看带有<literal>sio</literal>字符的信息，
	可以使用下面的命令：</para>

      <screen>&prompt.root; <userinput>/sbin/dmesg | grep 'sio'</userinput></screen>
      </tip>

      <para>例如，在一个带有4个串口的系统上，这些是串口特定的内核启动信息：</para>

      <screen>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A</screen>

      <para>如果您的内核没有认出您的所有串口，您需要为您的系统定制内核。
	更多有关配置内核的细节，可以看看第9章<xref
	linkend="kernelconfig">。</para>

      <para>在您的内核配置文件中相关的设备行是这样的，FreeBSD&nbsp;4.X:</para>

      <programlisting>
device		sio0	at isa? port port IO_COM1 irq 4
device		sio1	at isa? port port IO_COM2 irq 3
device		sio2	at isa? port IO_COM3 irq 5
device		sio3	at isa? port IO_COM4 irq 9</programlisting>


      <para>FreeBSD&nbsp;5.X:</para>

      <programlisting>device		sio</programlisting>

      <para>您可以注释掉或完全删除您没有的设备。 FreeBSD&nbsp;5.X 需要修改
	<filename>/boot/device.hints</filename>文件。请看看 &man.sio.4;
	的有关如何为您的多插口主板写入配置信息的联机手册。
	如果您使用了一个不同版本的 FreeBSD 的配置文件，请小心点，
	因为设备的标记在两个版本之间已经改变了。</para>

      <note>
	<para>这里端口 <literal>IO_COM1</literal> 代替了
	  <literal>0x3f8</literal>，端口 <literal>IO_COM2</literal> 代替了
	  <literal>0x2f8</literal>，端口 <literal>IO_COM3</literal> 代替了
	  <literal>0x3e8</literal>，端口 <literal>IO_COM4</literal> 代替了
	  <literal>0x2e8</literal>，这些都是各自端口相应的端口地址。
	  中断4，3，5，9都是经常用的中断。也要注意有些正常的串行端口可能
	  <emphasis>无法</emphasis> 在一些ISA总线的PC上共享中断
	  (多插口板卡有板载的电子设备，允许在板上所有 16550A
	  的设备共享一个或两个中断请求)。</para>
      </note>

    </sect2>

    <sect2>
      <title>设备指定文件</title>

      <para>内核中的绝大多数设备可以通过 <quote>设备特殊文件</quote> 来访问，
	它就在<filename>/dev</filename>目录下。
	<devicename>sio</devicename> 设备通过
	<filename>/dev/ttyd<replaceable>N</replaceable></filename> (拨入)和
	<filename>/dev/cuaa<replaceable>N</replaceable></filename> (拨出)
	设备来访问。 FreeBSD 也提供了初始化的设备
	(<filename>/dev/ttyid<replaceable>N</replaceable></filename> 和
	<filename>/dev/cuaia<replaceable>N</replaceable></filename>) 以及锁定的设备
	(<filename>/dev/ttyld<replaceable>N</replaceable></filename> 和
	<filename>/dev/cuala<replaceable>N</replaceable></filename>)。
	初始化的设备在每次端口被打开时被用来初始化设备通讯端口参数。
	例如使用 <literal>RTS/CTS</literal> 的流控制信号的
	<literal>crts</literal>的调制解调器。
	锁定设备用来锁定端口的标记以阻止用户或程序改变某个参数。
	参见 &man.termios.4;、&man.sio.4; 以及 &man.stty.1;
	联机手册了解更多信息。</para>

      <sect3>
	<title>编译设备指定文件</title>

	<note><para>从 FreeBSD&nbsp;5.0 开始， &man.devfs.5;
	  文件系统将根据需要创建设备节点。 如果您在运行启用
	  <literal>devfs</literal> 的FreeBSD版本，
	  您就可以跳过这一节。</para></note>

	<para>一个在<filename>/dev</filename> 目录下的叫做
	  <command>MAKEDEV</command> 的 shell 脚本管理着设备指定文件。
	  要使用 <command>MAKEDEV</command> 来建立拨号设备指定文件，
	  可以使用 <devicename>COM1</devicename>： (port 0)，
	  <command>cd</command> 进入 <filename>/dev</filename>，
	  然后执行命令 <command>MAKEDEV ttyd0</command>。
	  同样地，要建立拨号设备指定文件以使用
	  <devicename>COM2</devicename>： (port 1)，
	  可以执行 <command>MAKEDEV ttyd1</command>。</para>

	<para><command>MAKEDEV</command> 不仅仅创建
	  <filename>/dev/ttyd<replaceable>N</replaceable></filename> 设备指定文件，也创建
	  <filename>/dev/cuaa<replaceable>N</replaceable></filename>，
	  <filename>/dev/cuaia<replaceable>N</replaceable></filename>，
	  <filename>/dev/cuala<replaceable>N</replaceable></filename>，
	  <filename>/dev/ttyld<replaceable>N</replaceable></filename>， 以及
	  <filename>/dev/ttyid<replaceable>N</replaceable></filename>节点。</para>

	<para>建立完新设备指定文件后， 需要检查文件的权限来确定谁可以在这些文件上读写
	  &mdash; 您可能不想让普通的用户使用您的 modem 吧。
	  在<filename>/dev/cua*</filename>文件上的默认权限应该是足够了：</para>

	<screen>crw-rw----    1 uucp     dialer    28, 129 Feb 15 14:38 /dev/cuaa1
crw-rw----    1 uucp     dialer    28, 161 Feb 15 14:38 /dev/cuaia1
crw-rw----    1 uucp     dialer    28, 193 Feb 15 14:38 /dev/cuala1</screen>

	<para>这些许可允许用户<username>uucp</username>和在组<username>dialer</username>
	  上的用户使用呼出设备。</para>
      </sect3>
    </sect2>


    <sect2 id="serial-hw-config">
      <title>串行端口配置</title>

    <indexterm><primary><devicename>ttyd</devicename></primary></indexterm>
    <indexterm><primary><devicename>cuaa</devicename></primary></indexterm>

    <para><devicename>ttyd<replaceable>N</replaceable></devicename> (或<devicename>cuaa<replaceable>N</replaceable></devicename>)
      设备是您将要打开的应用程序的一般设备。 当进程打开某个设备时，
      它将有一个终端 I/O 设置的默认配置。 您可以在命令行看看这些设置：</para>

    <screen>&prompt.root; <userinput>stty -a -f /dev/ttyd1</userinput></screen>

    <para>当您修改了这个设备的设置，这个设置会生效，除非设备被关闭。
      当它被重新打开时，它将回到默认设置。 要修改默认设置，您可以打开和调整
      <quote>初始状态</quote> 设备的设置。例如，
      要为<devicename>ttyd5</devicename> 打开
      <option>CLOCAL</option> 模式，8位通讯和默认的 <option>XON/XOFF</option> 流控制，
      输入：</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyid5 clocal cs8 ixon ixoff</userinput></screen>

    <indexterm>
      <primary>rc files</primary>
      <secondary><filename>rc.serial</filename></secondary>
    </indexterm>

    <!-- XXX; /etc/rc.serial is gone in 5.1.
      How do you set default parameters for these devices in 5.X ? -->

    <para>串行设备的系统初始化是用<filename>/etc/rc.serial</filename>文件类控制的。
      这个文件会影响串行设备的默认设置。</para>

    <para>要防止某个设置被一个应用程序所修改，需要调整 <quote>锁状态</quote>设备。
      例如，要锁定<devicename>ttyd5</devicename> 的速度为57600&nbsp;bit/s，
      键入：</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyld5 57600</userinput></screen>

    <para>现在，一个打开<devicename>ttyd5</devicename>
      和设法改变端口速度的应用程序将被固定在57600bit/s。很自然地，
      您需要确定初始状态，然后用root帐户锁定状态设备的写入功能。</para>

    <indexterm>
      <primary><command>MAKEDEV</command></primary>
    </indexterm>
    <para>很显然，您应该只让 <username>root</username>
      用户可以初始化或锁定设备的状态。</para>
    </sect2>
  </sect1>

  <sect1 id="term">
    <sect1info>
      <authorgroup>
        <author>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	  <contrib>Contributed by </contrib>
	</author>
	<!-- 28 July 1996 -->
      </authorgroup>
    </sect1info>
    <title>终端</title>

    <indexterm><primary>终端</primary></indexterm>

    <para>当您在计算机控制台或是在一个连接的网络上时，
      终端提供了一个方便和低成本的访问FreeBSD系统的方法。
      这节描述了如何在FreeBSD上使用终端。</para>

    <sect2 id="term-uses">
      <title>终端的用法和类型</title>

      <para>早期的 &unix; 系统没有控制台。
	人们通过将终端连接到计算机的串口来登录和使用程序。
	它很像用 modem 和一些终端软件来拨号进入一个远程的系统，
	只能执行文本的工作。</para>

      <para>今天的 PC 已经可以使用高质量的图形了，
	但与今天的其他&unix;操作系统一样，建立一个登录会话的能力仍然存在。
	通过使用一个终端连接到一个没有使用的串口，
	您就能登录和运行任何文本程序或在 X 视窗系统中运行一个
	<command>xterm</command> 窗口程序。</para>

      <para>对于商业用户，您可以把任何终端连接到 FreeBSD 系统，
	然后把它们放在员工的桌面上。 对于家庭用户，则可以使用一台比较老的
	IBM PC 或 Macintosh 运行一个终端连接到一台运行 FreeBSD
	的高性能机器上。</para>

      <para>对于FreeBSD，有三种终端：</para>

      <itemizedlist>
	<listitem>
	  <para><link linkend="term-dumb">哑终端</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-pcs">充当终端的PC</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-x">X 终端</link></para>
	</listitem>
      </itemizedlist>

      <para>下面一小节将描述每一种终端。</para>

      <sect3 id="term-dumb">
	<title>哑终端</title>

	<para>哑终端需要专门的好几种硬件，让您通过串行线连接到计算机。
	  它们被叫做 <quote>哑</quote> 是因为它们只能够用来显示，
	  发送和接收文本。 您不能在它上面运行任何程序。</para>

	<para>有好几百种哑终端，包括Digital Equipment Corporation
	  的VT-100和Wyse的WY-75。只有几种可以在FreeBSD上工作。
	  一些高端的终端可以显示图形，但只有某些软件包可以使用这些高级特性。</para>

	<para>哑终端被广泛用于那些不需要图形应用的工作中。</para>
      </sect3>

      <sect3 id="term-pcs">
	<title>充当终端的PC</title>

	<para>如果一个 <link linkend="term-dumb">哑终端</link>
	  有足够的能力来显示，发送和接收文本，
	  那任何个人计算机都可以作为一个哑终端。
	  您所需要的只是适当的线缆和一些终端模拟软件。</para>

	<para>这样一个配置被广泛运用于家庭。例如，如果您的妻子忙于在您的
	  FreeBSD 系统控制台上工作，您也可以从一台低档的个人计算机登录到
	  FreeBSD 系统执行一些文本的工作。</para>
      </sect3>

      <sect3 id="term-x">
	<title>X 终端</title>

	<para>X终端是最复杂的终端系统。它们通常需要使用以太网来连接。
	  它们能显示任何X应用程序。</para>

	<para>我们介绍X终端只是为了感兴趣。然而，
	  这章<emphasis>不会</emphasis>涉及X终端的安装，配置或使用。</para>
      </sect3>
    </sect2>

    <sect2 id="term-config">
      <title>配置</title>

      <para>这节描述了您在一个终端上启用一个登录会话，需要在 FreeBSD
	系统上配置些什么。假设您已经配置好了内核来支持串行端口，您就可以连接了。</para>

      <para>在 <xref linkend="boot"> 中曾经提到， <command>init</command>
	进程依赖于系统启动时所有的处理控制和初始化。
	通过 <command>init</command> 来执行的一些任务将先读取
	<filename>/etc/ttys</filename>文件，
	然后在可用的终端上启用一个 <command>getty</command> 进程。
	<command>getty</command> 进程可用来阅读一个登录名和启动
	<command>login</command>程序。</para>

      <para>然而，要为您的FreeBSD系统配置终端，您需要以
	<username>root</username> 身份执行下面的步骤：</para>

      <procedure>
	<step>
	  <para>如果它不在那儿，您需要为串行端口在
	    <filename>/dev</filename>目录下添加一行记录到
	    <filename>/etc/ttys</filename>。</para>
	</step>

	<step>
	  <para>指定 <command>/usr/libexec/getty</command> 在端口上运行，
	    然后从 <filename>/etc/gettytab</filename> 文件指定适当的
	    <replaceable>getty</replaceable> 类型。</para>
	</step>

	<step>
	  <para>指定默认的终端类型。</para>
	</step>

	<step>
	  <para>设置端口为 <quote>on</quote>。</para>
	</step>

	<step>
	  <para>确定端口是否为 <quote>secure</quote>。</para>
	</step>

	<step>
	  <para>迫使<command>init</command> 重新读取
	    <filename>/etc/ttys</filename>文件。</para>
	</step>
      </procedure>

      <para>作为可选的步骤，您可以通过在 <filename>/etc/gettytab</filename>
	中建立一个记录，在第2步创建一个定制的
	<replaceable>getty</replaceable> 类型来使用。这章不会介绍如何做。
	您可以参考 &man.gettytab.5; 和 &man.getty.8;
	的联机手册了解更多信息。</para>

      <sect3 id="term-etcttys">
	<title>添加一个记录到<filename>/etc/ttys</filename></title>

	<para><filename>/etc/ttys</filename>文件列出了您
	  FreeBSD系统上允许登录的所有端口。 例如， 第一个虚拟控制台
	  <filename>ttyv0</filename> 在这个文件中有一个记录。
	  您可以使用这个记录登录进控制台。
	  这个文件也包含其他虚拟控制台的记录，串口，和伪 ttys 终端。
	  对于一个硬连线的终端， 只要列出串行端口的
	  <filename>/dev</filename> 记录而不需要
	  <filename>/dev</filename>部分 (例如，
	  <filename>/dev/ttyv0</filename> 可以被列为
	  <devicename>ttyv0</devicename>)。</para>

	<para>默认的 FreeBSD 安装包括一个支持最初四个串口
	  <filename>ttyd0</filename> 到 <filename>ttyd3</filename>
	  的<filename>/etc/ttys</filename> 文件。
	  如果您从那些端口中某一个使用终端，您不需要添加另一个记录。</para>

	<example id="ex-etc-ttys">
	  <title>添加终端记录到<filename>/etc/ttys</filename></title>

	  <para>假设我们连接两个终端给系统： 一个 Wyse-50 和一个老的运行
	    <application>Procomm</application> 终端软件模拟一个
	    VT-100 终端的286IBM PC。 在 <filename>/etc/ttys</filename>
	    文件中的相应的记录是这样的：</para>

	  <programlisting>ttyd1<co
	      id="co-ttys-line1col1">  "/usr/libexec/getty std.38400"<co
	      id="co-ttys-line1col2">  wy50<co
	      id="co-ttys-line1col3">  on<co
	      id="co-ttys-line1col4">  insecure<co
	      id="co-ttys-line1col5">
ttyd5   "/usr/libexec/getty std.19200"  vt100  on  insecure
	  </programlisting>

	  <calloutlist>
	    <callout arearefs="co-ttys-line1col1">
	      <para>第一部分指定了终端指定文件的名称， 它可以在
	      <filename>/dev</filename>中找到。</para>
	    </callout>
	    <callout arearefs="co-ttys-line1col2">

	      <para>第二部分是在这行执行的命令，通常是 &man.getty.8;。
	        <command>getty</command> 初始化然后打开一行，设置速度，
	        用户名的命令和执行登录程序。</para>

	      <para><command>getty</command> 程序在它的命令行接收一个参数 (可选)，
	        <replaceable>getty</replaceable> 类型。 一个
	        <replaceable>getty</replaceable> 类型会在终端行描述一个特征，
	        像波特率和奇偶校验。 <command>getty</command> 程序从
	        <filename>/etc/gettytab</filename> 文件读取这些特征。</para>

	      <para>文件<filename>/etc/gettytab</filename>
	        包含了许多老的和新的终端行记录。
	        在很多例子中，启动文本 <literal>std</literal>
	        的记录将用硬连线终端来工作。 这些记录忽略了奇偶性。
	        这是一个从110到115200 bit/s的 <literal>std</literal> 记录。
	        当然，您可以添加您自己的记录到这个文件。
	        gettytab 的联机手册提供了更多的信息。</para>

	      <para>当在<filename>/etc/ttys</filename>中设置
	        <replaceable>getty</replaceable> 类型的时候，
	        确信在终端上的通讯设置匹配。
	        在我们的例子中， Wyse-50 不使用奇偶性， 用38400 bit/s
	        来连接。286 PC不使用奇偶性，用19200bit/s来连接。</para>

	    </callout>

	    <callout arearefs="co-ttys-line1col3">

	      <para>第三部分是通常连接到那个tty行的终端类型。对于拨号端口，
	        <literal>unknown</literal> 或 <literal>dialup</literal>
	        通常被用在这个地方。 对于硬连线的终端，终端类型不会改变，
	        所以您可以从termcap数据库文件中放一个真正的终端类型。</para>

	      <para>在我们的例子中， Wyse-50 使用真正的终端类型，
	        而运行 <application>Procomm</application> 的286
	        PC将被设置成在VT-100上的模拟。</para>

	    </callout>

	    <callout arearefs="co-ttys-line1col4">
	      <para>如果端口被启用，可以指定第四个部分。在第二部分，
	        把它放在这儿将执行初始化进程来启动程序
	        <command>getty</command>。如果您在这部分拖延，
	        将没有<command>getty</command>，在端口上因此就没有登录。</para>
	    </callout>

	    <callout arearefs="co-ttys-line1col5">
	      <para>最后部分被用来指定端口是否安全。
	        标记一个安全的端口意味着您信任它允许用 <username>root</username>
	        帐户从那个端口登录。 不安全的端口不允许
	        <username>root</username>登录。 在一个不安全的端口上，
	        用户必须用无特权的帐户登录， 然后使用
	        <command>su</command> 或一个相似的机制来获得超级用户的权限。</para>
	    </callout>
	  </calloutlist>
	</example>
      </sect3>

      <sect3 id="term-hup">
	<title>重新读取<filename>/etc/ttys</filename>来强制<command>init</command>
	  </title>

	<para>对<filename>/etc/ttys</filename>文件做一个必要的修改后，您必须发送一个
	  SIGHUP 信号给初始化进程来迫使它重新读取配置文件，例如：</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<note>
	  <para><command>init</command> 总是系统运行时的第一个进程，因此它总是PID 1。</para>
	</note>

	<para>如果能够正确设置，所有的线缆都是适当的，终端将可以启用了，
	  然后一个 <command>getty</command> 进程将在每个终端运行，
	  您将在您的终端上看到登录命令行。</para>
      </sect3>
    </sect2>

    <sect2 id="term-debug">
      <title>您的连接可能出现的问题</title>

      <para>即使您小心翼翼地注意细节，您仍然可能会在设置终端时出错。
	  这有一个有关问题和解决办法的列表：</para>

      <sect3>
	<title>没有登录命令出现：</title>

	<para>确定终端被嵌入和打开了。如果把一台个人计算机充当一个终端，
	  确信终端模拟软件运行在正确的串口上。</para>

	<para>确信线缆被稳固地连接在终端和 FreeBSD 计算机上。
	  确信用了正确的电缆。</para>

	<para>确定终端和 FreeBSD 的传输速度和奇偶设置已经一致了。
	  如果您有一个图像显示终端，确信对比度已经调节好了。
	  如果它是一个可打印的终端，确信纸张和墨水已经就绪了。</para>

	<para>确定一个 <command>getty</command> 进程正在运行和服务终端。
	  例如， 可以用<command>ps</command> 命令得到运行
	  <command>getty</command> 程序的列表，键入：</para>

        <screen>&prompt.root; <userinput>ps -axww|grep getty</userinput></screen>

	<para>您将看到一个终端的记录。例如，下面的显示表明一个<command>getty</command>
	  正在第二个串行端口 <literal>ttyd1</literal> 运行，
	  正在<filename>/etc/gettytab</filename>中使用 <literal>std.38400</literal>
	  的记录：</para>

	<screen>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1</screen>

	<para>如果没有 <command>getty</command> 进程运行，
	  确信您已经在<filename>/etc/ttys</filename>中启用了端口。
	  在修改完<filename>/etc/ttys</filename>文件后，记得运行
	  <command>kill -HUP 1</command>。</para>

	<para>如果 <command>getty</command> 进程确实在运行，
	  但终端上仍然没有显示出登录提示， 或者虽然显示了单缺不允许您输入，
	  您的终端或电缆可能不支持硬件握手。 请尝试将
	  <filename>/etc/ttys</filename> 中的
	  <literal>std.38400</literal> 改为
	  <literal>3wire.38400</literal> 并一定能够记得在改完
	  <filename>/etc/ttys</filename> 之后
	  <command>kill -HUP 1</command>)。
	  <literal>3wire</literal> 记录和
	  <literal>std</literal> 类似， 但忽略硬件握手。
	  您可能需要在使用 <literal>3wire</literal>
	  时减少波特率或启用软件流控制以避免缓冲区溢出。</para>

      </sect3>

      <sect3>
	<title>出现一个 <quote>垃圾</quote> 而不是一个登录命令行</title>

	<para>确信终端和 FreeBSD 使用相同的 bit/s 传输率和奇偶校验设置。
	  检查一下 <command>getty</command> 进程确信当前使用正确的
	  <replaceable>getty</replaceable> 类型。 如果没有，
	  编辑<filename>/etc/ttys</filename>然后运行<command>kill
	  -HUP 1</command>。</para>

      </sect3>

      <sect3>
	<title>当键入密码时，字符两个两个出现</title>

	<para>将终端 (或终端模拟软件) 从 <quote>半双工</quote>
	  或 <quote>本地回显</quote> 换成
	  <quote>全双工</quote>。</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 id="dialup">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Guy</firstname>
	  <surname>Helmer</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
        <author>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	  <contrib>Additions by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>拨入服务</title>
    <indexterm><primary>拨入服务</primary></indexterm>

    <para>为拨入服务配置FreeBSD系统与连接到终端是非常相似的，除非您正在使用
      modem来拨号而不是终端。</para>

      <sect2>
	<title>外置vs.内置modem</title>

	<para>外置modem看起来很容易拨号。 因为，外置 modem
	  可以通过储存在非易失性的RAM中的参数来配置，
	  它们通常提供指示器来显示重要的RS-232信号的状态。
	  不停闪光的信号灯能给用户留下比较深刻的印象，
	  而且指示器也可以用来查看modem是否正常地工作。</para>

	<para>内置modem通常缺乏非易失性的RAM，
	  所以对它们的配置可能会限制在通过 DIP 开关来设置。
	  如果您的内置modem有指示灯，您也很难看得到。</para>

      <sect3>
	<title>Modem和线缆</title>
	<indexterm><primary>modem</primary></indexterm>

	<para>如果您使用一个外置的 modem，那您将需要适当的电缆线。
	  一个标准的串行线应当足够长以至普通的信号能够连接上：</para>

	<itemizedlist>
	  <listitem>
	    <para>Transmitted Data (<acronym>TD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Received Data (<acronym>RD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Request to Send (<acronym>RTS</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Clear to Send (<acronym>CTS</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Data Set Ready (<acronym>DSR</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Data Terminal Ready (<acronym>DTR</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Carrier Detect (<acronym>CD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Signal Ground (<acronym>SG</acronym>)</para>
	  </listitem>
	</itemizedlist>

	<para>FreeBSD需要对速度超过2400bit/s的<acronym>RTS</acronym> 和
	  <acronym>CTS</acronym>信号进行流控制，
	  当一个呼叫被回复或线路被挂起的时候， <acronym>CD</acronym>
	  信号就会被侦测到，一个会话完成之后，<acronym>DTR</acronym>
	  信号就会刷新modem。 一些线缆不需要任何信号就可以连接，
	  所以如果您有问题， 当线路被挂断时， 一个登录任务就会丢失，
	  您可能会在线缆上有问题。</para>

	<para>像其他 &unix; 类的操作系统一样， FreeBSD
	  使用硬件信号来寻找出一个呼叫什么时候会回复或一个线路会被挂起。
	  FreeBSD 避免发送命令给 modem 或监视 modem 的状况。
	  如果您熟悉连接 modem 到基于 PC 的 BBS，这可能看起来有点笨拙。</para>
      </sect3>
      </sect2>

      <sect2>
	<title>串行接口的考虑</title>

	<para>FreeBSD支持基于 NS8250， NS16450， NS16550 和 NS16550A
	  的EIA RS-232C通讯接口。 8250和16450设备有单字符缓冲。
	  16550设备提供了一个 16 个字符的缓冲， 可以提高更多的系统性能。
	  因为单字符缓冲设备比 16 个字符的缓冲需要更多的系统资源来工作，
	  所以基于16550A的接口卡可能更好。 如果系统没有活动的串口，
	  或有较大的负载， 16 字符缓冲的卡对于低错误率的通讯来说更好。</para>
      </sect2>

    <sect2>
      <title>快速预览</title>

      <indexterm><primary>getty</primary></indexterm>
      <para>对于终端， <command>init</command>
	会在每个配置串口上为每个拨入连接产生一个 <command>getty</command>
	进程。 例如， 如果一个 modem 被附带在 <filename>/dev/ttyd0</filename>
	中，用命令<command>ps ax</command>可以显示下面这些：</para>

      <screen> 4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0</screen>

      <para>当用户拨上modem， 并使用它进行连接时， <acronym>CD</acronym>
	线就会被 modem 认出。 内核注意到载波信号已经被检测到，
	需要完成 <command>getty</command> 端口的打开。
	<command>getty</command> 发送一个登录：在指定的初始线速度上的命令行。
	Getty 会检查合法的字符是否被接收， 在典型的配置中，
	如果发现 <quote>垃圾</quote>， <command>getty</command>
	就会设法调节线速度，直到它接收到合理的字符。</para>

      <indexterm>
        <primary><command>/usr/bin/login</command></primary>
      </indexterm>
      <para>用户在键入他/她的登录名称后，
	<command>getty</command>执行<filename>/usr/bin/login</filename>，
	这会要求用户输入密码来完成登录， 然后启动用户的shell。</para>
    </sect2>


    <sect2>
      <title>配置文件</title>

      <para>在 <filename>/etc</filename> 目录中，有三个您将需要编辑的系统配置文件，
	来允许拨号访问到您的 FreeBSD 系统。 第一，
	<filename>/etc/gettytab</filename> 包含了针对
	<filename>/usr/libexec/getty</filename> 守护程序的配置信息。
	第二， 保存信息来告诉 <filename>/sbin/init</filename>
	什么 <filename>tty</filename> 设备将有运行在它们系统上的
	<command>getty</command>进程。 最后，
	您可以把端口初始化命令放在 <filename>/etc/rc.serial</filename>
	脚本中。</para>

      <para>在 &unix; 上， 关于拨号 modem 的想法主要有两种。
	一种是把本地接口配置成一个固定速度，
	以至一个远程用户拨号进入时都保持一个固定速度。
	这样配置的好处是远程用户总是可以立即看到一个系统的登录界面。
	这种下降趋势是系统不知道一个用户真正的数据速度是多少，
	所以像 Emacs 全屏程序将不会调节屏幕刷新来确保对比较慢的连接有比较好的回应。</para>

      <para>另一所学校将他们的 modem 所在的 RS-232 设置为自动适应远程用户的连接速度。
	例如， V.32bis (14.4&nbsp;Kbps) 的连接将让 modem 所在的 RS-232 接口运行在
	19.2&nbsp;Kbps， 而 2400&nbsp;bps 的连接则会使 modem 的 RS-232 以
	2400&nbsp;bps 运行。 由于
	<command>getty</command> 并不知道任何一个特定的 modem 的连接速率，
	因此 <command>getty</command> 会以初始的速率给出一个
	<prompt>login:</prompt> 消息并监视用户回应的字符。
	如果用户看到一些乱码， 则他们应该知道连续按
	<keycode>Enter</keycode> 键直到能够看到可以识别的提示为止。
	如果数据传输速率不匹配， <command>getty</command>
	将把用户输入的任何信息看作 <quote>乱码</quote>，
	并尝试下一个速度并再次给出 <prompt>login:</prompt> 提示。
	这个过程可以令人作呕地继续下去，
	但用户通常只需按一两次键盘就可以看到正常的提示了。
	很明显， 这个登录过程看起来可能没有前面所介绍的
	<quote>锁定速率</quote> 方法那样脉络清晰，
	但在低速连接上的用户应该能够从全屏幕程序中得到更好的交互响应。</para>

      <para>这一节将尽量给出较为公平的配置信息， 但更偏向于使用遵守连接速率的
	modem。</para>

      <sect3>
	<title><filename>/etc/gettytab</filename></title>

  <indexterm>
    <primary><filename>/etc/gettytab</filename></primary>
  </indexterm>
	<para><filename>/etc/gettytab</filename>是一个用来配置
	  <command>getty</command> 信息的 termcap 风格的文件。 请看看
	  gettytab 的联机手册了解完整的文件格式和功能列表。</para>

	<sect4>
	  <title>锁定速度的配置</title>

	  <para>如果您把您的modem的数据通讯率锁定在一个特殊的速度上，
	    您不需要对 <filename>/etc/gettytab</filename> 文件作任何变化。</para>
	</sect4>

	<sect4>
	  <title>匹配速度的配置</title>

	  <para>您将需要在 <filename>/etc/gettytab</filename>
	    中设置一个记录来告诉 <command>getty</command> 您希望在
	    modem 上使用的速度。 如果您的 modem 的速率是 2400&nbsp;bit/s，
	    则可以使用现有的 <literal>D2400</literal> 的记录。</para>

	  <programlisting>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</programlisting>

	  <para>如果您有一个更高速度的 modem， 必须在
	    <filename>/etc/gettytab</filename> 中添加一个记录。
	    下面是一个让您可以以最高 19.2 Kbit/s 的用在
	    14.4 Kbit/s的modem上的接口记录：</para>

	  <programlisting>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

	  <para>这样做的结果是 8-数据位， 没有奇偶校验的连接。</para>

	  <para>上面使用19.2 Kbit/s的连接速度的例子，也可以使用
	    9600 bit/s (for V.32)， 2400 bit/s， 1200 bit/s，300 bit/s，
	    直到 19.2 Kbit/s。 通讯率的调节使用 <literal>nx=</literal>
	    (<quote>next table</quote>) 来实现。 每条线使用一个
	    <literal>tc=</literal> (<quote>table continuation</quote>)
	    的记录来加速对于一个特殊传输率的标准设置。</para>

	  <para>如果您有28.8 Kbit/s的modem，或您想使用它的 14.4Kbit/s
	    模式， 就需要使用一个更高的超过 19.2 Kbit/s 的通讯速度的
	    modem。 这是一个启动 57.6 Kbit/s 的 <filename>gettytab</filename>
	    记录的例子：</para>

	  <programlisting>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

	  <para>如果您的 CPU 速度较低， 或系统的负荷很重， 而且没有
	    16550A的串行端口，您可能会在57.6 Kbit/s上得到
	    <errorname>sio</errorname> <quote>silo</quote>错误。</para>
	</sect4>
      </sect3>

      <sect3 id="dialup-ttys">
	<title><filename>/etc/ttys</filename></title>
	<indexterm>
	  <primary><filename>/etc/ttys</filename></primary>
	</indexterm>

	<para><filename>/etc/ttys</filename>文件的配置在
	  <xref linkend="ex-etc-ttys">中介绍过。 配置 modem 是相似的，
	  但我们必须指定一个不同的终端类型。
	  锁定速度和匹配速度配置的通用格式是：</para>

	<programlisting>ttyd0   "/usr/libexec/getty <replaceable>xxx</replaceable>"   dialup on</programlisting>

	<para>上面的第一条是这个记录的设备特定文件 &mdash;
	  <literal>ttyd0</literal> 表示 <filename>/dev/ttyd0</filename>
	  是这个 <command>getty</command> 将被监视的文件。 第二条
	  <literal>"/usr/libexec/getty
	    <replaceable>xxx</replaceable>"</literal>
	  是将运行在设备上的进程 <command>init</command>。
	  第三条，dialup，是默认的终端类型。 第四个参数，
	  <literal>on</literal>， 指出了线路是可操作的
	  <command>init</command>。 也可能会有第五个参数，
	  <literal>secure</literal>， 但它将只被用作拥有物理安全的终端
	  (如系统终端)。</para>

	<para>默认的终端类型可能依赖于本地参考。 拨号是传统的默认终端类型，
	  以至用户可以定制它们的登录脚本来注意终端什么时候拨号，
	  和自动调节它们的终端类型。 然而， 作者发现它很容易在它的站点上指定
	  <literal>vt102</literal> 作为默认的终端类型，
	  因为用户刚才在它们的远程系统上使用的是VT102模拟器。</para>

	<para>您对<filename>/etc/ttys</filename>作修改之后，您可以发送
	  <command>init</command> 进程给一个 <acronym>HUP</acronym>
	  信号来重读文件。您可以使用下面的命令来发送信号：

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	  如果这是您的第一次设置系统， 您可能要在发信号
	  <command>init</command> 之前等一下， 等到您的 modem
	  正确地配置并连接好。
	  </para>

	<sect4>
	  <title>锁定速度的配置</title>

	  <para>对于一个锁定速度的配置，您的 <filename>ttys</filename>
	    记录必须有一个为 <command>getty</command> 提供固定速度的记录。
	    对于一个速度被锁定在 19.2kbit/s 的 modem，
	    <filename>ttys</filename> 记录是这样的：</para>

	  <programlisting>ttyd0   "/usr/libexec/getty std.19200"   dialup on</programlisting>

	  <para>如果您的 modem 被锁定在一个不同的数据速度，
	    为 std.speed 使用适当的速度来代替 std.19200。
	    确信您使用了一个在 <filename>/etc/gettytab</filename>
	    中列出的正确的类型。</para>
	</sect4>

	<sect4>
	  <title>匹配速度的设置</title>

	  <para>在一个匹配速度的设置中，您的 <filename>ttys</filename>
	    录需要参考在 <filename>/etc/gettytab</filename> 适当的起始
	    <quote>auto-baud</quote> 记录。 例如， 如果您为一个以 19.2
	    Kbit/s 开始的可匹配速度的 modem 添加上面建议的记录， 您的
	    <filename>ttys</filename> 记录可能是这样的：</para>

	  <programlisting>ttyd0   "/usr/libexec/getty V19200"   dialup on</programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title><filename>/etc/rc.serial</filename></title>
	<indexterm>
	  <primary>rc files</primary>
	  <secondary><filename>rc.serial</filename></secondary>
	</indexterm>

	<para>高速modem， 像 V.32，V.32bis，和 V.34 modem，需要使用硬件
	  (<filename>RTS/CTS</filename>) 流控制。 您可以在
	  <filename>/etc/rc.serial</filename> 中添加
	  <command>stty</command> 命令来设置硬件流控制标记。</para>

	<para>例如，在拨入和拨出初始设备的第一个 (<devicename>COM2</devicename>)
	  串行端口上设置termios标记crtscts， 下面这些行会被添加到
	  <filename>/etc/rc.serial</filename>中：</para>
	<programlisting># Serial port initial configuration
stty -f /dev/ttyid1 crtscts
stty -f /dev/cuaia1 crtscts</programlisting>
	    	    
      </sect3>
    </sect2>

    <sect2>
      <title>Modem设置</title>

      <para>如果您有一个 modem， 它的参数能被存储在非易失性的 RAM 中，
	您将必须使用一个终端程序来设置参数。 使用同样的通讯速度来连接
	modem 作为初始速度 <command>getty</command> 将使用和配置
	modem 的非易失性RAM来匹配这些要求：</para>

      <itemizedlist>
	<listitem>
	  <para><acronym>CD</acronym> asserted when connected</para>
	</listitem>

	<listitem>
	  <para><acronym>DTR</acronym> asserted for operation; dropping DTR
	    hangs up line and resets modem</para>
	</listitem>

	<listitem>
	  <para><acronym>CTS</acronym> transmitted data flow control</para>
	</listitem>

	<listitem>
	  <para>Disable <acronym>XON/XOFF</acronym> flow control</para>
	</listitem>

	<listitem>
	  <para><acronym>RTS</acronym> received data flow control</para>
	</listitem>

	<listitem>
	  <para>Quiet mode (no result codes)</para>
	</listitem>

	<listitem>
	  <para>No command echo</para>
	</listitem>
      </itemizedlist>

      <para>请读读您的 modem 的文档找到您需要用什么命令和 DIP 接口设置。</para>

      <para>例如，要在一个 USRobotics Sportster 14400 的外置 modem
	上设置上面的参数，可以用下面这些命令：</para>

      <programlisting>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>您也可能想要在 modem 上寻找机会调节这个设置， 例如它是否使用
	V.42bis 和 MNP5 压缩。</para>

      <para>外置 modem 也有一些用来设置的 DIP 开关，
	也许您可以使用这些设置作为一个例子：</para>

      <itemizedlist>
	<listitem>
	  <para>Switch 1: UP &mdash; DTR Normal</para>
	</listitem>

	<listitem>
	  <para>Switch 2: N/A (Verbal Result Codes/Numeric Result
	    Codes)</para>
	</listitem>

	<listitem>
	  <para>Switch 3: UP &mdash; Suppress Result Codes</para>
	</listitem>

	<listitem>
	  <para>Switch 4: DOWN &mdash; No echo, offline commands</para>
	</listitem>

	<listitem>
	  <para>Switch 5: UP &mdash; Auto Answer</para>
	</listitem>

	<listitem>
	  <para>Switch 6: UP &mdash; Carrier Detect Normal</para>
	</listitem>

	<listitem>
	  <para>Switch 7: UP &mdash; Load NVRAM Defaults</para>
	</listitem>

	<listitem>
	  <para>Switch 8: N/A (Smart Mode/Dumb Mode)</para>
	</listitem>
      </itemizedlist>

      <para>在拨号 modem 上的结果代码应该被 禁用/抑制， 以避免当
	<command>getty</command> 在 modem 处于命令模式并回显输入时错误地给出
	<prompt>login:</prompt> 提示时可能造成的问题。
	这样可能导致 <command>getty</command> 与 modem
	之间产生更长的不必要交互。</para>

      <sect3>
	<title>锁定速度的配置</title>

	<para>对于锁定速度的配置， 您需要配置 modem
	  来获得一个不依赖于通讯率的稳定的 modem到计算机 的传输率。
	  在一个 USR Sportster 14400 外置 modem 上， 这些命令将锁定
	  modem到计算机 的传输率：</para>

	<programlisting>ATZ
AT&amp;B1&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>匹配速度的配置</title>

	<para>对于一个变速的配置， 您需要配置 modem
	  调节它的串行端口传输率匹配接收的传输率。
	  在一个 USR Sportster 14400 的外置 modem 上， 这些命令将锁定
	  modem 的错误修正传输率适合命令要求的速度，
	  但允许串行端口速度适应没有纠错的连接：</para>

	<programlisting>ATZ
AT&amp;B2&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>检查modem的配置</title>

	<para>大多数高速的modem提供了用来查看当前操作参数的命令。
	  在USR Sportster 14400外置modem上， 命令 <command>ATI5</command>
	  显示了存储在非易失性RAM中的设置。 要看看正确的 modem 操作参数，
	  可以使用命令 <command>ATZ</command> 然后是
	  <command>ATI4</command>。</para>

	<para>如果您有一个不同牌子的 modem， 检查 modem
	  的使用手册看看如何双重检查您的 modem 的配置参数。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>问题解答</title>

      <para>这儿是几个检查拨号modem的步骤。</para>

      <sect3>
	<title>检查FreeBSD系统</title>

	<para>把您的modem连接到FreeBSD系统， 启动系统， 然后， 如果您的
	  modem 有一个指示灯， 当登录时看看 modem 的 DTR 指示灯是否亮：
	  会在系统控制台出现命令行――如果它亮， 意味着 FreeBSD
	  已经在适当的通讯端口启动了一个 <command>getty</command> 进程，
	  等待 modem 接收一个呼叫。</para>

	<para>如果<acronym>DTR</acronym>指示灯不亮， 通过控制台登录到
	  FreeBSD系统，然后执行一个 <command>ps ax</command>
	  命令来看 FreeBSD 是否正在正确的端口运行
	  <command>getty</command>进程。
	  您将在进程显示中看到像这样的一行：</para>

	<screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1</screen>

	<para>如果您看到是这样的：</para>

	  <screen>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0</screen>

	<para>modem 不接收呼叫， 这意味着 <command>getty</command>
	  已经在通讯端口打开了。 这可以指出线缆有问题或 modem 错误配置，
	  因为 <command>getty</command> 无法打开通讯端口。</para>

	<para>如果您没有看到任何 <command>getty</command> 进程等待打开想要的
	  <devicename>ttyd<replaceable>N</replaceable></devicename> 端口，
	  在 <filename>/etc/ttys</filename> 中双击您的记录看看那儿是否有错误。
	  另外，检查日志文件 <filename>/var/log/messages</filename>
	  看看是否有一些来自 <command>init</command> 或
	  <command>getty</command> 的问题日志。 如果有任何信息，
	  仔细检查配置文件 <filename>/etc/ttys</filename> 和
	  <filename>/etc/gettytab</filename>，还有相应的设备文件
	  <devicename>/dev/ttyd<replaceable>N</replaceable></devicename>，
	  是否有错误，丢失记录，或丢失了设备指定文件。</para>
      </sect3>

      <sect3>
	<title>尝试接入Try Dialing In</title>

	<para>设法拨入系统。 确信使用8位， 没有奇偶检验， 在远程系统上的1阻止位。
	  如果您不能立刻得到一个命令行， 试试每隔一秒按一下
	  <keycode>Enter</keycode>。 如果您仍没有看到一个登录： 设法发送一个
	  <command>BREAK</command>。 如果您正使用一个高速的 modem 来拨号，
	  请在锁定拨号 modem 的接口速度后再试试。</para>

	<para>如果您不能得到一个登录：prompt，再检查一下
	  <filename>/etc/gettytab</filename>，重复检查：</para>

	<itemizedlist>
	  <listitem>
	    <para>在<filename>/etc/ttys</filename> 中指定的初始可用的名称与
	      <filename>/etc/gettytab</filename> 的一个可用的相匹配。</para>
		</listitem>

	  <listitem>
	    <para>每个 <literal>nx=</literal> 记录与另一个
	      <filename>gettytab</filename> 可用名称匹配。</para>
	  </listitem>

	  <listitem>
	    <para>每个 <literal>tc=</literal> 记录与另一个
	      <filename>gettytab</filename>可用名称相匹配。</para>
	  </listitem>
	</itemizedlist>

	<para>如果您拨号但 FreeBSD 系统上的 modem 没有回应， 确信 modem
	  能回应电话。 如果 modem 看起来配置正确了， 通过检查 modem
	  的指示灯来确认 <acronym>DTR</acronym> 线连接正确。</para>

	<para>如果您做了好几次，它仍然无法工作，打断一会，等会再试试。
	  如果还不能工作， 也许您应该发一封电子邮件给 &a.questions;
	  寻求帮助。</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="dialout">
    <title>拨出设备</title>
    <indexterm><primary>dial-out service</primary></indexterm>

    <para>下面将让您的主机通过 modem 连接到另一台计算机上。
      这只要适当地建立一个终端作为远程主机就可以。</para>

    <para>这可以用来登录进一个BBS。</para>

    <para>如果您用 PPP 有问题， 那这种连接可以用来从 Internet
      上下载一个文件。 如果您必须 FTP 一些东西， 而 PPP 断了，
      使用终端会话来 FTP 它们。 然后使用 zmodem 来把它们传输到您的机器上。</para>

    <sect2>
      <title>我的Stock Hayes Modem不被支持，我该怎么办?</title>

      <para>事实上， 联机手册对于这个的描述已经过时了。 一个通用的
	Hayes拨号已经内建其中。 只要在您的 <filename>/etc/remote</filename>
	文件中使用 <literal>at=hayes</literal>。</para>

      <para>Hayes 驱动不够 <quote>聪明</quote> 只能认出一些比较新的 modem
	的高级特性 &mdash; 如 <literal>BUSY</literal>、
	<literal>NO DIALTONE</literal>， 或 <literal>CONNECT 115200</literal>
	的信息将被搞乱。 当您使用的时候， 您必须把这些信息关掉。(通过
	<command>ATX0&amp;W</command>)。</para>

      <para>另外，拨号的延迟是 60 秒。 您的 modem
	可能使用另外的时间或提示认为有其他的通讯问题。
	试试 <command>ATS7=45&amp;W</command>。</para>

      <note>
	<para>注意： 实际上 <command>tip</command> 不支持所有的
	  Hayes modems。 解决方法是编辑
	  <filename>/usr/src/usr.bin/tip/tip</filename>
	  目录中的 <filename>tipconf.h</filename> 文件。很明显，
	  您需要它的源代码才能这样做。</para>

	<para>把行<literal>#define HAYES 0</literal> 改为
	  <literal>#define HAYES 1</literal>。 然后
	  <command>make</command> 并
	  <command>make install</command>就可以了。</para>
      </note>
    </sect2>

    <sect2 id="direct-at">
      <title>我如何输入这些 AT 命令?</title>

      <indexterm>
        <primary><filename>/etc/remote</filename></primary>
      </indexterm>
      <para>在 <filename>/etc/remote</filename> 文件中编译一个叫做
	<quote>direct</quote> 的记录。 例如， 如果您的 modem
	连接在第一个串行端口， <filename>/dev/cuaa0</filename>，
	就添加下面这行：</para>

      <programlisting>cuaa0:dv=/dev/cuaa0:br#19200:pa=none</programlisting>

      <para>使用 br 命令来启用您 modem 支持的最高传输速度。
	然后键入 <command>tip</command> cuaa0，
	您就可以连到您的 modem 上了。</para>

      <para>如果在您的系统上没有 <filename>/dev/cuaa0</filename>，可以这样：</para>

      <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV cuaa0</userinput></screen>

      <para>或以 <username>root</username> 使用 <command>cu</command>，
	执行下面的命令：</para>

      <screen>&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>

      <para><replaceable>line</replaceable> line是串行端口 (例如
	<filename>/dev/cuaa0</filename>)， speed 是速度 (如57600)。
	键入 <keycap>~.</keycap> 退出。</para>
    </sect2>

    <sect2>
      <title>现在pn <literal>@</literal>标记不能工作？</title>

      <para>在电话号码中的 <literal>@</literal> 标记告诉计算机在
	<filename>/etc/phones</filename> 文件中查找一个电话号码。 但
	<literal>@</literal> 标记也是一个在像 <filename>/etc/remote</filename>
	这样的可用文件中的特殊字符。 用一个反斜线符号退出：</para>

      <programlisting>pn=\@</programlisting>
    </sect2>

    <sect2>
      <title>我如何在命令行拨电话号码?</title>

      <para>在您的 <filename>/etc/remote</filename> 文件中通常放着一个叫做
	<quote>generic</quote> 的记录。 例如：</para>

      <programlisting>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>然后，您可以这样：</para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>如果您更喜欢<command>cu</command>而不是<command>tip</command>，使用一个通用的<literal>cu</literal>记录：</para>

      <programlisting>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>然后键入：</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>
    </sect2>

    <sect2>
      <title>这么做时是否每次都需要重新输入 bps 速率?</title>

      <para>添加一项 <literal>tip1200</literal> 或
	<literal>cu1200</literal>， 并将 bps 速率换成更合适的值。
	<command>tip</command> 的默认值是1200 &nbsp;bps， 也就是为什么会有 
	<literal>tip1200</literal> 这条记录的原因。
	虽然您并不需要使用 1200&nbsp;bps。</para>
    </sect2>

    <sect2>
      <title>我通过一个终端服务器访问了很多主机。</title>

      <para>除非每次都要等到您连接到主机然后键入
	<command>CONNECT &lt;host&gt;</command>， 否则使用
	<command>tip</command> 的 <literal>cm</literal> 功能。
	例如， 在 <filename>/etc/remote</filename> 中的这些记录：</para>

      <programlisting>pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>
	  
      <para>将让您键入 <command>tip pain</command> 或 <command>tip
	  muffin</command> 连接到主机pain或muffin， 和 <command>tip
	  deep13</command> 连接到终端服务器。</para>
    </sect2>

    <sect2>
      <title><command>tip</command>能为每个站点试用多个线路吗？</title>

      <para>经常有一个问题， 一个大学有几个modem线路， 几千个学生设法使用它们。</para>

      <para>在 <filename>/etc/remote</filename> 中为您的大学添加一个记录，
	然后为 <literal>pn</literal> 功能使用 <literal>@</literal> 标记：</para>

      <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</programlisting>
	  
      <para>接着， 在 <filename>/etc/phones</filename>
	中列出大学的电话号码：</para>

      <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>
	  
      <para><command>tip</command> 将按顺序试用每一个，然后就停止。
	如果想继续测试， 隔一段时间再运行 <command>tip</command>。</para>
    </sect2>

    <sect2>
      <title>为什么我必须键入
        <keycombo action="simul">
          <keycap>Ctrl</keycap>  
          <keycap>P</keycap>
        </keycombo>
        两次才能发出
        <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>P</keycap>
        </keycombo>
        一次?</title>

      <para><keycombo action="simul"><keycap>Ctrl</keycap><keycap>P</keycap></keycombo>是默认的<quote>强制</quote>字符，被用来告诉<command>tip</command>下一个字符是文字的数据。您可以用<command>~s</command>给任何其他的字符设置强制字符，这意思是<quote>设置一个变量</quote>。</para>

      <para>在新的一行键入 <command>~sforce=<replaceable>single-char</replaceable></command>。
	<replaceable>single-char</replaceable> 是任何简单的字符。 如果您遗漏了
	<replaceable>single-char</replaceable>， 那强制字符就是空字符，
	这可以键入
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	或
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>Space</keycap>
	</keycombo>来完成。 更好的 <replaceable>single-char</replaceable>
	是
	<keycombo action="simul">
	  <keycap>Shift</keycap>
	  <keycap>Ctrl</keycap>
	  <keycap>6</keycap>
	</keycombo>， 这只用在一些终端服务器上。</para>

      <para>通过在您的 <filename>&#36;HOME/.tiprc</filename>
	文件中指定下面这行， 就可以得到您想要的任何强制字符：</para>

      <programlisting>force=&lt;single-char&gt;</programlisting>
    </sect2>

    <sect2>
      <title>突然我键入的每一样东西都变成了大写??</title>

      <para>您一定是键入了
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo>， 即 <command>tip</command>
	的 <quote>raise character</quote>，
	会临时地指定成坏掉的 caps-lock键。 使用上面的
	<command>~s</command> 来合理地设置各种
	<literal>raisechar</literal>。 事实上，
	如果您不想使用这些特性的话，您可以用同样的方法设置强制字符。</para>

      <para>这儿有一个很好的示例 .tiprc 文件， 对
        <application>Emacs</application>用户来说，需要经常按
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	和
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>A</keycap>
	</keycombo>：</para>

      <programlisting>force=^^
raisechar=^^</programlisting>

      <para>The ^^ is 
	<keycombo action="simul">
	  <keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>6</keycap>
	</keycombo>.</para>

    </sect2>

    <sect2>
      <title>如何用 <command>tip</command> 做文件传输？</title>

      <para>如果您正在与另一台 &unix; 系统对话， 您可以用
	<command>~p</command>(put) 和 <command>~t</command> (take)
	发送和接收文件。 这些命令可以在远程系统上运行 <command>cat</command>
	和 <command>echo</command> 来接收和发送文件。 语法是这样的：</para>

      <cmdsynopsis>
	<command>~p</command>
	<arg choice="plain">local-file</arg>
	<arg choice="opt">remote-file</arg>
      </cmdsynopsis>
      
      <cmdsynopsis>
	<command>~t</command>
	<arg choice="plain">remote-file</arg>
	<arg choice="opt">local-file</arg>
      </cmdsynopsis>
      
      <para>由于没有错误校验， 所以您需要使用其他协议， 如 zmodem。</para>
    </sect2>

    <sect2>
      <title>我如何用<command>tip</command>运行zmodem？</title>

      <para>要接收这些文件，可以在远程终端启动发送程序。然后，键入
	<command>~C rz</command> 在本地开始接收它们。 要发送文件，
	可以在远程终端启动接收程序。 然后， 键入 <command>~C sz
	<replaceable>files</replaceable></command>
	把它们发送到远程系统。</para>
    </sect2>
  </sect1>

  <sect1 id="serialconsole-setup">
    <sect1info>
      <authorgroup>
        <author>
	  <firstname>Kazutaka</firstname>
	  <surname>YOKOTA</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Paul</surname>
	  <contrib>Based on a document by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>设置串行控制台</title>
    <indexterm><primary>serial console</primary></indexterm>

    <sect2 id="serialconsole-intro">
      <title>Introduction</title>

      <para>FreeBSD可以通过一个串口只使用一个哑 (dumb) 终端就可以启动一个系统。
	这样一种配置只有两种人能使用： 希望在机器上安装 FreeBSD 的系统管理员，
	他没有键盘或显示器， 还有就是要调试内核或设备驱动程序的开发人员。</para>

      <para>就象 <xref linkend="boot"> 描述的， FreeBSD
	采用一个三步的启动过程。 最先两步储存在 FreeBSD 启动磁盘的启动
	slice 的启动代码块中。 引导块然后就被加载，
	接着运行第三步启动引导器 (<filename>/boot/loader</filename>)。</para>

      <para>为了设置串行控制台， 您必须配置启动代码块， 启动引导器代码和内核。</para>

    </sect2>
    
    <sect2 id="serialconsole-howto-fast">
      <title>串行控制台的配置， 简明版</title>
  
      <para>本节假定您使用默认的配置， 了解如何连接串口，
	并且希望快速地了解一下串行控制台。 如果您在采取这些步骤时遇到问题，
	请参考
	<xref linkend="serialconsole-howto"> 中关于高级设置的详细介绍。</para>

      <procedure>

	<step>
	  <para>连接串口。 串行控制台将出现在
	    <devicename>COM1</devicename> 上。</para>
	</step>

	<step>
	  <para>使用 <command>echo -h &gt; /boot.config</command>
	    来启用引导加载器和内核的串口控制台。</para>
	</step>

	<step>
	  <para>编辑 <filename>/etc/ttys</filename> 并把 <literal>ttyd0</literal> 的
	    <literal>off</literal> 改为 <literal>on</literal>。
	    这将在串口控制台上启用一个登录提示， 其内容和普通的控制台一样。</para>
	</step>

	<step>
	  <para><command>shutdown -r now</command> 将重启系统并启用串行控制台。</para>
	</step>

      </procedure>

    </sect2>

    <sect2 id="serialconsole-howto">
      <title>串行控制台的设置S</title>

      <procedure>
	<step>
	  <para>准备一个串行线缆。</para>

	  <indexterm><primary>null-modem cable</primary></indexterm>
	  <para>您需要使用一个 null-modem 的线缆或标准的串行线和一个 null-modem
	    适配器。 请参考 <xref linkend="serial-cables-ports">
	    中有关串行线的讨论。</para>
	</step>

	<step>
	  <para>拔掉键盘。</para>

	  <para>绝大多数的PC在开机检测的时候会检测到键盘，
	    如果没有检测到键盘， 则会出现错误。 一些机器会提示缺少键盘，
	    就不会继续引导系统。</para>

	  <para>如果您的计算机出现错误， 但仍能继续启动， 您可以不必理它。</para>

	  <para>如果您的计算机没有键盘拒绝启动， 那您需要配置 BIOS
	    来避免它。 请参考您的主板的使用说明了解更多细节。</para>

	  <tip>
	    <para>在 BIOS 中设置键盘 <quote>Not installed</quote>
	      并不意味着您不能使用键盘。 这样做只是告诉 BIOS
	      不要在机器开机检测时检测键盘以至提示您系统找不到键盘。
	      即使您设置了 <quote>Not installed</quote>，
	      只要把键盘插上去仍然可以使用。</para>
	  </tip>

	  <note>
	    <para>如果系统有 PS/2 鼠标， 如果幸运的话，
	      您也可以象键盘一样把它拔下来， 这是因为 PS/2
	      鼠标与键盘的一些硬件是共享的， 您的鼠标插上去，
	      系统会认为键盘仍在那儿。</para>
	  </note>
	</step>

	<step>
	  <para>插一个哑 (dumb) 终端到<devicename>COM1</devicename>：（<devicename>sio0</devicename>）。</para>

	  <para>如果您没有哑终端， 可以使用一个比较老的带有一个 modem
	    程序的PC/XT机器， 或在其他 &unix; 机器上的串口。 如果您没有
	    <devicename>COM1</devicename>： (<devicename>sio0</devicename>)，
	    去找一个。 这时， 您就不能只能选择
	    <devicename>COM1</devicename>：来启动系统。
	    如果您已经在另一台设备上使用 <devicename>COM1</devicename>，
	    您必须临时删除那个设备， 然后安装一个新的系统引导块和内核。</para>
	</step>

	<step>
	  <para>确信您的内核配置文件已经为 <devicename>COM1</devicename>：
	    (<devicename>sio0</devicename>) 设置了适当的标记：</para>

	  <para>有关的标记是：</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>0x10</literal></term>

	      <listitem>
		<para>启用控制台支持。 如果没有设置它，
		  则其他的控制台标记都会被忽略。 现在，
		  绝大多数的设置都有控制台的支持。
		  这个标记的第一个就是首选的。
		  这个单独选项是不能确保串口适用于控制台的，
		  设置下面的标记或加上下面描述的 <option>-h</option> 选项，
		  和这个放在一起。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x20</literal></term>

	      <listitem>
		<para>不管下面有没有讨论， 都强制这个选项支持控制台。
		  这个标记在 FreeBSD 2.X 中取代了
		  <literal>COMCONSOLE</literal>选项。
		  标记 <literal>0x20</literal> 必须和
		  <option>0x10</option> 一起使用。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x40</literal></term>

	      <listitem>

		<para>预留这个单元 (配合
		  <literal>0x10</literal>) 并让它不能用于普通的使用。
		  您不应在希望作为控制台的串口单元上设置这个标志。
		  这一标志是为内核远程调试准备的。
		  参见 <ulink
		  url="&url.books.developers-handbook;/index.html">开发者手册</ulink>
		  以了解关于远程调试更进一步的情况。</para>
		
		<note>
		  <para>在FreeBSD 4.0-CURRENT和以后的版本中，标记
		    <literal>0x40</literal>通常是不同的，
		    有另一个标记可以来指定一个串口用于远程调试。</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>例如：</para>

	  <programlisting>device sio0 at isa? port IO_COM1 flags 0x10 irq 4</programlisting>

	  <para>看看 &man.sio.4; 的联机手册了解更多信息。</para>

	  <para>如果标记没有被设置， 您必须运行UserConfig或重新编译内核。</para>
	</step>

	<step>
	  <para>在启动磁盘的 <literal>a</literal> 分区的根目录创建
	    <filename>boot.config</filename> 文件。</para>

	  <para>这个文件将指导引导块代码如何启动系统。 为了激活串行控制台，
	    您必须有一个或多个下面的选项――如果您要多个选项，
	    在同一行必须都包含它们：</para>

	  <variablelist>
	    <varlistentry>
	      <term><option>-h</option></term>

	      <listitem>
		<para>切换内部和串行控制台。 您使用这个来交换控制台设备。
		  例如， 如果您从内部控制台启动， 您可以使用 <option>-h</option>
		  来直接使用启动引导器和内核来使用串口作为它的控制台设备。
		  另外， 如果您从串口启动， 您可以使用 <option>-h</option>
		  来告诉启动引导器和内核使用显示设备作为控制台。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-D</option></term>

	      <listitem>
		<para>切换单一和双重控制台配置。 在单一配置中，
		  控制台将是本机的控制台 (显示设备) 或串口。
		  在双重控制台配置中， 显示设备和串口将同时成为控制台，
		  无论 <option>-h</option> 的选项的情形。 然而，
		  双控制台配置只在引导块运行的过程中起作用。
		  一旦启动引导器获得控制， 由 <option>-h</option>
		  选项指定的控制台将成为唯一的控制台。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-P</option></term>

	      <listitem>
		<para>在启动时，探测键盘。如果键盘找不到，
		  <option>-D</option> 和 <option>-h</option> 选项会自动设置。</para>

		<note>
		  <para>由于当前版本引导块的空间限制， <option>-P</option>
		    选项只能探测扩展的键盘。 少于101键的键盘将无法被探测到。
		    如果您碰到这个情况， 您必须避免使用 <option>-P</option>
		    选项。 目前还没有绕过这个问题的办法。</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>使用 <option>-P</option> 选项来自动选择控制台， 或使用
	    <option>-h</option> 选项来激活控制台。</para>

	  <para>您也可以使用boot联机文档中所描述的其他选项。</para>

	  <para>除了 <option>-P</option> 选项， 所有选项将被传给启动引导器
	    (<filename>/boot/loader</filename>)。 启动引导器将通过检查
	    <option>-h</option> 选项的状态来决定是显示设备成为控制台，
	    还是串口成为控制台。 这表示如果您指定 <option>-D</option> 选项，
	    但在 <filename>/boot.config</filename> 中没有 <option>-h</option>
	    选项， 您在启动代码块时使用串口作为控制台。
	    启动引导器将使用内部显示设备作为控制台。</para>
	</step>

	<step>
	  <para>启动机器</para>

	  <para>当您启动您的FreeBSD时，引导块将把 <filename>/boot.config</filename>
	    的内容发给控制台。例如：</para>

	  <screen>/boot.config: -P
Keyboard: no</screen>
    
	  <para>如果您把 <option>-P</option> 放在 <filename>/boot.config</filename>
	    中并指出键盘存在或不存在， 那将只出现第二行。
	    这些信息会被定位到串口或内部控制台， 或两者同时， 这完全取决于
	    <filename>/boot.config</filename> 中的选项。</para>

	  <informaltable frame="none">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>选项</entry>
		  <entry>定位信息</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>none</entry>
		  <entry>内部控制台</entry>
		</row>

		<row>
		  <entry><option>-h</option></entry>
		  <entry>串行控制台</entry>
		</row>

		<row>
		  <entry><option>-D</option></entry>
		  <entry>串行控制台和内部控制台</entry>
		</row>

		<row>
		  <entry><option>-Dh</option></entry>
		  <entry>串行控制台和内部控制台</entry>
		</row>

		<row>
		  <entry><option>-P</option>， 有键盘</entry>
		  <entry>内部控制台</entry>
		</row>

		<row>
		  <entry><option>-P</option>， 无键盘</entry>
		  <entry>串行控制台</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>出现上面信息后，在引导块加载启动引导器和更多信息被映到屏幕之前将有一个小小的停顿。
	    在通常情况下， 您不需要打断启动进程， 但为了确信设置是否正确， 您也可以这样做。</para>

	  <para>在控制台上按 <keycode>Enter</keycode> 以外的任意键就能打断启动进程。
	    引导块将进入命令行模式。 您将看到：</para>

	  <screen>>> FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>

	  <para>检验上面出现的信息， 可能是串口， 或内部控制台， 或两个同时，
	    完全取决于您在 <filename>/boot.config</filename> 中的选项。
	    如果信息出现在正确的控制台， 按 <keycode>Enter</keycode>
	    继续启动进程。</para>

	  <para>如果您要使用串行控制台， 但您没有看到命令行， 那可能设置有问题。
	    这时， 输入 <option>-h</option> 然后按 Enter/Return 来告诉引导块
	    (然后是启动引导器和内核) 选择串口作为控制台。 一旦系统起来了，
	    就可以回去检查一下是什么出了问题。</para>
	</step>
      </procedure>

      <para>启动引导器加载完后， 您将进入启动进程的第三步，
	您仍然可以在启动引导器通过设定您喜欢的环境来切换内部控制台和串行控制台。
	参考 <xref linkend="serialconsole-loader">。</para>
    </sect2>

  <sect2 id="serialconsole-summary">
    <title>摘要</title>

      <para>这是几个在这章要讨论的几个设置和选择的控制台的摘要。</para>

      <sect3>
	<title>例1： 您为 <devicename>sio0</devicename> 设置标记 0x10</title>

	<programlisting>device sio0 at isa? port IO_COM1 flags 0x10 irq 4</programlisting>

	<informaltable frame="none">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry>在/boot.config中的选项</entry>
		<entry>引导块过程中的控制台</entry>
		<entry>启动引导器过程中的控制台</entry>
		<entry>内核中的控制台</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>无</entry>
		<entry>内部</entry>
		<entry>内部</entry>
		<entry>内部</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>串行</entry>
		<entry>串行</entry>
		<entry>串行</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>串行和内部</entry>
		<entry>内部</entry>
		<entry>内部</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>串行和内部</entry>
		<entry>串行</entry>
		<entry>串行</entry>
	      </row>

	      <row>
		<entry><option>-P</option>， 有键盘</entry>
		<entry>内部</entry>
		<entry>内部</entry>
		<entry>内部</entry>
	      </row>

	      <row>
		<entry><option>-P</option>， 没有键盘</entry>
		<entry>串行和内部</entry>
		<entry>串行</entry>
		<entry>串行</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>例2：您为sio0设置标记为0x30</title>

	<programlisting>device sio0 at isa? port IO_COM1 flags 0x30 irq 4</programlisting>

	<informaltable frame="none">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry>在/boot.config中的选项</entry>
		<entry>引导块过程中的控制台</entry>
		<entry>启动引导器过程中的控制台</entry>
		<entry>内核中的控制台</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>无</entry>
		<entry>内部</entry>
		<entry>内部</entry>
		<entry>串行</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>串行</entry>
		<entry>串行</entry>
		<entry>串行</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>串行和内部</entry>
		<entry>内部</entry>
		<entry>串行</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>串行和内部</entry>
		<entry>串行</entry>
		<entry>串行</entry>
	      </row>

	      <row>
		<entry><option>-P</option>， 有键盘</entry>
		<entry>内部</entry>
		<entry>内部</entry>
		<entry>串行</entry>
	      </row>

	      <row>
		<entry><option>-P</option>， 没有键盘</entry>
		<entry>串行 and internal</entry>
		<entry>串行</entry>
		<entry>串行</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
    </sect2>

    <sect2 id="serialconsole-tips">
      <title>串行控制台的提示</title>

      <sect3>
	<title>设置一个快速的串口速度</title>

	<para>默认的串口被设置成9600波特，8数据位， 无奇偶校验， 1个停止位。
	  如果您希望改变速度， 就必须重新编译引导块。在 <filename>/etc/make.conf</filename>
	  中添加下面一行， 然后编译新的引导块：</para>

	<programlisting>BOOT_COMCONSOLE_SPEED=19200</programlisting>
  
	<para>参见 <xref linkend="serialconsole-com2">
	  以了解如何编译和安装新的引导块。</para>

	<para>如果串行控制台用其他方法来配置而不是在启动时用
	  <option>-h</option>， 或内核使用的串行控制台与引导块使用的不同，
	  就必须在内核配置中加入下面这行，并重新编译内核：</para>
  
	<programlisting>options CONSPEED=19200</programlisting>
      </sect3>

      <sect3 id="serialconsole-com2">
	<title>使用 <devicename>sio0</devicename> 以外的串口
	  作为控制台</title>

	<para>使用串口而不是 <devicename>sio0</devicename>
	  作为控制台需要做一些重编译。 如果您无论如何都要使用另一个串口，
	  重新编译引导块， 启动引导器和内核。</para>

	<procedure>
	  <step>
	    <para>取得内核源代码 (参考 <xref linkend="cutting-edge">)。</para>
	  </step>

	  <step>
	    <para>编辑 <filename>/etc/make.conf</filename> 文件， 然后设置
	      <literal>BOOT_COMCONSOLE_PORT</literal>作为您要使用
	      (<literal>0x3f8</literal>、 <literal>0x2f8</literal>、 0x3E8
	      或 0x2E8) 端口的地址。 只有 <devicename>sio0</devicename> 到
	      <devicename>sio3</devicename> (<devicename>COM1</devicename> 到
	      <devicename>COM4</devicename>) 都可以使用； 但多口串行卡将不会工作。
	      不需要任何中断设置。</para>
	  </step>

	  <step>
	    <para>创建一个定制的内核配置文件， 在您要使用的串口添加合适的标记。
	      例如， 如果要将 <devicename>sio1</devicename>
	      (<devicename>COM2</devicename>) 作为控制台：</para>

	    <programlisting>device sio1 at isa? port port IO_COM2 flags 0x10 irq 3</programlisting>

	    <para>or</para>

	    <programlisting>device sio1 at isa? port port IO_COM2 flags 0x30 irq 3</programlisting>

	    <para>其他端口的控制台标记也不要设。</para>
	  </step>

	  <step>
	    <para>重新编译和安装引导块：</para>

	    <screen>&prompt.root; <userinput>cd /sys/boot</userinput>
&prompt.root; <userinput>make clean</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>
	  </step>

	  <step>
	    <para>重建和安装内核。</para>
	  </step>

	  <step>
	    <para>用 &man.disklabel.8;
	      将引导块写到启动盘上，然后从新内核启动。</para>
	  </step>
	</procedure>
      </sect3>

      <sect3 id="serialconsole-ddb">
	<title>通过串行线进入DDB调试器</title>

	<programlisting>options BREAK_TO_DEBUGGER
options DDB</programlisting>
      </sect3>

      <sect3>
	<title>在串行控制台上得到一个登录命令行</title>

	<para>您可能希望通过串行线进入登录提示， 现在您可以看到启动信息，
	  通过串行控制台键入内核调试信息。可以这样做。</para>

	<para>用一个编辑器打开 <filename>/etc/ttys</filename> 文件，
	  然后找到下面的行：</para>

      <programlisting>ttyd0 "/usr/libexec/getty std.9600" unknown off secure
ttyd1 "/usr/libexec/getty std.9600" unknown off secure
ttyd2 "/usr/libexec/getty std.9600" unknown off secure
ttyd3 "/usr/libexec/getty std.9600" unknown off secure</programlisting>

	<para><literal>ttyd0</literal> 到 <literal>ttyd3</literal> 相当于
	  <devicename>COM1</devicename> 到 <devicename>COM4</devicename>。
	  可以打开或关闭某个端口。 如果您已经改变了串口的速度，
	  还必须改掉标准的 9600 与当前的例如 19200 相匹配。</para>

	<para>您也可以改变终端的类型从不知名的到您串行终端的真实类型。
	  编辑完这个文件， 您必须 <command>kill -HUP 1</command>
	  来使这个修改生效。</para>
      </sect3>
    </sect2>

    <sect2 id="serialconsole-loader">
      <title>从启动引导器修改控制台</title>

      <para>前面一节描述了如何通过调整引导块来设定串行控制台。
	这节将讲到在启动引导器中通过键入一些命令和环境变量来指定控制台。
	由于启动引导器会被启动进程的第三步所调用， 引导块以后，
	在启动引导器中的设置将忽略在引导块中的设置。</para>

      <sect3>
	<title>配置串行控制台</title>

	<para>您可以很容易地指定启动引导器和内核来使用串行控制台， 只需要在
	  <filename>/boot/loader.rc</filename>中写入下面这行：</para>

	<programlisting>set console=comconsole</programlisting>

	<para>无论前一节中的引导块如何配置， 这个设置都会生效。</para>

	<para>您最好把上面一行放在文件的第一行，
	  以便尽早地在启动时看到串行控制台的启动信息。</para>

	<para>同样地，您可以指定内部控制台为：</para>

	<programlisting>set console=vidconsole</programlisting>

	<para>如果您不设置启动引导环境变量控制台，
	  启动引导器和内核将使用在引导块时用 <option>-h</option>
	  选项指定的控制台。</para>

	<para>在 3.2 以及更新的版本中，您可以在 <filename>/boot/loader.conf.local</filename>
	  或 <filename>/boot/loader.conf</filename> 中，
	  而不是在 <filename>/boot/loader.rc</filename> 指定控制台。
	  用这种方法， 您的 <filename>/boot/loader.rc</filename>
	  文件将是这样的：</para>

	<programlisting>include /boot/loader.4th
start</programlisting>

	<para>然后， 创建 <filename>/boot/loader.conf.local</filename> 并加入下面的行。</para>

	<programlisting>console=comconsole</programlisting>

	<para>或</para>

	<programlisting>console=vidconsole</programlisting>

	<para>看看 &man.loader.conf.5; 的联机手册了解更多信息。</para>

	<note>
	  <para>目前， 引导块还没有与引导加载器的
	    <option>-P</option> 选项等价的选项，
	    此外也没有在存在键盘时自动选则使用什么控制台的能力。</para>
	</note>
      </sect3>

      <sect3>
	<title>使用串口而不是<devicename>sio0</devicename>作为控制台</title>

	<para>要使用一个串口而不是 <devicename>sio0</devicename> 作为串行控制台
	  需要重新编译启动引导器。下面的步骤跟
	  <xref linkend="serialconsole-com2"> 描述的相似。</para>
      </sect3>
    </sect2>

    <sect2 id="serialconsole-caveats">
      <title>警告</title>

      <para>这篇文章本意是想告诉人们如何设定没有显示设备或键盘的专用服务器。
	不幸的是， 绝大多数系统没有键盘可以让您启动，
	而没有显示设备就不让您启动。 使用 AMI BIOS 的机器可以通过在 CMOS
	中将 <quote>graphics adapter</quote> 项设为
	<quote>Not installed</quote> 来在启动时不要求显示适配器。</para>

      <para>然而， 许多机器并不支持这个选项，
	如果您的系统没有显示硬件就拒绝启动。 对于这些机器， 即使您没有显示器，
	也必须在机器上插上显示适配器。 建议您试试采用 AMI BIOS 的机器。</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
