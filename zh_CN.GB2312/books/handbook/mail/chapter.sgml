<!--
     The FreeBSD Documentation Project
     The FreeBSD Chinese Documentation Project

     Original Revision: 1.121
     $FreeBSD$
-->

<chapter id="mail">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Bill</firstname>
	<surname>Lloyd</surname>
	<contrib>Original work by </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Rewritten by </contrib>
	<!-- 2 Dec 1999 -->
      </author>
    </authorgroup>
  </chapterinfo>

  <title>电子邮件</title>

  <sect1 id="mail-synopsis">
    <title>概述</title>
    <indexterm><primary>email</primary></indexterm>
    <indexterm><primary>电子邮件</primary></indexterm>

    <para><quote>电子邮件</quote>，或通常所说的 email，是现今使用最广泛的通信方式之一。
      本章将对如何在 &os; 上运行邮件服务，以及如何使用 &os; 来收发电子邮件作基本的介绍；
      然而，它并不是一份完整的参考手册，实际上，许多需要考虑的重要事项都没有提及。
      我们推荐读者阅读 <xref linkend="bibliography"> 中的参考书籍，以获得对于这部分的全面认识。</para>

    <para>读完这章，您将了解：</para>

    <itemizedlist>
      <listitem>
	<para>那些软件与收发电子邮件有关。</para>
      </listitem>

      <listitem>
	<para>&os; 下的基本 <application>sendmail</application> 配置文件在哪里。</para>
      </listitem>

      <listitem>
        <para>本地和远程邮箱之间的区别。</para>
      </listitem>

      <listitem>
	<para>如何阻止垃圾邮件制造者非法地使用您的邮件服务器作为转发中继。</para>
      </listitem>

      <listitem>
	<para>如何安装和配置用于替代 <application>sendmail</application> 的其他邮件传输代理。</para>
      </listitem>

      <listitem>
	<para>如何处理常见的邮件服务器问题。</para>
      </listitem>

      <listitem>
	<para>如何使用 SMTP 和 UUCP。</para>
      </listitem>

      <listitem>
	<para>如何设置系统使其只能发送邮件。</para>
      </listitem>

      <listitem>
	<para>如何在拨号连接时使用邮件。</para>
      </listitem>

      <listitem>
        <para>如何配置 SMTP 验证以增加安全性。</para>
      </listitem>

      <listitem>
        <para>如何安装并使用用户邮件代理，如
	  <application>mutt</application> 来收发邮件。</para>
      </listitem>

      <listitem>

        <para>如何从远程的 <acronym>POP</acronym>
	  或 <acronym>IMAP</acronym> 服务器上下载邮件。</para>
      </listitem>

      <listitem>
        <para>如何在进入的邮件上自动地应用过滤器和规则。</para>
      </listitem>
    </itemizedlist>

    <para>阅读本章之前，您需要：</para>

    <itemizedlist>
      <listitem>
	<para>正确地配置您的网络连接
	  (<xref linkend="advanced-networking">).</para>
      </listitem>

      <listitem>
	<para>正确地为您的邮件服务器配置 DNS 信息
	  (<xref linkend="network-servers">).</para>
      </listitem>

      <listitem>
	<para>知道如何安装第三方软件
	  (<xref linkend="ports">).</para></listitem>
      </itemizedlist>
  </sect1>

  <sect1 id="mail-using">
    <title>使用电子邮件</title>
    <indexterm><primary>POP</primary></indexterm>
    <indexterm><primary>IMAP</primary></indexterm>
    <indexterm><primary>DNS</primary></indexterm>

    <para>邮件交换可以分为 5 部分。它们是：
      <link linkend="mail-mua">用户端程序</link>、<link
      linkend="mail-mta">服务端守护进程</link>、<link
      linkend="mail-dns">DNS</link>、<link
      linkend="mail-receive">远程或本地的邮箱</link>、
      当然，<link linkend="mail-host">还有邮件主机自己</link>。</para>

    <sect2 id="mail-mua">
      <title>用户端程序</title>

      <para>这包括一些基于命令行的程序，例如
	<application>mutt</application>、
	<application>pine</application>、<application>elm</application>
	和 <command>mail</command>，以及类似 <application>balsa</application>、
	<application>xfmail</application> 这样的 <acronym>GUI</acronym> 程序。
	此外，还有我们更<quote>熟悉的</quote>WWW 浏览器这样的程序。
	这些程序简单地通过调用<link
	linkend="mail-mta">服务守护进程</link>把邮件事务交给本地的
	<link linkend="mail-host"><quote>邮件主机</quote></link>，或者通过
	<acronym>TCP</acronym> 把邮件发出去。</para>
	</sect2>
    <sect2 id="mail-mta">
      <title>邮件主机上使用的服务程序</title>
      <indexterm>
        <primary>邮件服务程序</primary>
        <secondary><application>sendmail</application></secondary>
      </indexterm>
      <indexterm>
        <primary>邮件服务程序</primary>
        <secondary><application>postfix</application></secondary>
      </indexterm>
      <indexterm>
        <primary>邮件服务程序</primary>
        <secondary><application>qmail</application></secondary>
      </indexterm>
      <indexterm>
        <primary>邮件服务程序</primary>
        <secondary><application>exim</application></secondary>
      </indexterm>

      <para>&os; 默认情况下采用 <application>sendmail</application>，
	但它也支持为数众多的其它邮件服务程序，
	这其中包括：</para>

      <itemizedlist>
	<listitem>
	  <para><application>exim</application>;</para>
	</listitem>

	<listitem>
	  <para><application>postfix</application>;</para>
	</listitem>

	<listitem>
	  <para><application>qmail</application>.</para>
	</listitem>
      </itemizedlist>

      <para>邮件服务器后台守护程序通常有两个功能 &mdash;
	接收外面发来的邮件和把邮件传送出去。 但它
	<emphasis>不</emphasis> 负责使用类似
	<acronym>POP</acronym> 或 <acronym>IMAP</acronym> 这样的协议来帮您阅读邮件，
	也不负责连接到本地的
	<filename>mbox</filename> 或 Maildir 信箱。 您可能需要其它的
	<link linkend="mail-receive">服务程序</link> 来完成这些任务。</para>

      <warning>
	<para>较早版本的 <application>sendmail</application>
	  有一些严重的安全问题， 他们可能导致攻击者从本地和/或远程操作您的电脑。
	  您应该确认自己使用的是最新版本以避免这些问题。
	  另外， 也可以从 <link linkend="ports">&os;
	  Ports Collection</link> 来安装其它的
	  <acronym>MTA</acronym>。</para>
      </warning>
    </sect2>

    <sect2 id="mail-dns">
      <title>Email 和 DNS</title>

      <para>域名系统 (DNS) 及其服务程序
        <command>named</command> 在email的投递过程当中扮演着很重要的角色。
	为了能够从您的站点向其它的站点传递邮件， 服务程序需要通过 DNS 查找接收邮件的远程站点的位置。
	类似地， 在远程站点向您的主机投递邮件时也会发生这样的查找。</para>

      <indexterm>
	<primary>MX 记录</primary>
      </indexterm>

      <para><acronym>DNS</acronym> 负责将主机名映射为 IP 地址，
	同时， 也需要保存递送邮件时所需要的信息， 这些信息称作 MX 记录。
	MX (Mail eXchanger，邮件交换) 记录指定了哪个， 或哪些主机能够接收特定域下的邮件。
	如果您没有为主机名或域名设置 MX 记录， 则邮件将被直接递交给主机名对应 IP 所在的主机。</para>

      <para>您可以通过
	&man.host.1; 命令来查找任何域或主机名对应的 MX 记录， 如下面的例子所示：</para>

      <screen>&prompt.user; <userinput>host -t mx FreeBSD.org</userinput>
FreeBSD.org mail is handled (pri=10) by mx1.FreeBSD.org</screen>
    </sect2>

    <sect2 id="mail-receive">
      <title>接收邮件</title>
      <indexterm>
        <primary>电子邮件</primary>
        <secondary>接收</secondary>
      </indexterm>

      <para>为您的域接收邮件是通过邮件服务器来完成的。
	它收集发送给您的域的那些邮件，并保存到
	<filename>mbox</filename> (存储邮件默认的方法) 或 Maildir 格式，
	这取决于您采用的配置。
	一旦邮件被保存下来， 就可以在本地通过类似
	&man.mail.1; 或
	<application>mutt</application> 这样的程序， 或在远程通过
	<acronym>POP</acronym> 或 <acronym>IMAP</acronym> 这样的协议来读取了。
	简单地说， 如果您只在本地阅读邮件，那就没有必要安装
	<acronym>POP</acronym> 或 <acronym>IMAP</acronym> 服务。</para>

      <sect3 id="pop-and-imap">
        <title>通过 <acronym>POP</acronym> 和 <acronym>IMAP</acronym> 访问远程的邮件</title>

        <indexterm><primary>POP</primary></indexterm>
        <indexterm><primary>IMAP</primary></indexterm>
	<para>如果希望在远程访问邮箱， 就需要访问
	  <acronym>POP</acronym> 或 <acronym>IMAP</acronym>
	  服务器。 这些协议允许用户从远程方便地访问他们的信箱。 尽管
	  <acronym>POP</acronym> 和 <acronym>IMAP</acronym> 都允许用户从远程访问信箱，
	  但 <acronym>IMAP</acronym> 有很多优点， 这包括：</para>

        <itemizedlist>
          <listitem>
	    <para><acronym>IMAP</acronym> 既可以从远程服务器上抓取邮件， 也可以把邮件放上去。</para>
          </listitem>

          <listitem>
	    <para><acronym>IMAP</acronym> 支持并发更新。</para>
          </listitem>

          <listitem>
	    <para><acronym>IMAP</acronym> 对于使用低速网络的用户尤为有用，
	      因为它能够让这些用户把邮件的结构下载下去， 而无需立即下载整个邮件。
	      它还可以在服务器端执行类似查找这样的操作， 以减少客户机和服务器之间的通讯量。</para>
          </listitem>

        </itemizedlist>

        <para>您可以按照下面的步骤来安装和配置 <acronym>POP</acronym> 或
	  <acronym>IMAP</acronym> 服务器：</para>

        <procedure>
	  <step>
	    <para>选择一个最符合需要的 <acronym>IMAP</acronym> 或
	      <acronym>POP</acronym> 服务器。
	      下列 <acronym>POP</acronym> 和
	      <acronym>IMAP</acronym> 服务器是最著名的， 而且都有很多成功案例：</para>

	      <itemizedlist>
	        <listitem>
		  <para><application>qpopper</application>;</para>
	        </listitem>

	        <listitem>
		  <para><application>teapop</application>;</para>
	        </listitem>

	        <listitem>
		  <para><application>imap-uw</application>;</para>
	        </listitem>

	        <listitem>
		  <para><application>courier-imap</application>;</para>
	        </listitem>
	      </itemizedlist>

	  </step>

          <step>
	    <para>通过 ports collection 安装 <acronym>POP</acronym> 或
	      <acronym>IMAP</acronym> 服务。</para>
	  </step>

	  <step>
	    <para>根据需要修改 <filename>/etc/inetd.conf</filename>
	      来加载 <acronym>POP</acronym> 或
	      <acronym>IMAP</acronym> 服务。</para>
	  </step>
        </procedure>

	<warning>
	  <para>此外还应注意的是 <acronym>POP</acronym> 和
	    <acronym>IMAP</acronym> 传递的信息， 包括用户名和口令等等，
	    通常都是明文的。 这意味着如果您希望加密传输过程中的信息，
	    可能需要考虑使用 &man.ssh.1; 隧道。 关于如何实施隧道在
	    <xref linkend="security-ssh-tunneling"> 中进行了详细阐述。</para>
        </warning>
      </sect3>

      <sect3 id="local">
        <title>操作本地的信箱</title>

	<para>信箱可以在邮件服务器本地直接用
	  <acronym>MUA</acronym> 来进行操作。
	  这通常是通过
	  <application>mutt</application> 或 &man.mail.1; 这样的用用程序实现的。
	</para>
      </sect3>
    </sect2>

	<sect2 id="mail-host">
	  <title>邮件服务器</title>
	  <indexterm><primary>邮件服务器</primary></indexterm>

	  <para>邮件服务器是通过服务器给的一个名字,这也正是它能在您的主机和网络上发送和接收邮件的原因.</para>
	</sect2>
  </sect1>

  <sect1 id="sendmail">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Christopher</firstname>
          <surname>Shumway</surname>
          <contrib>作者：</contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title><application>sendmail</application> 配置</title>

    <indexterm>
      <primary><application>sendmail</application></primary>
    </indexterm>

    <para>&man.sendmail.8; 是 &os; 中的默认邮件传输代理 (MTA)。
      <application>sendmail</application> 的任务是从邮件用户代理
      (<acronym>MUA</acronym>) 接收邮件然后根据配置文件的定义把它们送给配置好的的寄送程序。
      <application>sendmail</application> 也能接受网络连接，
      并且发送邮件到本地邮箱或者发送它到其它程序。</para>

    <para><application>sendmail</application> 使用下列配置文件：</para>

    <indexterm>
      <primary><filename>/etc/mail/access</filename></primary>
    </indexterm>
    <indexterm>
      <primary><filename>/etc/mail/aliases</filename></primary>
    </indexterm>
    <indexterm>
      <primary><filename>/etc/mail/local-host-names</filename></primary>
    </indexterm>
    <indexterm>
      <primary><filename>/etc/mail/mailer.conf</filename></primary>
    </indexterm>
    <indexterm>
      <primary><filename>/etc/mail/mailertable</filename></primary>
    </indexterm>
    <indexterm>
      <primary><filename>/etc/mail/sendmail.cf</filename></primary>
    </indexterm>
    <indexterm>
      <primary><filename>/etc/mail/virtusertable</filename></primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
		<entry>文件名</entry>
		<entry>功能</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
		<entry>
		  <filename>/etc/mail/access</filename>
		</entry>
		<entry><application>sendmail</application> 访问数据库文件
		  </entry>
	  </row>
	  <row>
		<entry>
		  <filename>/etc/mail/aliases</filename>
		</entry>
		<entry>邮箱别名</entry>
	  </row>
	  <row>
		<entry>
		  <filename>/etc/mail/local-host-names</filename>
		</entry>
		<entry> <application>sendmail</application>
		接收邮件主机列表</entry>
	</row>
	  <row>
		<entry>
		  <filename>/etc/mail/mailer.conf</filename>
		</entry>
		<entry>邮寄配置程序</entry>
	  </row>
	  <row>
		<entry>
		  <filename>/etc/mail/mailertable</filename>
		</entry>
		<entry>邮件分发列表</entry>
	  </row>
	  <row>
		<entry>
		  <filename>/etc/mail/sendmail.cf</filename>
		</entry>
		<entry><application>sendmail</application>的主配置文件
		</entry>
	  </row>
	  <row>
		<entry>
		  <filename>/etc/mail/virtusertable</filename>
		</entry>
		<entry>虚拟用户和域列表</entry>
	  </row>
	</tbody>
	  </tgroup>
	</informaltable>

  <sect2>
	<title><filename>/etc/mail/access</filename></title>

	<para>访问数据库定义了什么主机或者 IP
	  地址可以访问本地邮件服务器和它们是哪种类型的访问。
	  主机可能会列出 <option>OK</option>、
	  <option>REJECT</option>、<option>RELAY</option> 或者简单的通过
	  <application>sendmail</application> 的出错处理程序检测一个给定的邮件错误。
	  主机默认列出 <option>OK</option>，允许传送邮件到主机，
	  只要邮件的最后目的地是本地主机。列出 <option>REJECT</option>
	  将拒绝所有的邮件连接。如果带有 <option>RELAY</option>
	  选项的主机将被允许通过这个邮件服务器发送邮件到任何地方。</para>

	  <example>
	<title>配置<application>sendmail</application>
	  访问数据库</title>

	<programlisting>cyberspammer.com                550 We don't accept mail from spammers
FREE.STEALTH.MAILER@            550 We don't accept mail from spammers
another.source.of.spam          REJECT
okay.cyberspammer.com           OK
128.32                          RELAY</programlisting>
	  </example>

   <para>在上面的例子中我们有 5 条记录。
     与左边列表匹配的发件人受到右边列表动作的影响。
     前边的两个例子给出了 <application>sendmail</application>
     的出错处理程序检测到的错误代码。
     当一个邮件与左边列表相匹配时，这个信息会被打印到远程主机上。
     下一条记录拒绝来自 Internet 上的一个特别主机的邮件
     <hostid>another.source.of.spam</hostid>。接下来的记录允许来自
     <hostid role="fqdn">okay.cyberspammer.com</hostid> 的邮件连接，
     这条记录比上面那行 <hostid role="domainname">cyberspammer.com</hostid>
     更准确。更多的准确匹配使不准确的匹配无效。最后一行允许电子邮件从主机和
     <hostid>128.32</hostid> 开头的 IP 地址转发。
     这些主机将被允许通过这台邮件服务器前往其它邮件服务器发送邮件。</para>

   <para>当这个文件被升级的时候，您必须在
     <filename>/etc/mail/</filename> 运行 <command>make</command>
     升级数据库。</para>

   </sect2>
   <sect2>
    <title><filename>/etc/mail/aliases</filename></title>

    <para>别名数据库包含一个扩展到用户，程序或者其它别名的虚拟邮箱列表。
      下面是一些在 <filename>/etc/mail/aliases</filename> 中使用的例子：</para>

      <example>
	<title>邮件别名</title>
    <programlisting>root: localuser
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: "|/usr/local/bin/procmail"</programlisting>
      </example>

      <para>文件格式比较简单：邮箱名在冒号左边，右边是扩展的目标。
	第一个例子简单的扩展邮箱 <username>root</username>
	到邮箱 <username>localuser</username>，它可以在别名数据库中被找到。
	如果没有找到匹配的，那么这个信息会被发送给本地用户
	<username>localuser</username>。接下来的例子显示了一个邮件列表。
	发送到 <username>ftp-bugs</username> 邮箱的邮件会被扩展为三个本地邮箱
	<username>joe</username>、
	<username>eric</username> 和 <username>paul</username>。注意
	一个远程邮箱可以用 <literal>user@example.com</literal> 的形式指定。
	下个例子显示将邮件写到 <filename>/dev/null</filename> 文件。
	最后一个例子向您展示了传送邮件到一个程序，在这个例子里邮件通过
	&unix; 管道被写到 <filename>/usr/local/bin/procmail</filename>
	标准输入里。</para>

   <para>当这个文件被升级时, 您必须在<filename>/etc/mail/</filename>运行
   <command>make</command>来升级数据库.</para>
  </sect2>
  <sect2>
    <title><filename>/etc/mail/local-host-names</filename></title>

    <para>这是一个 &man.sendmail.8; 被接受为一个本地主机名的主机名列表。
      可以放入任何 <application>sendmail</application>
      将从那里收发邮件的域名或主机。例如，如果这个邮件服务器从域
      <hostid role="domainname">example.com</hostid> 和主机
      <hostid role="fqdn">mail.example.com</hostid> 接收邮件，它的
      <filename>local-host-names</filename> 文件，可以看起来象如下这样：</para>

    <programlisting>example.com
mail.example.com</programlisting>

    <para>当这个文件被升级，&man.sendmail.8; 必须重新启动，以便更新设置。</para>

  </sect2>

  <sect2>
    <title><filename>/etc/mail/sendmail.cf</filename></title>

    <para><application>sendmail</application>的主配置文件
      <filename>sendmail.cf</filename> 控制着
      <application>sendmail</application> 的所有行为，
      包括从重写邮件地址到打印拒绝远程邮件服务器信息等所有事。
      当然，作为一个不同的角色，这个配置文件是相当复杂的，
      它的细节部分已经超出了本节的范围。幸运的是，
      这个文件对于标准的邮件服务器来说很少需要被改动。</para>

    <para><application>sendmail</application> 主配置文件可以用
      &man.m4.1; 宏定义 <application>sendmail</application>
      的特性和行为。它的细节请看
      <filename>/usr/src/contrib/sendmail/cf/README</filename>。</para>

    <para>当这个文件被修改时，
      <application>sendmail</application> 必须重新启动以便对新修改生效。</para>

  </sect2>
  <sect2>
    <title><filename>/etc/mail/virtusertable</filename></title>

    <para><filename>virtusertable</filename> 映射虚拟域名和邮箱到真实的邮箱。
      这些邮箱可以是本地的、远程的、<filename>/etc/mail/aliases</filename>
      中定义的别名或一个文件。</para>

    <example>
	<title>虚拟域邮件映射的例子</title>

    <programlisting>root@example.com                root
postmaster@example.com          postmaster@noc.example.net
@example.com                    joe</programlisting>
      </example>

    <para>在上面这个例子里，我们映射了一个域
      <hostid role="domainname">example.com</hostid>。
      这个文件用一个最初匹配的文件处理。第一项映射
      <literal>root@example.com</literal> 到本地邮箱
      <username>root</username>。下一项映射
      <literal>postmaster@example.com</literal> 到
      <hostid role="fqdn">noc.example.net</hostid> 主机的
      <username>postmaster</username> 邮箱。最后，如果域
      <hostid role="domainname">example.com</hostid>
      没有被什么匹配，它将与最后一个映射匹配，在
      <hostid role="domainname">example.com</hostid>
      域，每个其它邮件信息地址到某一个主机被匹配。
      在这里被映射到本地邮箱 <username>joe</username>。</para>

  </sect2>
  </sect1>

  <sect1 id="mail-changingmta">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Andrew</firstname>
          <surname>Boothman</surname>
          <contrib>Written by </contrib>
        </author>
      </authorgroup>
      <authorgroup>
        <author>
          <firstname>Gregory</firstname>
          <surname>Neil Shapiro</surname>
          <contrib>Information taken from e-mails written by </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>改变您的邮件传输代理程序</title>
    <indexterm>
      <primary>邮件</primary>
      <secondary>改变mta</secondary>
    </indexterm>

    <para>先前已经提到，FreeBSD 中的
      <application>sendmail</application> 已经安装了您的
      MTA (邮件传输代理程序)。因此它它负责着您的收发邮件的工作。</para>

    <para>然而，基于不同的理由，一些系统管理员想要改变他们系统的
      MTA。这些理由从简单的想要尝试另一个 MTA，到需要一个特殊的特性或者
      package 依赖某个邮寄程序等等。幸运的是，不管是什么理由，FreeBSD
      都能容易的改变它。</para>

    <sect2>
      <title>安装一个新的 MTA</title>

      <para>对于可用的 MTA 您有很多的选择。一个好的出发点是
	<link linkend="ports">FreeBSD Ports Collection</link>，在那里您能找到很多。
	当然您可以从任何位置不受任何限制的使用 MTA，只要您能让它运行在
	FreeBSD 下。</para>

      <para>开始安装您的新 MTA。一旦它被安装，
	它可以让您有机会决定它是否能满足您的需要和在接管
	<application>sendmail</application> 之前让您有机会配置您的新软件。
	当完成这些之后，您应该确信安装的新软件不会尝试更改系统的二进制文件例如象
	<filename>/usr/bin/sendmail</filename>。除此以外，
	您的新邮件软件启用之前要已经配置好它。</para>

      <para>具体配置请参考您所选择的 MTA 软件的配置文档或其它相关资料。</para>
    </sect2>

    <sect2>
      <title>停用 <application>sendmail</application></title>

      <para>值得注意的是启动
	<application>sendmail</application> 在 4.5-RELEASE 版本和
	4.6-RELEASE 版本之间有些不同。因此，停用它的过程也稍有不同。</para>

      <sect3>
	<title>FreeBSD 4.5-STABLE 版本 2002/4/4 之前和更早前版本
	  (包括 4.5-RELEASE 及更早版本)</title>

	<para>输入：</para>

	  <programlisting>sendmail_enable="NO"</programlisting>

	  <para>到 <filename>/etc/rc.conf</filename> 文件。它将停用
	  <application>sendmail</application> 接收邮件服务，
	  但是如果 <filename>/etc/mail/mailer.conf</filename> 文件(见下文)
	  没有被改变，<application>sendmail</application> 将仍然可以发送邮件。</para>
      </sect3>

      <sect3>
	<title>FreeBSD 4.5-STABLE 版本 2002/4/4 之后和以后的版本
	  (包括 4.6-RELEASE 及后续版本)</title>

	<para>为了完全的停用
	  <application>sendmail</application>，您必须在
	  <filename>/etc/rc.conf</filename> 文件里使用</para>

	  <programlisting>sendmail_enable="NONE"</programlisting>

	<warning>
	  <para>如果用这个方法停止 <application>sendmail</application>
	    的发送邮件服务，那么就必须有一个能够完全正常地工作的邮件发送系统。
	    如果不这样做的话，类似 &man.periodic.8;
	    这样的系统功能将无法正确地通过电子邮件将它们的执行结果送到通常希望的地方去。
	    系统中的很多部分都要求有和
	    <application>sendmail</application> 在功能上兼容的系统。
	    如果应用程序在您禁用之后仍然继续使用
	    <application>sendmail</application> 的执行文件来发送文件，
	    则这些邮件可能会进入睡眠的
	    <application>sendmail</application> 队列，并永远无法到达目的地。</para>
	</warning>

	<para>如果只是想要停止
	  <application>sendmail</application> 的接收邮件服务，
	  您应该在 <filename>/etc/rc.conf</filename> 文件中设置</para>

	  <programlisting>sendmail_enable="NO"</programlisting>

	<para>更多的有关
	  <application>sendmail</application> 可用的启动选项，参看
	  &man.rc.sendmail.8; 联机手册.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>机器引导时运行您的新 MTA</title>

      <para>您也许有两种方法在机器引导时运行您的新
	MTA，这个也倚赖您所运行的 FreeBSD 版本。</para>

      <sect3>
	<title>FreeBSD 4.5-STABLE 版本 2002/4/11 以前
	  (包括 4.5-RELEASE 及更早版本)</title>

	<para>在 <filename>/usr/local/etc/rc.d/</filename>
	  中添加一个以 <filename>.sh</filename> 为后缀的脚本文件，
	  并可以用 <username>root</username> 身份运行。这个脚本应该接受
	  <literal>start</literal> 和 <literal>stop</literal>
	  参数。用如下命令启动这个脚本</para>

	<programlisting>/usr/local/etc/rc.d/supermailer.sh start</programlisting>

	<para>您也可以手工启动这个服务。如果想要停止它，
	  系统脚本将使用 <literal>stop</literal> 选项，运行如下命令</para>

	<programlisting>/usr/local/etc/rc.d/supermailer.sh stop</programlisting>

	<para>您也可以手工停止正在系统运行的服务。</para>

      </sect3>

      <sect3>
	<title>FreeBSD 4.5-STABLE 版本 2002/4/11 以后
	  (包括 4.6-RELEASE 及后续版本)</title>

	<para>在 FreeBSD 较后来的版本，
	  您可以使用上面的方法或者在 <filename>/etc/rc.conf</filename>
	  文件做如下设置</para>

	<programlisting>mta_start_script="filename"</programlisting>

	<para><replaceable>filename</replaceable> 是您想要在引导时执行的
	  MTA 脚本文件的名字。</para>
      </sect3>

    </sect2>

    <sect2>
      <title>替换系统默认的邮寄程序 <application>sendmail</application></title>

      <para>因为 <application>sendmail</application> 程序是一个在
	&unix; 系统下普遍存在的一个标准的软件，一些软件就假定它已经被安装并且配置好。
	基于这个原因，许多其它的 MTA 提供者都提供了兼容
	<application>sendmail</application> 的命令行界面来执行。
	这使它们象<quote>混入</quote><application>sendmail</application>
	一样变的很容易掌握。</para>

      <para>因此，如果您使用其它的邮寄程序，
	您必须确定这个软件是去尝试运行标准的
	<application>sendmail</application> 二进制，就象
	<filename>/usr/bin/sendmail</filename>，还是运行您自己选择的替换邮寄程序。
	幸运的是，FreeBSD 提供了一个系统调用
	&man.mailwrapper.8;，它能为您做这件工作。</para>

      <para>当 <application>sendmail</application> 安装后被运行，您可以在
	<filename>/etc/mail/mailer.conf</filename> 中找到如下行：</para>

<programlisting>sendmail	 /usr/libexec/sendmail/sendmail
send-mail	/usr/libexec/sendmail/sendmail
mailq		/usr/libexec/sendmail/sendmail
newaliases	/usr/libexec/sendmail/sendmail
hoststat	/usr/libexec/sendmail/sendmail
purgestat	/usr/libexec/sendmail/sendmail</programlisting>

      <para>这个的意思就是当这些公共命令
	(例如 <filename>sendmail</filename> 它本身) 运行时，
	系统实际上调用了一个 <filename>sendmail</filename> 指定的
	mailwrapper 的副本，它检查 <filename>mailer.conf</filename>
	并且运行 <filename>/usr/libexec/sendmail/sendmail</filename>
	做为替代。当默认的 <filename>sendmail</filename> 功能被调用，
	系统将很容易的改变实际上运行的二进制文件。</para>

      <para>因此如果您想要
	<filename>/usr/local/supermailer/bin/sendmail-compat</filename>
	替换 <application>sendmail</application> 被运行，您应该改变
	<filename>/etc/mail/mailer.conf</filename> 文件为：</para>

<programlisting>sendmail	 /usr/local/supermailer/bin/sendmail-compat
send-mail	/usr/local/supermailer/bin/sendmail-compat
mailq		/usr/local/supermailer/bin/mailq-compat
newaliases	/usr/local/supermailer/bin/newaliases-compat
hoststat	/usr/local/supermailer/bin/hoststat-compat
purgestat	/usr/local/supermailer/bin/purgestat-compat</programlisting>

	</sect2>

	<sect2>
	  <title>最后</title>

	<para>一旦做完您想要配置的每件事，您应该杀掉
	  <application>sendmail</application> 进程并且启动属于您的新软件的进程，
	  或者简单的重启。重启也将给您机会保证您正确的配置您的系统，
	  在引导的时候自动的运行您新的 MTA。</para>

      </sect2>
    </sect1>

  <sect1 id="mail-trouble">
	<title>疑难解答</title>
	<indexterm>
	  <primary>邮件</primary>
	  <secondary>疑难解答</secondary>
	</indexterm>

	<qandaset>
	  <qandaentry>
		<question>
	<para>为什么必须在我的站点的主机上使用 FQDN？</para>
	</question>

	<answer>
	<para>您可能会发现主机实际上是在另外一个域里面，
	  例如，如果您是在
	  <hostid role="fqdn">foo.bar.edu</hostid> 里，而您要找一台叫
	  <hostid>mumble</hostid> 的主机，它在
	  <hostid role="domainname">bar.edu</hostid> 域里，您就必须用完整的域名
	  <hostid role="fqdn">mumble.bar.edu</hostid>，而不是用
	  <hostid>mumble</hostid>。</para>

	<indexterm><primary>BIND</primary></indexterm>
	<para>传统上，这在 BSD BIND resolvers 中是可行的。
	  然而目前随 FreeBSD 附带的 <application>BIND</application>
	  已不为同一域外提供缩写服务。所以，这个不完整的主机名
	  <hostid>mumble</hostid> 必须以 <hostid
	  role="fqdn">mumble.foo.bar.edu</hostid> 这种形式才能被找到，
	  或者将在根域中搜索它。</para>

	<para>这跟以前的处理是不同的，以前版本将会继续寻找
	  <hostid role="domainname">mumble.bar.edu</hostid> 和
	  <hostid role="domainname">mumble.edu</hostid>。
	  如果您想要了解这种方式是否是好，或者它有什么安全方面的漏洞，
	  请参阅 RFC 1535 文档。</para>

	<para>如果您想要一个好的工作环境，您可以使用如下行：

          <programlisting>search foo.bar.edu bar.edu</programlisting>

          替换先前旧的版本：

          <programlisting>domain foo.bar.edu</programlisting>

          把这行放在您的 <filename>/etc/resolv.conf</filename>
	  文件中。然而，请一定要确定这样的搜寻顺序不会造成 RFC 1535
	  里提到的<quote>boundary between local and public administration</quote>
	  问题。</para>
	</answer>
	  </qandaentry>

      <indexterm>
	<primary>MX record</primary>
      </indexterm>

      <qandaentry>
	<question>
	<para><application>sendmail</application> 提示信息 <errorname>mail
	  loops back to myself</errorname></para>
	</question>

	<answer>
	<para>下面是
	<application>sendmail</application> FAQ 中的回答：</para>

        <programlisting>我得到了如下的信息：

553 MX list for domain.net points back to relay.domain.net
554 &lt;user@domain.net&gt;... Local configuration error

我如何解决这个问题？

您已经通过 MX 记录指定把发送给特定的域 (例如，domain.net)
的邮件被转寄到指定的主机 (在这个例子中，relay.domain.net)，
而这台机器并不认为它自己是 domain.net。请把 domain.net 添加到
/etc/mail/local-host-names 文件中 [在 8.10 版之前是 /etc/sendmail.cw]
(如果您使用 FEATURE(use_cw_file) 的话) 或者在 /etc/mail/sendmail.cf
中添加<quote>Cw domain.net</quote>。</programlisting>

        <para><application>sendmail</application> 的 FAQ 可以在
	  <ulink url="http://www.sendmail.org/faq/"></ulink> 找到，
	  如果您想要对您的邮件做任何的<quote>调整</quote>，
	  则推荐首先看一看它。</para>
	</answer>
      </qandaentry>

      <indexterm><primary>PPP</primary></indexterm>
      <qandaentry>
        <question>
	<para>我如何在一个拨号主机上运行一个邮件服务？</para>
	</question>

	<answer>
	<para>您想要把局域网上的 FreeBSD 主机连接到互连网上，而这台
	  FreeBSD 主机将会成为这个局域网的邮件网关，
	  这个拨号连接不必一直保持在连接状态。</para>

	<indexterm><primary>UUCP</primary></indexterm>
	<indexterm>
	  <primary>MX record</primary>
	</indexterm>

	<para>最少有两种方法可以满足您的要求。一种方法就是使用 UUCP。</para>

	<para>另一种方法是找到一个专职的服务器来为您的域提供副 MX 主机服务。
	  例如，如果您公司的域名是
	  <hostid role="domainname">example.com</hostid>，您的互连网服务提供者把
	  <hostid role="domainname">example.net</hostid> 作为您域的副 MX 服务：</para>

	<programlisting>example.com.          MX        10      example.com.
                      MX        20      example.net.</programlisting>

	<para>只有一台主机被指定当做您的最终收信主机
	  (在 <hostid role="domainname">example.com</hostid> 主机的
	  <filename>/etc/mail/sendmail.cf</filename> 文件中添加
	  <literal>Cw example.com</literal>)。</para>

	<para>当 <command>sendmail</command> 试图分发邮件的时候，
	  它会尝试通过 modem 连接到您 (<hostid role="domainname">example.com</hostid>)。
	  因为您并不在线，所以总是会得到一个超时的错误。
	  <application>sendmail</application> 将会把邮件发送到副
	  MX 主机，也就是说，您的互连网服务提供者
	  (<hostid role="domainname">example.net</hostid>)。副
	  MX 主机将周期性的尝试连接并发送邮件到您的主机
	  (<hostid role="domainname">example.com</hostid>)。</para>

	<para>您也许想要使用下面的这个登录脚本：</para>

	<programlisting>#!/bin/sh
# Put me in /usr/local/bin/pppmyisp
( sleep 60 ; /usr/sbin/sendmail -q ) &amp;
/usr/sbin/ppp -direct pppmyisp</programlisting>

	<para>如果您想要为一个用户建立一个分开登录的脚本，
	  您可以使用 <command>sendmail -qRexample.com</command>
	  替换上面的脚本。这样将使所有的邮件按照您的
	  <hostid role="domainname">example.com</hostid>
	  队列立即被处理。</para>

	<para>更深入的方法可以参考下面这段：</para>

	<para>这段信息是从 &a.isp; 拿来的。</para>

	<programlisting>&gt; 我们为用户提供副 MX 主机服务。用户每天都会上线好几次
&gt; 并且自动把信件取回主 MX 主机
&gt; (当有他们的邮件时我们并没有通知他们)。
&gt; 我们的 mailqueue 程序每 30 分钟清一次邮件队列。那段时间他们
&gt; 就必须上线 30 分钟以确保他们的信件送达他们的主 MX 主机。
&gt;
&gt; 有任何指令可以用 sendmail 寄出所有邮件么？
&gt; 普通用户在我们的机器上当然没有 root 权限。

在 sendmail.cf 的<quote>privacy flags</quote>部分，有这样的设定
Opgoaway,restrictqrun

移除 restrictqrun 可以让非 root 用户启动队列处理的程序。
您可能也要重新安排您的 MX 设定。我们是用户的 MX 主机，
而且我们还设定了这个：

# If we are the best MX for a host, try directly instead of generating # local config error.
OwTrue

这样的话远程机器会直接把信送给您，而不会尝试连接您的用户的机器。
然后您就可以把邮件发送到您的用户。这个设定只对
<quote>主机</quote>有效，所以您必须要让您的用户在 DNS 中把他们的邮件主机设置为
<quote>customer.com</quote>或者
<quote>hostname.customer.com</quote>。只要为<quote>customer.com</quote>在 DNS
里添加一个 A 记录就可以了。</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
	  <para>为什么当我发送邮件到其它主机总是有 <errorname>Relaying
	    Denied</errorname> 出错信息？</para>
	</question>

	<answer>
	  <para>默认的 FreeBSD 安装中，
 	    <application>sendmail</application> 会配置为只发送来自它所在主机上的邮件。
 	    例如，如果有可用的 <acronym>POP</acronym> 服务器，则用户将可以从学校、
 	    公司或其他什么别的地方检查邮件，但他们仍然无法从远程直接发送邮件。
	    通常，在几次尝试之后，
	    <application>MAILER-DAEMON</application> 将发出一封包含
	    <errorname>5.7 Relaying Denied</errorname> 错误信息的邮件。</para>

	  <para>有很多方法可以避免这种现象。
 	    最直截了当的方法是把您的 ISP 的地址放到
	    <filename>/etc/mail/relay-domains</filename> 文件中。
 	    完成这项工作的简单的方法是：</para>

	  <screen>&prompt.root; <userinput>echo "your.isp.example.com" &gt; /etc/mail/relay-domains</userinput></screen>

	  <para>建立或编辑这个文件以后您必须重新启动
	    <application>sendmail</application>。
	    如果您是一个管理员并且不希望在本地发送邮件，
	    或者想要在其它的机器甚至其它的 ISP 上使用一个客户端系统，
	    这个方法是很方便的。如果您仅有一到两个邮件帐户它也非常的有用。
	    如果有大量的地址需要添加，
	    您可以很简单的使用您喜欢的文本编辑器打开这个文件添加域名，
	    每行一个：</para>

	  <programlisting>your.isp.example.com
other.isp.example.net
users-isp.example.org
www.example.org</programlisting>

	  <para>现在邮件可以通过您的系统传送，
	    这个列表中存在的主机 (前提是用户在您的系统上已经有一个帐户)
	    将可以成功的发送。这是一个允许正常的远程用户从您的系统发送邮件，
	    并且阻止其它非法用户通过您系统发送垃圾邮件的好方法。</para>

	</answer>
	  </qandaentry>
	</qandaset>
  </sect1>

  <sect1 id="mail-advanced">
	<title>高级主题</title>

	<para>下面这节将介绍邮件配置和为整个域安装邮件。</para>

	<sect2 id="mail-config">
	  <title>基本配置</title>
	  <indexterm>
		<primary>邮件</primary>
		<secondary>配置</secondary>
	  </indexterm>

	  <para>在邮箱外，只要您设置 <filename>/etc/resolv.conf</filename>
	    或者运行您自己的名字服务器，您就可以发送邮件到外部的主机。
	    如果您想要您的邮件发送给某个特定的 MTA(例如，
	    <application>sendmail</application>) 在您的 FreeBSD
	    主机上，有两个方法：</para>

	  <itemizedlist>
		<listitem>
		  <para>运行您自己的域名服务器和您自己的域。例如，
		  <hostid role="domainname">FreeBSD.org</hostid></para>
		</listitem>

		<listitem>
		  <para>获得直接分发给您主机的邮件。您可以直接使用您当前的
		DNS 名称。例如，<hostid
		role="fqdn">example.FreeBSD.org</hostid>。</para>
		</listitem>
	  </itemizedlist>

	  <indexterm><primary>SMTP</primary></indexterm>
	  <para>不管您选择上面那种方法，为了直接在您的主机上发送邮件，
	    必须有一个静态的 IP 地址(不是象 PPP 拨号一样的动态地址)。
	    如果您在防火墙后面，它必须让 SMTP 协议通过。
	    如果您想要在您的主机上直接的收取邮件，
	    您必须确定两件事：</para>

	  <itemizedlist>
		<indexterm><primary>MX 记录</primary></indexterm>
		<listitem>
		  <para>确定在您 DNS 中的 MX 记录(最小编号的)指向您的 IP 地址。</para>
		</listitem>

		<listitem>
		  <para>确定在您 DNS 中的 MX 记录没有禁止您的主机。</para>
		</listitem>
	  </itemizedlist>

	  <para>上面的每条记录都允许您在您的主机直接接收邮件。</para>

	  <para>试试这个：</para>

      <screen>&prompt.root; <userinput>hostname</userinput>
example.FreeBSD.org
&prompt.root; <userinput>host example.FreeBSD.org</userinput>
example.FreeBSD.org has address 204.216.27.XX</screen>

      <para>如果您看到这些，直接使用
	<email>yourlogin@example.FreeBSD.org</email> 应该没有问题
	(假定 <application>sendmail</application> 已经
	正确的运行在 <hostid role="fqdn">example.FreeBSD.org</hostid>)。</para>

      <para>如果您看到这些：</para>

      <screen>&prompt.root; <userinput>host example.FreeBSD.org</userinput>
example.FreeBSD.org has address 204.216.27.XX
example.FreeBSD.org mail is handled (pri=10) by hub.FreeBSD.org</screen>

      <para>所有发送到主机 (<hostid
	role="fqdn">example.FreeBSD.org</hostid>) 的邮件在相同的用户名下将会被
	<hostid>hub</hostid> 终止的收集，而不是直接发送到您的主机。</para>

      <para>上面的信息是通过您的 DNS 服务器来处理的。支持邮件路由信息的 DNS
	记录是 <emphasis>邮件</emphasis> <emphasis>交换</emphasis> 记录。如果
	MX 记录不存在，邮件将通过它自己的 IP 地址被直接的发送到主机。</para>

      <para><hostid
	role="fqdn">freefall.FreeBSD.org</hostid>的MX记录如下所示:</para>

      <programlisting>freefall		MX	30	mail.crl.net
freefall		MX	40	agora.rdrop.com
freefall		MX	10	freefall.FreeBSD.org
freefall		MX	20	who.cdrom.com</programlisting>

      <para>正如您说看到的，<hostid>freefall</hostid> 有很多 MX 记录。
	最小编号的 MX 记录是直接接收邮件的主机。如果因为一些原因它不可用，其它
	(有时会访问<quote>backup MXes</quote>)接收信息将会暂时接替并做临时的排列。</para>

      <para>为了有效的使用交换式 MX 站点，应当从您的机器上分离一些
	Internet 连接。您的 ISP 或者其它友好的站点可以没有任何问题的为您提供这个服务。</para>
    </sect2>

    <sect2 id="mail-domain">
      <title>Mail for Your Domain</title>

      <para>为了设置一个<quote>邮件主机</quote>(又称邮件服务器)
	您必须要把许多邮件发送到与它相连的几个工作站中。
	基本上，您想要<quote>要求</quote>在您域的每个主机的所有邮件
	(在这个例子里是 <hostid role="fqdn">*.FreeBSD.org</hostid>)
	转向到您的邮件服务器，从而使您的用户可以在主邮件服务器里接收他们的邮件。</para>

      <indexterm><primary>DNS</primary></indexterm>
      <para>要使工作最简单，带有同样
	<emphasis>用户名</emphasis> 的帐户应该同时存在于两台机器上。使用
	&man.adduser.8; 来这样做。</para>

      <para>您将使用的邮件主机必须为每个工作站指定一个邮件交换。您可以在
	DNS 中这样配置：</para>

      <programlisting>example.FreeBSD.org	A	204.216.27.XX		; Workstation
			MX	10 hub.FreeBSD.org	; Mailhost</programlisting>

      <para>无论 A 记录指向哪，这将为工作站重新定位到邮件主机。邮件将被发送到 MX
	主机。</para>

      <para>您不能自己这样做除非您运行着一个 DNS 服务器。
	如果不是这样，或者不能运行您自己的 DNS 服务器，告诉您的 ISP
	或者给您提供 DNS 服务的人。</para>

      <para>如果您正在使用虚拟邮件主机，下面的信息将会对您有用。
	在这个例子里，我们假定您有一个客户并且他有自己的域，
	这个例子中是 <hostid role="domainname">customer1.org</hostid>，您要把
	<hostid role="domainname">customer1.org</hostid>
	所有的邮件发送到您的邮件主机 <hostid role="fqdn">mail.myhost.com</hostid>。
	您的 DNS 记录应该是这样：</para>

      <programlisting>customer1.org		MX	10	mail.myhost.com</programlisting>

      <para>您 <emphasis>不</emphasis> 需要有个 A 记录，
	如果您只为域 <hostid role="domainname">customer1.org</hostid>
	处理邮件。</para>

      <note>
	<para>必须清楚 <hostid role="domainname">customer1.org</hostid>
	  将不能工作，除非存在一个 A 记录。</para>
      </note>

      <para>最后一件您必须要做的事是告诉
	<application>sendmail</application> 接受邮件的是什么域和(或)主机名。
	这里有好几种方法。下面方法可以任选一种：</para>

      <itemizedlist>
	<listitem>
	  <para>添加您的主机到
	    <filename>/etc/mail/local-host-names</filename> 文件中，如果您使用的是
	    <literal>FEATURE(use_cw_file)</literal>。如果您使用
	    <application>sendmail</application> 8.10 或者更高版本，文件是
	    <filename>/etc/sendmail.cw</filename>。</para>
	</listitem>

	<listitem>
	  <para>添加一行 <literal>Cwyour.host.com</literal> 到您的
	    <filename>/etc/sendmail.cf</filename> 或
	    <filename>/etc/mail/sendmail.cf</filename> 文件，如果您使用
	    <application>sendmail</application> 8.10 或者更高版本。</para>
	</listitem>
	  </itemizedlist>
	</sect2>
  </sect1>

  <sect1 id="SMTP-UUCP">
  <title>SMTP 与 UUCP</title>

    <para><application>sendmail</application> 的配置，在
      FreeBSD 中已经配置好为您的站点直接的连接 Internet。
      如果站点希望他们的邮件通过 UUCP 交换，则必须安装其它的
      <application>sendmail</application> 配置文件。</para>

    <para>手工的配置 <filename>/etc/mail/sendmail.cf</filename>
      是一个高级主题。<application>sendmail</application> 8 版本通过
      &man.m4.1; 预处理生成一个配置文件，实际上这个配置发生在一个比较高的抽象层。
      &man.m4.1; 配置文件可以在 <filename>/usr/src/usr.sbin/sendmail/cf</filename>
      下找到。</para>

    <para>如果您没有在系统上安装全部源码，则可以从单独的压缩文件中提取
      sendmail 配置文件。假定您的 FreeBSD 源码 CDROM 已经被 mount：</para>

    <screen>&prompt.root; <userinput>cd /cdrom/src</userinput>
&prompt.root; <userinput>cat scontrib.?? | tar xzf - -C /usr/src/contrib/sendmail</userinput></screen>

    <para>这个提取只有几百 K 字节。<filename>cf</filename>
      目录中的 <filename>README</filename> 文件能够为您提供一个到
      &man.m4.1; 配置的基本的介绍。</para>

    <para>最好的支持 UUCP 传送的方法是使用
      <literal>mailertable</literal> 的特点。建立一个资料库让
      <application>sendmail</application> 可以使用它自己的路由决策。</para>

    <para>首先，您必须建立您自己的 <filename>.mc</filename> 文件。
      <filename>/usr/src/usr.sbin/sendmail/cf/cf</filename> 目录包含一些例子。
      假定您已经命名自己的文件叫做 <filename>foo.mc</filename>，
      您要做的只是把它转换成一个有效的 <filename>sendmail.cf</filename>：</para>

    <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/sendmail/cf/cf</userinput>
&prompt.root; <userinput>make foo.cf</userinput>
&prompt.root; <userinput>cp foo.cf /etc/mail/sendmail.cf</userinput></screen>

    <para>一个典型的 <filename>.mc</filename> 文件看起来可能象这样：</para>

    <programlisting>VERSIONID(`<replaceable>Your version number</replaceable>') OSTYPE(bsd4.4)

FEATURE(accept_unresolvable_domains)
FEATURE(nocanonify)
FEATURE(mailertable, `hash -o /etc/mail/mailertable')

define(`UUCP_RELAY', <replaceable>your.uucp.relay</replaceable>)
define(`UUCP_MAX_SIZE', 200000)
define(`confDONT_PROBE_INTERFACES')

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    <replaceable>your.alias.host.name</replaceable>
Cw    <replaceable>youruucpnodename.UUCP</replaceable></programlisting>

    <para>
      <literal>accept_unresolvable_domains</literal>、
      <literal>nocanonify</literal> 和 <literal>confDONT_PROBE_INTERFACES</literal>
      特性将避免在传送邮件时使用DNS的机会。<literal>UUCP_RELAY</literal>
      项是支持 UUCP 传送所必须的。简单的放入一个 Internet 上可以处理
      UUCP 虚拟域地址的主机名。通常，您在这里填入您 ISP 邮件的回复处。</para>

    <para>一旦您做完这些，您还需要这个
      <filename>/etc/mail/mailertable</filename> 文件。
      如果您只有一个用来传递所有邮件的对外通道的话，
      以下的文件就足够了：</para>

    <programlisting>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
.                             uucp-dom:<replaceable>your.uucp.relay</replaceable></programlisting>

	<para>一个更复杂点的例子象这样：</para>

    <programlisting>#
# makemap hash /etc/mail/mailertable.db &lt; /etc/mail/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</programlisting>


    <para>头三行处理域地址邮件，不应该被传送出默认的路由，
      而由某些 UUCP 邻居取代的特殊情况，这是为了走<quote>捷径</quote>。
      下一行处理本地网的邮件让它可以使用 SMTP 来传送。
      最后，UUCP 邻居提起。UUCP 虚拟域的记载，
      允许一个 <literal><replaceable>uucp-neighbor
      </replaceable>!<replaceable>recipient</replaceable></literal>
      推翻默认规则。最后一行则以一个单独的句点最为结束，
      以 UUCP 传送到提供您所有的邮件网关的 UUCP 邻居。
      所有在 <literal>uucp-dom:</literal> 关键字里的节点名称必须是有效的
      UUCP 邻居，您可以用 <literal>uuname</literal> 去确认。</para>

    <para>提醒您这个文件在使用前必须被转换成 DBM 数据库文件。最好在
      <filename>mailertable</filename> 最上面用注解写出命令行来完成这个工作。
      当您每次更换您的 <filename>mailertable</filename> 后您总是需要执行这个命令。</para>

    <para>最后提示：如果您不确定某个特定的路径可用，
      记得把 <option>-bt</option> 选项加到
      <application>sendmail</application>。这会将
      <application>sendmail</application> 启动在
      <emphasis>地址检测模式</emphasis>。只要按下
      <literal>3,0</literal>，接着输入您希望测试的邮件路径位置。
      最后一行告诉您使用邮件代理程序，
      代理程序会通知目的主机以及 (可能转换) 地址。
      要离开此模式请按 <keycombo
      action="simul"><keycap>Ctrl</keycap><keycap>D</keycap></keycombo>。</para>

    <screen>&prompt.user; <userinput>sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
<prompt>&gt;</prompt> <userinput>3,0 foo@example.com</userinput>
canonify           input: foo @ example . com
...
parse            returns: $# uucp-dom $@ <replaceable>your.uucp.relay</replaceable> $: foo &lt; @ example . com . &gt;
<prompt>&gt;</prompt> <userinput>^D</userinput></screen>
  </sect1>

  <sect1 id="outgoing-only">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Bill</firstname>
          <surname>Moran</surname>
          <contrib>Contributed by </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Setting Up to Send Only ** 翻译进行中 **</title>

    <para></para>
  </sect1>

  <sect1 id="SMTP-dialup">
    <title>拨号连接时使用邮件传送</title>

    <para>如果您有静态的 IP 地址， 就应该不用修改任何默认的配置。
      将主机名设置为分配给您的 Internet 名称，其他的事情
      <application>sendmail</application> 都会替您做好。</para>

    <para>如果您的 IP 地址是动态分配的， 并使用 PPP 连接拨入
      Internet， 则您可能会从 ISP 的邮件服务器上得到一个信箱。
      这里我们假设您的 ISP 的域名是
      <hostid role="domainname">example.net</hostid>， 您的用户名是
      <username>user</username>， 您把自己的机器称作
      <hostid role="fqdn">bsd.home</hostid>， 而您的 ISP 告诉您可以使用
      <hostid role="fqdn">relay.example.net</hostid> 来转发邮件。</para>

    <para>为了从邮箱收取邮件， 需要安装一个收信代理。
      <application>fetchmail</application> 是一个能够支持许多种不同协议的不错的选择。
      这个程序可以通过 package 或 ports collection (<filename
      role="package">mail/fetchmail</filename>) 来安装。
      通常， 您的 <acronym>ISP</acronym> 会提供 <acronym>POP</acronym>。
      如果您使用用户 <acronym>PPP</acronym>，您还可以在 Internet 连接建立时自动地抓取邮件，
      这可以通过在
      <filename>/etc/ppp/ppp.linkup</filename> 中增加如下的项来实现：</para>

	<programlisting>MYADDR:
!bg su user -c fetchmail</programlisting>

	<para>如果您正使用<application>sendmail</application> (如下所示)
	  传送邮件到非本地帐户，这会强迫
	  <application>sendmail</application> 在连接网络后马上处理邮件进程队列，它在
	  <filename>/etc/ppp/ppp.linkup</filename> 文件执行
	  <command>fetchmail</command> 命令。</para>

	<programlisting>  !bg su user -c "sendmail -q"</programlisting>

	<para>假设您有一个
	  <username>user</username> 帐户，在 <hostid
	  role="fqdn">bsd.home</hostid>机器上。在 <hostid role="fqdn">bsd.home</hostid>
	  机器上的 <username>user</username> 目录里建立一个
	  <filename>.fetchmailrc</filename>文件：</para>

	<programlisting>poll example.net protocol pop3 fetchall pass MySecret</programlisting>

	<para>这个文件除了 <username>user</username> 外不应该被任何人读取，
	  因为它包含了 <literal>MySecret</literal> 这个密码。</para>

	<para>为了在发信时有正确的抬头
	  <literal>from:</literal>，您必须告诉
	  <application>sendmail</application> 使用
	  <literal>user@example.net</literal> 而非
	  <literal>user@bsd.home</literal>。您可能会希望告诉
	  <application>sendmail</application> 从 <hostid
	  role="fqdn">relay.example.net</hostid> 发送所有邮件，加快邮件的传送。</para>

	<para>以下的 <filename>.mc</filename> 文件应该可以满足您的需求：</para>

    <programlisting>VERSIONID(`bsd.home.mc version 1.0')
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net')dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST', `relay.example.net')
Dmbsd.home
define(`confDOMAIN_NAME',`bsd.home')dnl
define(`confDELIVERY_MODE',`deferred')dnl</programlisting>

	<para>如何转换这个 <filename>.mc</filename> 文件到
	  <filename>sendmail.cf</filename> 文件的细节，请参考前面的章节。
	  另外，在更新 <filename>sendmail.cf</filename> 文件后，
	  不要忘记重启 <application>sendmail</application>。</para>
  </sect1>

  <sect1 id="SMTP-Auth">
    <sect1info>
    <authorgroup>
      <author>
        <firstname>James</firstname>
        <surname>Gorham</surname>
        <contrib>作者：</contrib>
      </author>
    </authorgroup>
    </sect1info>

    <title>SMTP 验证</title>

    <para>在您的邮件服务器上启用 <acronym>SMTP</acronym> 验证有很多好处。
      <acronym>SMTP</acronym> 验证可以让
      <application>sendmail</application> 多一重安全保障，
      而且也使得使用不同机器的漫游用户能够使用同一个邮件服务器，
      而不需要每次都修改它们的邮件客户端配置。</para>

    <procedure>
      <step>
	<para>从 ports 中安装 <filename role="package">security/cyrus-sasl</filename>。
	  您可以从 <filename role="package">security/cyrus-sasl</filename> 找到它。
	  <filename role="package">security/cyrus-sasl</filename> 有一系列编译时可选的选项，
	  包括我们将要使用的验证方式等等。请务必选择
	  <option>pwcheck</option>。</para>
      </step>

      <step>
	<para>安装完 <filename role="package">security/cyrus-sasl</filename> 之后，
	  编辑 <filename>/usr/local/lib/sasl/Sendmail.conf</filename>
	  (如果不存在则建立) 并在其中增加：</para>

	<programlisting>pwcheck_method: passwd</programlisting>

	<para>这个方法将允许<application>sendmail</application>
	  依照您的 FreeBSD <filename>passwd</filename> 数据库进行验证。
	  这将为每个用户建立一个新用户名设置和口令使用
	  <acronym>SMTP</acronym> 验证减少麻烦，并且保证登录和邮件口令是相同的。</para>
      </step>

      <step>
	<para>现在编辑 <filename>/etc/make.conf</filename> 文件，添加如下行：</para>

	<programlisting>SENDMAIL_CFLAGS=-I/usr/local/include/sasl1 -DSASL
SENDMAIL_LDFLAGS=-L/usr/local/lib
SENDMAIL_LDADD=-lsasl</programlisting>

	<para>这些行将给 <application>sendmail</application> 合适的配置选项，
	为在编译时间链接到 <filename role="package">cyrus-sasl</filename>。
	确定 <filename role="package">cyrus-sasl</filename>
	被安装之前重新编译 <application>sendmail</application>。</para>
      </step>

      <step>
	<para>重新编译 <application>sendmail</application> 运行如下命令：</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/sendmail</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make obj</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>

	<para>如果 <filename>/usr/src</filename>
	  和共享库没有大的变化并且它们都必须可用，<application>sendmail</application>
	  编译应该没有任何问题。</para>
      </step>

      <step>
	<para><application>sendmail</application> 被重新编译和安装后，
	  编辑您的 <filename>/etc/mail/freebsd.mc</filename>
	  文件 (或者无论您选择使用的您的哪个 <filename>.mc</filename>
	  文件。许多管理员选择使用跟 &man.hostname.1; 一样的唯一的
	  <filename>.mc</filename> 文件输出)。添加这些行在这个文件：</para>

	<programlisting>dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN')dnl
define(`confAUTH_MECHANISMS', `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN')dnl
define(`confDEF_AUTH_INFO', `/etc/mail/auth-info')dnl</programlisting>

	<para>这些选项配置有不同的方法，对于
	<application>sendmail</application> 验证用户。
	如果您想要使用除
	<application>pwcheck</application> 之外的方法，请参考相关文档。</para>
      </step>

      <step>
	<para>最后，在 <filename>/etc/mail</filename> 运行 &man.make.1;。
	  它将建立您的新 <filename>.mc</filename> 文件并建立一个
	  <filename>.cf</filename> 文件命名为 <filename>freebsd.cf</filename>
	  (或者您想使用您的其它名字的 <filename>.mc</filename>文件)。接着使用命令
	  <command>make install restart</command>，这将复制文件到
	  <filename>sendmail.cf</filename>，并且正确的重新启动
	  <application>sendmail</application>。
	  更多有关这个过程的信息，您可以参考
	  <filename>/etc/mail/Makefile</filename> 文件。</para>
      </step>
    </procedure>

    <para>如果所每个步骤都做对了，
      您应该可以通过您的邮件客户端进入您的登录信息并且传送一个测试信息。
      更多的分析，设置 <application>sendmail</application> 的
      <option>LogLevel</option> 到 13 并且查看 <filename>/var/log/maillog</filename>
      中的信息。</para>

    <para>您也许希望添加如下行到 <filename>/etc/rc.conf</filename> 文件，
      这将允许服务在重起之后自动运行：</para>

    <programlisting>sasl_pwcheck_enable="YES"
sasl_pwcheck_program="/usr/local/sbin/pwcheck"</programlisting>

    <para>这将保证 <acronym>SMTP_AUTH</acronym> 初始化在系统启动时自动运行。</para>

    <para>更多的信息，请参看 <application>sendmail</application>
      相关页<ulink url="http://www.sendmail.org/~ca/email/auth.html">
      <acronym>SMTP</acronym> 验证</ulink>。</para>

  </sect1>

  <sect1 id="mail-agents">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Silver</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Mail User Agents ** 翻译进行中 **</title>

    <indexterm>
      <primary>Mail User Agents ** 翻译进行中 **</primary>
    </indexterm>

    <para></para>

    <sect2 id="mail-command">
      <title>mail ** 翻译进行中 **</title>

      <para></para>
    </sect2>

    <sect2 id="mutt-command">
      <title>mutt ** 翻译进行中 **</title>

      <para></para>
    </sect2>

    <sect2 id="pine-command">
      <title>pine ** 翻译进行中 **</title>

      <para></para>

    </sect2>
  </sect1>

  <sect1 id="mail-fetchmail">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Silver</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Using fetchmail ** 翻译进行中 **</title>

    <indexterm>
      <primary>Using fetchmail</primary>
    </indexterm>

    <para></para>
  </sect1>

  <sect1 id="mail-procmail">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Silver</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Using procmail ** 翻译进行中 **</title>

    <indexterm>
      <primary>Using procmail</primary>
    </indexterm>

    <para></para>
  </sect1>
</chapter>

<!--
	 Local Variables:
	 mode: sgml
	 sgml-declaration: "../chapter.decl"
	 sgml-indent-data: t
	 sgml-omittag: nil
	 sgml-always-quote-attributes: t
	 sgml-parent-document: ("../book.sgml" "part" "chapter")
	 End:
-->
