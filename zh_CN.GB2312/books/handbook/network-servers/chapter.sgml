<!--
     The FreeBSD Documentation Project
     The FreeBSD Simplified Chinese Project

     Original Revision: 1.31
     $FreeBSD$
-->

<chapter id="network-servers">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Murray</firstname>
	<surname>Stokely</surname>
	<contrib>Reorganized by </contrib>
      </author>
    </authorgroup>
    <!-- 23 July 2004 -->
  </chapterinfo>

  <title>网络服务器</title>

  <sect1 id="network-servers-synopsis">
    <title>概要</title>

    <para>本章将覆盖某些在 &unix; 系统上常用的网络服务。话题将会涉及
      如何安装、配置、测试和维护多种不同类型的网络服务。本章节中将提
      供大量配置文件的样例，期望能够对您有所裨益。</para>

    <para>在读完本章之后，您将会知道：</para>

    <itemizedlist>

      <listitem>
	<para>如何管理<application>inetd</application>
	  。</para>
      </listitem>

      <listitem>
	<para>如何设置运行一个网络文件系统。</para>
      </listitem>

      <listitem>
	<para>如何配置一个网络信息服务器以共享用户帐号。</para>
      </listitem>

      <listitem>
	<para>如何通过DHCP自动配置网络。</para>
      </listitem>

      <listitem>
	<para>如何配置一个域名服务器。</para>
      </listitem>

      <listitem>
	<para>如何设置<application>Apache</application> HTTP 服务器。</para>
      </listitem>

      <listitem>
	<para>如何设置文件传输（FTP）服务器。</para>
      </listitem>

      <listitem>
	<para>如何使用<application>Samba</application>为 &windows; 
		客户端设置文件和打印服务。</para>
      </listitem>

      <listitem>
	<para>如何同步时间和日期，以及如何设置使用NTP协议的时间服务器。</para>
      </listitem>

    </itemizedlist>

    <para>在阅读此章节之前，您应当：</para>

    <itemizedlist>
      <listitem>
	<para>理解有关<filename>/etc/rc</filename>中脚本的基本知识。</para>
      </listitem>

      <listitem>
	<para>熟悉基本网络术语。</para>
      </listitem>

      <listitem>
      <para>懂得如何安装额外的第三方软件（<xref linkend="ports">）。</para>
      </listitem>

    </itemizedlist>
  </sect1>

  <sect1 id="network-inetd">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Contributed by </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title> <application>inetd</application> <quote>超级服务器</quote></title>

    <sect2 id="network-inetd-overview">
      <title>总览</title>

      <para>&man.inetd.8; 被称为<quote>Internet
	Super-Server</quote>， 因为它管理几个守护程序的链接。提供网络
	服务的程序被称为守护进程。<application>inetd</application>
  作为一个为其他服务的管理服务器，当一个被<application>inetd</application>
	收到后，它将决定连接将前往哪个程序，然后拉起对应的守护进程，
	并将socket转交过去。 比起来将所有守护进程以stand-alone模式
	运行，运行单个<application>inetd</application>实例可以降低
	系统开销。</para>

      <para>一般说来，<application>inetd</application> 被用来拉起
  其他守护进程，不过有些细碎的协议被直接接管，比如<application>chargen</application>，
	<application>auth</application>，和
	<application>daytime</application>。</para>

      <para>这一部分将通过命令行选项和<filename>/etc/inetd.conf</filename>
  文件来介绍配置<application>inetd</application> 的基础知识。</para>
    </sect2>

    <sect2 id="network-inetd-settings">
      <title>设置</title>

      <para><application>inetd</application> 通过 <filename>/etc/rc.conf</filename>
  系统进行初始化。<literal>inetd_enable</literal> 选项默认被设定为
	<literal>NO</literal>，不过可以通过<application>sysinstall</application>打开，
	如果选用中等安全的模板。在<filename>/etc/rc.conf</filename>中设定:
	<programlisting>inetd_enable="YES"</programlisting> 或
	<programlisting>inetd_enable="NO"</programlisting> 
	可以激活或者禁止<application>inetd</application>在启动时加载。</para>

      <para>此外，可以通过<literal>inetd_flags</literal>把不同的
  命令行参数传给<application>inetd</application>。</para>
  </sect2>

    <sect2 id="network-inetd-cmdline">
      <title>命令行选项</title>

      <para><application>inetd</application> 语法:</para>

      <para><option>     inetd [-d] [-l] [-w] [-W] [-c maximum] [-C rate] [-a address | hostname]
           [-p filename] [-R rate] [configuration file]</option></para>

      <variablelist>
	<varlistentry>
	  <term>-d</term>

	  <listitem>
	    <para>打开调试选项。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-l</term>

	  <listitem>
	    <para>记录成功的连接</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-w</term>

	  <listitem>
	    <para>为外部服务打开TCP Wrapping（默认）。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-W</term>

	  <listitem>
	    <para>为<application>inetd</application>的内置服务打开TCP Wrapping （默认）。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-c maximum</term>

	  <listitem>
	    <para>指定单个服务的最大并发访问数量，默认为不限。
	      也可以在此服务的具体配置里面通过<option>max-child</option>改掉。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-C rate</term>

	  <listitem>
	    <para>指定单个服务一分钟内能被单个IP地址调用的最大次数，
	      默认不限。也可以在此服务的具体配置里面通过<option>max-connections-per-ip-per-minute</option>
	      改掉。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-R rate</term>

	  <listitem>
	    <para>指定单个服务一分钟内能被调用的最大次数，默认为256。
	      设为0 则允许不限次数调用。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-a</term>

	  <listitem>
	    <para>指定绑定的IP地址。此外，可以使用主机名，这样系统就
	      可以根据主机名对应的IPV4或者IPV6来选择绑定地址。通常当
	      <application>inetd</application> 在 &man.jail.8; 中运行
	      的时候指定主机名，这种情况下主机名来自 &man.jail.8; 环
	      境变量</para>

	    <para>当使用主机名方式时，如果IPV4和IPV6都会被绑定到服务，
	      那么，需要在<filename>/etc/inetd.conf</filename>.中为该服务
	      的每个对应协议添加一条记录。比如，一个TCP服务需要两条记录，
	      一条使用<literal>tcp4</literal>，另一条使用<literal>tcp6</literal>。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-p</term>

	  <listitem>
	    <para>指定用来存放进程ID的文件。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>以上选项在<filename>/etc/rc.conf</filename>中将可以
      被<literal>inetd_flags</literal>开关传递给<application>inetd</application>。
	 		默认情况下，<literal>inetd_flags</literal> 被置为
			<literal>-wW</literal>，也既是对<application>inetd</application>的内置或外部服务打开TCP wrapping.
			对于新手，通常不用去动这些参数，就算它们出现在<filename>/etc/rc.conf</filename>里头。</para>

      <note>
	<para>对<application>inetd</application>而言，所谓外部服务是当
		连接请求到来时，被调用并接受连接，启动于inetd之外的守护进程。
		反之，内置服务则是那些<application>inetd</application>自己可
		以完全处理的了。</para>
      </note>

    </sect2>

    <sect2 id="network-inetd-conf">
      <title><filename>inetd.conf</filename></title>

      <para><application>inetd</application>的配置通过
      <filename>/etc/inetd.conf</filename>文件进行控制。</para>

      <para>当
	<filename>/etc/inetd.conf</filename>内容发生改变，可以
	对<application>inetd</application>进程发送一个HangUP信号，以强制
	<application>inetd</application>重新读取配置文件，如下所示：</para>

      <example id="network-inetd-hangup">
	<title>对 <application>inetd</application>发送HangUP信号</title>

	<screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
      </example>

      <para>配置文件中的每一行都是一个独立服务。如果要注释掉该服务，可以在行首加上
	<quote>#</quote>。<filename>/etc/inetd.conf</filename>的格式如下：</para>

      <programlisting>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]
user[:group][/login-class]
server-program
server-program-arguments</programlisting>

      <para><application>ftpd</application>使用IPv4的例子：</para>

      <programlisting>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</programlisting>

      <variablelist>
	<varlistentry>
	  <term>service-name</term>

	  <listitem>
	    <para>指明各个服务的服务名。其服务名必须与<filename>/etc/services</filename>中列出的一致。
	      这将决定<application>inetd</application>会监听哪个port。
	      一旦有新的服务需要添加，必须先在<filename>/etc/services</filename>里面添加。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>socket-type</term>

	  <listitem>
	    <para>可以是<literal>stream</literal>、<literal>dgram</literal>、<literal>raw</literal>或者
	      <literal>seqpacket</literal>。 <literal>stream</literal>
	      用在基于连接的，TCP 服务；而<literal>dgram</literal>被用于服务用于<acronym>UDP</acronym>传输协议。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>protocol</term>

	  <listitem>
	    <para>下列之一：</para>

	    <informaltable frame="none">
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry>协议</entry>
		    <entry>说明</entry>
		  </row>
		</thead>
		<tbody>
		  <row>
		    <entry>tcp， tcp4</entry>
		    <entry>TCP IPv4</entry>
		  </row>
		  <row>
		    <entry>udp， udp4</entry>
		    <entry>UDP IPv4</entry>
		  </row>
		  <row>
		    <entry>tcp6</entry>
		    <entry>TCP IPv6</entry>
		  </row>
		  <row>
		    <entry>udp6</entry>
		    <entry>UDP IPv6</entry>
		  </row>
		  <row>
		    <entry>tcp46</entry>
		    <entry>Both TCP IPv4 and v6</entry>
		  </row>
		  <row>
		    <entry>udp46</entry>
		    <entry>Both UDP IPv4 and v6</entry>
		  </row>
		</tbody>
	      </tgroup>
	    </informaltable>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]</term>

	  <listitem>
	    <para><option>wait|nowait</option> 指明从<application>inetd</application>
	    	里头调用的服务是否可以自己处理socket.
	      <option>dgram</option>socket类型必须使用<option>wait</option>，
	      而stream socket daemons， 由于通常使用多线程方式，应当使用
	      <option>nowait</option>.  <option>wait</option> 通常usually
	      把多个socket丢给单个服务进程， 而<option>nowait</option> 则
	      会为每个新的socket生成一个子进程。</para>

	    <para>使用<option>max-child</option>选项可以设定针对服务，
	      <application>inetd</application>可以派生出来的最大子进程数量。
	      如果某特定服务需要限定最高10个实例，把<literal>/10</literal>
	      放到<option>nowait</option>后头就可以了。</para>

	    <para>在<option>max-child</option>之外，还有一个开关可以限制
	      来自同一个地方，针对某个服务的最大连接数。这个开关就是：
	      <option>max-connections-per-ip-per-minute</option>。
	      比如，设定该值为10就可以限定单个IP地址去向某服务的连接最大
	      为每分钟十个。这个对于防止有意或者无意的资源耗尽或者拒绝服
	      务（DoS）颇有用处。</para>

	    <para>在这部分，必须选择<option>wait</option>或
	      <option>nowait</option>。
	      <option>max-child</option>和
	      <option>max-connections-per-ip-per-minute</option> 则为可有可无。</para>

	    <para>一个stream-type多线程的服务，如果没有
	      <option>max-child</option>或者
	      <option>max-connections-per-ip-per-minute</option>需要，
	      一般使用: <literal>nowait</literal>。</para>

	    <para>同样的服务，如果需要限制最大连接数，则如下：
	    <literal>nowait/10</literal>。</para>

	    <para>此外，如果要限制每分钟单个IP来访连接为20个，同时最多
	    派生10个进程，可以如下：
	      <literal>nowait/10/20</literal>。</para>

	    <para>以上开关都默认被使用在<application>fingerd</application>服务上面，
	      如下所示：</para>

	    <programlisting>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</programlisting>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>user</term>

	  <listitem>
	    <para>该开关指定服务将以什么用户身份运行。一般而言，服务运行身份是
	      <username>root</username>。基于安全目的，可以看到有些服务以
	      <username>daemon</username>身份，或者是最小特权的
	      <username>nobody</username>身份运行。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program</term>

	  <listitem>
	    <para>当连接到来时，执行服务程序的全路径。如果服务是由
	    <application>inetd</application>内置提供的，以<option>internal</option>代替。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program-arguments</term>

	  <listitem>
	    <para>当<option>server-program</option>调用到时，该开关
	    的值通过<literal>argv[0]</literal>通过传递给服务而工作。
	    如果命令行为：<command>mydaemon -d</command>，则
	      <literal>mydaemon -d</literal>为<option>server-program-arguments</option>
	      开关的值。同样的，如果服务是由<application>inetd</application>
	      内置提供的，这里还是
	      <option>internal</option>。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="network-inetd-security">
      <title>Security</title>

      <para>随安装时候选择的安全模式不同，部分<application>inetd</application>的服务
      会被设为默认打开。如果没有确实的需要，禁止它们！只要在<filename>/etc/inetd.conf</filename>里头
      需要禁止的服务前头加上<quote>#</quote>，然后<link linkend="network-inetd-hangup">
      对inetd发送hangup信号</link>。某些服务，比如<application>fingerd</application>，
      由于对攻击者提供太多信息，可能对任何人都应该禁止。</para>

      <para>某些服务在安全上没有考虑，并且有一些连接超时检测设得很长或没有检测机制。
      这回允许攻击者慢慢地发送连接，这样可以导致可用资源的消耗。在某些服务上面加上
      <option>max-connections-per-ip-per-minute</option>和<option>max-child</option>
      的限制似乎不错。</para>

      <para>默认情况下，TCP wrapping 是打开的。参考
	&man.hosts.access.5; 手册，以获得更多关于在各种<application>inetd</application>
	调用的服务上设置TCP限制的信息。</para>
    </sect2>

    <sect2 id="network-inetd-misc">
      <title>杂项</title>

      <para><application>daytime</application>，
	<application>time</application>，
	<application>echo</application>，
	<application>discard</application>，
	<application>chargen</application>， 和
	<application>auth</application> 都是<application>inetd</application>内置的服务。</para>

      <para><application>auth</application>服务提供
	identity （<application>ident</application>，
	<application>identd</application>）网络服务，并且某种程度上可配置。</para>

      <para>参考 &man.inetd.8; 手册获得更多信息。</para>
    </sect2>
  </sect1>

  <sect1 id="network-nfs">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
          <contrib>Reorganized and enhanced by </contrib>
        </author>
      </authorgroup>
      <authorgroup>
        <author>
          <firstname>Bill</firstname>
      	  <surname>Swingle</surname>
	  <contrib>Written by </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>网络文件系统（NFS）</title>

    <indexterm><primary>NFS</primary></indexterm>
    <para>网络文件系统是FreeBSD支持的文件系统中的一种，也被称为<acronym role="Network
      File System">NFS</acronym>.  <acronym role="Network File
      System">NFS</acronym>允许一个系统在网络上与它人共享目录和文件。通过使用<acronym
      role="Network File System">NFS</acronym>，用户和程序可以象访问本地文件
      一样访问远端系统上的文件。</para>

    <para>以下是<acronym>NFS</acronym>最显而易见的好处：</para>

    <itemizedlist>
      <listitem>
	<para>本地工作站使用更少的磁盘空间，因为通常的数据可以存放在一
	台机器上而且可以通过网络访问到。</para>
      </listitem>

      <listitem>
	<para>用户不必在每个网络上机器里头都有一个home目录。Home目录
	  可以被放在<acronym>NFS</acronym>服务器上并且在网络上处处可用。
	  </para>
      </listitem>

      <listitem>
	<para>诸如软驱，CDROM，和 &iomegazip; 之类的存储设备可以在网络上面被别的机器使用。
	  这可以减少整个网络上的可移动介质设备的数量。</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title><acronym>NFS</acronym>是如何工作的</title>

      <para><acronym>NFS</acronym>至少有两个主要部分：一台服务器和一
      台（或者更多）客户机。客户机远程访问存放在服务器上的数据。为了
      正常工作，一些进程需要被配置并运行。</para>

      <note><para>在 &os; 5.X上面，<application>portmap</application>
	被<application>rpcbind</application>替换了。而且，在&os; 5.X上面，
	the user is required to replace every instance of
	<application>portmap</application> with
	<application>rpcbind</application> in the forthcoming
	examples。</para></note>

      <para>服务器必须运行以下服务：</para>
      <indexterm>
        <primary>NFS</primary>
        <secondary>server</secondary>
      </indexterm>
      <indexterm>
        <primary>file server </primary>
        <secondary>unix clients </secondary>
      </indexterm>

      <indexterm>
        <primary><application>portmap</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>mountd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>nfsd</application></primary>
      </indexterm>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="3*">

	  <thead>
	    <row>
	      <entry>服务</entry>
	      <entry>描述</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><application>nfsd</application></entry>
	      <entry><acronym>NFS</acronym>，为来自<acronym>NFS</acronym>客户端的
	      请求服务。</entry>
	    </row>
	    <row>
	      <entry><application>mountd</application></entry>
	      <entry><acronym>NFS</acronym>挂载服务，处理&man.nfsd.8;递交过来的请求。</entry>
	    </row>
	    <row>
	      <entry><application>portmap</application></entry>
	      <entry> portmap服务允许
	      <acronym>NFS</acronym>客户端查看<acronym>NFS</acronym>服务在用的端口。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>客户端同样运行一些进程，比如
        <application>nfsiod</application>。
        <application>nfsiod</application>处理来自<acronym>NFS</acronym>的请求。
        这是可选的，而且可以提高性能，对于普通和正确的操作来说并不是必须的。
        参考&man.nfsiod.8;手册获得更多信息。
      </para>
    </sect2>

    <sect2 id="network-configuring-nfs">
      <title>配置<acronym>NFS</acronym></title>
      <indexterm>
        <primary>NFS</primary>
        <secondary>configuration</secondary>
      </indexterm>

      <para><acronym>NFS</acronym>的配置过程相对简单。这个过程只需要
      对<filename>/etc/rc.conf</filename>文件作一些简单修改。</para>

      <para>在<acronym>NFS</acronym>服务器这端，确认<filename>/etc/rc.conf</filename>
      文件里头以下开关都配上了:</para>

      <programlisting>portmap_enable="YES"
nfs_server_enable="YES"
mountd_flags="-r"</programlisting>

      <para>只要<acronym>NFS</acronym>服务被置为enable，<application>mountd</application>
      就能自动运行。</para>

      <para>在客户端一侧，确认下面这个开关出现在
        <filename>/etc/rc.conf</filename>里头:</para>

      <programlisting>nfs_client_enable="YES"</programlisting>

      <para><filename>/etc/exports</filename>文件指定了哪个文件系统
      <acronym>NFS</acronym>应该输出（有时被称为<quote>共享</quote>）。
      <filename>/etc/exports</filename>里面每行指定一个输出的文件系统和
      哪些机器可以访问该文件系统。在指定机器访问权限的同时，访问选项
      开关也可以被指定。有很多开关可以被用在这个文件里头，不过不会在这
      里详细谈。您可以通过阅读&man.exports.5; 手册来发现这些开关。</para>

      <para>以下是一些<filename>/etc/exports</filename>的例子：</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>export examples</secondary>
      </indexterm>

      <para>紧接着的这个例子说明了如何输出一个文件系统，尽管具体设定和您
      的环境以及网络配置有关。作为实例，为了输出<filename>/cdrom</filename>
      到三个的例子机器，它们有同样域名（因此他们的域名不大对）或者在您的
      <filename>/etc/hosts</filename>文件里头有记录。<option>-ro</option>
      标志将被输出的文件系统置为只读。由于这个标志，远程系统将无法在被输出
      的文件系统上写入任何变动。</para>

      <programlisting>/cdrom -ro host1 host2 host3</programlisting>

      <para>下面的例子可以输出<filename>/home</filename>给三个以IP地址方式表示的主机。
	对于在没有配置<acronym>DNS</acronym>服务器的私有网络里头，这很有用。
	此外，the <filename>/etc/hosts</filename> 文件也可以用以配置主机名；参看 &man.hosts.5; 。
	<option>-alldirs</option> 标记允许子目录被作为挂载点。
	也就是说，客户端可以根据需要挂载需要的目录。 </para>

      <programlisting>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

      <para>下面几行输出 <filename>/a</filename> ，以便两个来自不同域的客户端可以访问文件系统。
	<option>-maproot=root</option> 标记授权远端系统上的
	<username>root</username> 用户在被输出的文件系统上以<username>root</username>身份进行读写。
	如果没有特别指定 <literal>-maproot=root</literal> 标记，
	则即使用户在远端系统上是 <username>root</username> 身份，
	也不能修改被输出文件系统上的文件。 </para>

      <programlisting>/a  -maproot=root  host.example.com box.example.org</programlisting>

      <para> 为了能够访问到被输出的文件系统，客户端必须被授权。
      请确认客户端在您的 <filename>/etc/exports</filename> 被列出。 </para>

      <para>在 <filename>/etc/exports</filename> 里头，每一行里面，输出信息和文件系统一一对应。
  一个远程主机每次只能对应一个文件系统。而且只能有一个默认入口。比如，假设
	<filename>/usr</filename> 是独立的文件系统。这个 <filename>/etc/exports</filename> 就是无效的：</para>

      <programlisting>/usr/src   client
/usr/ports client</programlisting>

      <para>一个文件系统，<filename>/usr</filename>， 有两行指定输出到同一主机，
   <hostid>client</hostid>.
       解决这一问题的正确的格式是：</para>

      <programlisting>/usr/src /usr/ports  client</programlisting>

      <para>The properties of one filesystem exported to a given host
	must all occur on one line.  Lines without a client specified
	are treated as a single host.  This limits how you can export
	filesystems, but for most people this is not an issue.</para>

      <para>下面是一个有效输出列表的例子，
	<filename>/usr</filename> and <filename>/exports</filename>
	是本地文件系统：</para>

      <programlisting># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</programlisting>

      <para>一旦修改 <filename>/etc/exports</filename> 了之后，
      为了让变动生效，您必须重启 <application>mountd</application>。
      可以通过对<command>mountd</command> 进程发送HUP信号重启：</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>

      <para>另外，系统重启动可以让FreeBSD把一切都弄好。尽管如此，重启不是必须的。
        以 <username>root</username> 身份执行下面的命令可以搞定一切。</para>

      <para>在 <acronym>NFS</acronym> 服务器端：</para>

      <screen>&prompt.root; <userinput>portmap</userinput>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput></screen>

      <para>在 <acronym>NFS</acronym> 客户端：</para>

      <screen>&prompt.root; <userinput>nfsiod -n 4</userinput></screen>

      <para>现在每件事情都应该就绪，以备挂载一个远端文件系统。 在这些例子里头，
      服务器名字将是：<hostid>server</hostid> ，而客户端的名字将是： <hostid>client</hostid>。
      如果您只打算临时挂载一个远端文件系统或者只是打算作测试配置正确与否，
      只要在客户端以 <username>root</username> 身份执行下面的命令：</para>
      <indexterm>
        <primary>NFS</primary>
        <secondary>mounting</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>mount server:/home /mnt</userinput></screen>

      <para>这条命令会把服务端的 <filename>/home</filename> 目录挂载到客户端的 <filename>/mnt</filename> 上。
      如果配置正确，您应该可以进入客户端的 <filename>/mnt</filename> 目录并且看到所有服务端的文件。 </para>

      <para>如果您打算让系统每次在重启动的时候都自动挂载远端的文件系统，把那个文件系统加到
	<filename>/etc/fstab</filename> 文件里头去。下面是例子：</para>

      <programlisting>server:/home	/mnt	nfs	rw	0	0</programlisting>

      <para> &man.fstab.5; 手册里有所有可用的开关。</para>
    </sect2>

    <sect2>
      <title>实际应用</title>

      <para><acronym>NFS</acronym> 有很多实际应用。下面是比较常见的一些：</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>uses</secondary>
      </indexterm>
      <itemizedlist>
        <listitem>
	  <para>多个机器共享一台CDROM或者其他设备。这对于在多台机器中安装软件来说更加便宜跟方便。
	   </para>
	</listitem>

	<listitem>
	  <para>在大型网络中，配置一台中心 <acronym>NFS</acronym> 服务器用来放置所有用户的home目录可能会带来便利。
	    这些目录能被输出到网络以便用户不管在哪台工作站上登录，总能得到相同的home目录。
	    </para>
	</listitem>

	<listitem>
	  <para>几台机器可以有通用的<filename>/usr/ports/distfiles</filename> 目录。
          这样的话，当您需要在几台机器上安装port时，您可以无需在每台设备上下载而快速访问源码。
           </para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="network-amd">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Wylie</firstname>
	    <surname>Stilwell</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
	<authorgroup>
	  <author>
	    <firstname>Chern</firstname>
	    <surname>Lee</surname>
	    <contrib>Rewritten by </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>使用 <application>amd</application> 自动挂载 ** 翻译进行中 **</title>

      <para></para>
    </sect2>

    <sect2 id="network-nfs-integration">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>John</firstname>
            <surname>Lind</surname>
            <contrib>Contributed by </contrib>
          </author>
        </authorgroup>
      </sect2info>
      <title>Problems Integrating with Other Systems ** 翻译进行中 **</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="network-nis">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Bill</firstname>
      	  <surname>Swingle</surname>
	  <contrib>Written by </contrib>
         </author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Ogren</surname>
	  <contrib>Enhanced by </contrib>
	</author>
	<author>
	  <firstname>Udo</firstname>
	  <surname>Erdelhoff</surname>
	</author>
      </authorgroup>
    </sect1info>
    <title>Network Information System (NIS/YP) ** 翻译进行中 **</title>

    <sect2 id="network-netgroups">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Udo</firstname>
            <surname>Erdelhoff</surname>
            <contrib>Contributed by </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Using Netgroups ** 翻译进行中 **</title>
      <para></para>
    </sect2>

    <sect2>
      <title>Important Things to Remember ** 翻译进行中 **</title>

      <para></para>
    </sect2>

    <sect2 id="network-nis-server-is-client">
      <title>NIS Servers That Are Also NIS Clients ** 翻译进行中 **</title>

      <para></para>
    </sect2>

  </sect1>

  <sect1 id="network-dhcp">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Greg</firstname>
      	  <surname>Sutter</surname>
	  <contrib>Written by </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>网络自动配置 (DHCP)</title>

    <sect2 id="network-dhcp-server">
	<title>安装和配置 DHCP 服务器</title>

	<sect3>
	  <title>这一章包含哪些内容</title>

	  <para>这一章提供了关于如何在 FreeBSD 系统上使用 ISC
	    (Internet 软件协会) 的 DHCP 实现套件来架设 DHCP 服务器的信息。</para>

	  <para>DHCP 套件中的服务器部分并没有作为 FreeBSD 的一部分来提供，
	    因此您需要安装
	    <filename role="package">net/isc-dhcp3-server</filename>
	    port 才能提供这个服务。 请参见 <xref linkend="ports">
	    以了解关于如何使用 ports collection 的进一步详情。</para>
	</sect3>

	<sect3>
	  <title>安装 DHCP 服务器</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>安装</secondary>
	  </indexterm>
	  <para>为了在您的 FreeBSD 系统上进行配置以便作为 DHCP 服务器来使用，
	    需要把 &man.bpf.4; 设备编译进内核。 要完成这项工作， 需要将
	    <literal>device bpf</literal> (如果使用 &os;&nbsp;4.X 的话， 则写作
	    <literal>pseudo-device bpf</literal>) 加入到您的内核配置文件中，
	    并重新联编内核。 要得到关于如何联编内核的进一步信息， 请参见
	    <xref linkend="kernelconfig">。</para>

	  <para><devicename>bpf</devicename> 设备是 FreeBSD 所附带的
	    <filename>GENERIC</filename> 内核中已经联入的组件，
	    因此您并不需要为了让 DHCP 正常工作而特地定制内核。</para>

	    <note>
	      <para>如果您有较强的安全意识， 应该注意
	        <devicename>bpf</devicename> 同时也是让听包程序能够正确工作的设备
		(尽管这类程序仍然需要以特权用户身份运行)。
		<devicename>bpf</devicename>
		<emphasis>是</emphasis> 使用 DHCP 所必需的，
		但如果您对安全非常敏感， 您可能会不希望将
		<devicename>bpf</devicename> 放进内核，
		直到您真的认为 DHCP 是必需的为止。</para>
	    </note>

	  <para>接下来要做的是编辑示范的
	    <filename>dhcpd.conf</filename>， 它由
	    <filename role="package">net/isc-dhcp3-server</filename> port
	    安装。 默认情况下， 它的名字应该是
	    <filename>/usr/local/etc/dhcpd.conf.sample</filename>，
	    在开始修改之前， 您需要把它复制为
	    <filename>/usr/local/etc/dhcpd.conf</filename>。</para>
	</sect3>

	<sect3>
	  <title>配置 DHCP 服务器</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>dhcpd.conf</secondary>
	  </indexterm>
	  <para><filename>dhcpd.conf</filename> 包含了一系列关于子网和主机的定义，
	    下面的例子可以帮助您理解它：</para>

	  <programlisting>option domain-name "example.com";<co id="domain-name">
option domain-name-servers 192.168.4.100;<co id="domain-name-servers">
option subnet-mask 255.255.255.0;<co id="subnet-mask">

default-lease-time 3600;<co id="default-lease-time">
max-lease-time 86400;<co id="max-lease-time">
ddns-update-style none;<co id="ddns-update-style">

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<co id="range">
  option routers 192.168.4.1;<co id="routers">
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<co id="hardware">
  fixed-address mailhost.example.com;<co id="fixed-address">
}</programlisting>

	  <calloutlist>
	    <callout arearefs="domain-name">
	      <para>这个选项指定了提供给客户机作为默认搜索域的域名。 请参考
		&man.resolv.conf.5; 以了解关于这一概念的详情。</para>
	    </callout>

	    <callout arearefs="domain-name-servers">
	      <para>这个选项用于指定一组客户机使用的 DNS 服务器，
		它们之间以逗号分隔。</para>
	    </callout>

	    <callout arearefs="subnet-mask">
	      <para>提供给客户机的子网掩码。</para>
	    </callout>

	    <callout arearefs="default-lease-time">
	      <para>客户机可以请求租约的有效期， 而如果没有，
		则服务器将指定一个租约有效期， 也就是这个值 (单位是秒)。</para>
	    </callout>

	    <callout arearefs="max-lease-time">
	      <para>这是服务器允许租出地址的最大时长。
		如果客户机请求了更长的租期， 则它将得到一个地址，
		但其租期仅限于 <literal>max-lease-time</literal> 秒。</para>
	    </callout>

	    <callout arearefs="ddns-update-style">
	      <para>这个选项用于指定 DHCP 服务器在一个地址被接受或释放时是否应对应尝试更新
		DNS。 在 ISC 实现中， 这一选项是 <emphasis>必须指定的</emphasis>。</para>
	    </callout>

	    <callout arearefs="range">
	      <para>指定地址池中可以用来分配给客户机的 IP 地址范围。
		在这个范围之间， 以及其边界的 IP 地址将分配给客户机。</para>
	    </callout>

	    <callout arearefs="routers">
	      <para>定义客户机的默认网关。</para>
	    </callout>

	    <callout arearefs="hardware">
	      <para>主机的硬件 MAC 地址 (这样 DHCP
		服务器就能够在接到请求时知道请求的主机身份)。</para>
	    </callout>

	    <callout arearefs="fixed-address">
	      <para>指定总是得到同一 IP 地址的主机。
		请注意在此处使用主机名是对的， 因为 DHCP 
		服务器会在返回租借地址信息之前自行解析主机名。</para>
	    </callout>
	  </calloutlist>

	  <para>一旦您撰写完
	    <filename>dhcpd.conf</filename>， 就可以用下面的命令来启动服务：</para>

	  <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/isc-dhcpd.sh start</userinput></screen>

	  <para>如果未来您需要修改服务器的配置， 请务必牢记发送
	    <literal>SIGHUP</literal> 信号给
	    <application>dhcpd</application> 并 <emphasis>不会</emphasis>
	    导致配置文件的重新加载， 而这在其他服务程序中则是比较普遍的约定。
	    您需要发送 <literal>SIGTERM</literal> 信号来停止进程，
	    然后使用上面的命令来重新启动它。</para>
	</sect3>

	<sect3>
	  <title>文件</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>配置文件</secondary>
	  </indexterm>
	  <itemizedlist>
	    <listitem><para><filename>/usr/local/sbin/dhcpd</filename></para>
	      <para><application>dhcpd</application> 是静态连接的， 并安装到
		<filename>/usr/local/sbin</filename> 中。 随 port 安装的
		&man.dhcpd.8; 联机手册提供了关于
		<application>dhcpd</application> 更为详尽的信息。</para>
	    </listitem>

	    <listitem><para><filename>/usr/local/etc/dhcpd.conf</filename></para>
	      <para><application>dhcpd</application> 需要配置文件，
		即 <filename>/usr/local/etc/dhcpd.conf</filename>
		才能够向客户机提供服务。 这个文件需要包括应提供给客户机的所有信息，
		以及关于服务器运行的其他信息。 此配置文件的详细描述可以在随 port
		安装的 &man.dhcpd.conf.5; 联机手册上找到。</para>
	    </listitem>

	    <listitem><para><filename>/var/db/dhcpd.leases</filename></para>
	      <para>DHCP 服务器会维护一个它签发的租用地址数据库，
		并保存在这个文件中， 这个文件是以日志的形式保存的。
		随 port 安装的
		&man.dhcpd.leases.5; 联机手册提供了更详细的描述。</para>
	    </listitem>

	    <listitem><para><filename>/usr/local/sbin/dhcrelay</filename></para>
	      <para><application>dhcrelay</application> 在更为复杂的环境中，
		可以用来支持使用 DHCP 服务器转发请求给另一个独立网络上的
		DHCP 服务器。 如果您需要这个功能， 需要安装 <filename
		role="package">net/isc-dhcp3-relay</filename> port。
		&man.dhcrelay.8; 联机手册提供了更为详尽的介绍。</para>
	    </listitem>
	  </itemizedlist>
	</sect3>

      </sect2>

  </sect1>

  <sect1 id="network-dns">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Contributed by </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>域名系统 (DNS)</title>

    <sect2>
      <title>纵览</title>
      <indexterm><primary>BIND</primary></indexterm>

      <para>FreeBSD 在默认情况下使用一个版本的 BIND (Berkeley
        Internet Name Domain)， 这是目前最为流行的 DNS 协议实现。
        DNS 是一种协议， 可以通过它将域名同 IP 地址相互对应。
        例如， 查询 <hostid role="fqdn">www.FreeBSD.org</hostid>
        将得到 FreeBSD Project 的 web 服务器的 IP 地址， 而查询 <hostid
        role="fqdn">ftp.FreeBSD.org</hostid> 则将得到响应的 FTP 机器的
        IP 地址。 类似地， 也可以做相反的事情。 查询 IP
        地址可以得到其主机名。 当然， 完成 DNS
        查询并不需要在系统中运行域名服务器。
      </para>

      <indexterm><primary>DNS</primary></indexterm>
      <para>DNS 在 Internet 上通过一组略显复杂的权威根域名服务器来组织，
        它的其余部分则由较小规模的域名服务器组成，
        这些服务器提供少量的域名解析服务， 并对域名信息进行缓存。
      </para>

      <para>
        这份文档介绍了 BIND 8.x， 它是 FreeBSD 先前版本所采用的稳定版本。
	BIND 9.x 可以通过 <filename role="package">net/bind9</filename>
	port 来安装到 FreeBSD 上， 而从 5.3-RELEASE 开始，
	它成为了基本系统的一部分。
      </para>

      <para>
        RFC1034 和 RFC1035 定义了 DNS 协议。
      </para>

      <para>
        目前， BIND 由
        Internet Software Consortium <ulink url="http://www.isc.org/"></ulink>
        维护。
      </para>
    </sect2>

    <sect2>
      <title>术语</title>

      <para>要理解这份文档， 需要首先了解一些相关的 DNS 术语。</para>

      <indexterm><primary>解析器 (resolver)</primary></indexterm>
      <indexterm><primary>反向 DNS (reverse DNS)</primary></indexterm>
      <indexterm><primary>根域 (root zone)</primary></indexterm>
      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="3*">

	  <thead>
	    <row>
	      <entry>术语</entry>
	      <entry>定义</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>正向 DNS (Forward DNS)</entry>
	      <entry>将域名映射到 IP 地址</entry>
	    </row>

	    <row>
	      <entry>原点 (Origin)</entry>
	      <entry>表示特定域文件所在的域</entry>
	    </row>

	    <row>
	      <entry><application>named</application>, BIND, 域名服务器(name server)</entry>
	      <entry>在 FreeBSD 中 BIND 域名服务器软件包的常见叫法</entry>
	    </row>

	    <row>
	      <entry>解析器 (Resolver)</entry>
	      <entry>计算机用以向域名服务器查询域名信息的一个系统进程</entry>
	    </row>

	    <row>
	      <entry>反向 DNS (Reverse DNS)</entry>
	      <entry>与正向 DNS 相对； 将 IP 地址映射为主机名</entry>
	    </row>

	    <row>
	      <entry>根域</entry>

	      <entry>Internet 域层次的起点。 所有的域都在根域之下，
		类似文件系统中， 文件都在根目录之下那样。</entry>
	    </row>

	    <row>
	      <entry>域 (Zone)</entry>
	      <entry>独立的域， 子域， 或者由同一机构管理的 DNS 的一部分。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <indexterm>
	<primary>域</primary>
	<secondary>例子</secondary>
      </indexterm>

      <para>域的例子：
      </para>
      <itemizedlist>
        <listitem>
          <para><hostid>.</hostid> 是根域。</para>
        </listitem>
        <listitem>
          <para><hostid>org.</hostid> 是一个根域下的域。</para>
        </listitem>
        <listitem>
          <para><hostid role="domainname">example.org</hostid> 是
          <hostid>org.</hostid> 域之下的域。</para>
        </listitem>
        <listitem>
          <para><hostid role="domainname">foo.example.org.</hostid> 是
            <hostid role="domainname">example.org.</hostid> 域的子域。</para>
        </listitem>
        <listitem>
          <para>
            <hostid>1.2.3.in-addr.arpa</hostid> 是用于表达 <hostid
	    role="ipaddr">3.2.1.*</hostid> IP 地址空间之下所有
	    IP 地址的域。
          </para>
        </listitem>
      </itemizedlist>

      <para>如您所见， 域名中最细节的部分在它的左边。
        举例来说， <hostid
        role="domainname">example.org.</hostid> 要比
        <hostid>org.</hostid> 更小， 就像 <hostid>org.</hostid>
        要比根域更小一样。 主机名的格局和文件系统类似：
        <filename>/dev</filename> 目录在根目录中， 等等。</para>


    </sect2>

    <sect2>
      <title>运行域名服务器的理由</title>

      <para>域名服务器通常会有两种形式： 权威域名服务器，
	以及缓存域名服务器。</para>

      <para>下列情况需要有权威域名服务器：</para>

      <itemizedlist>
	<listitem>
	  <para>想要向全世界提供 DNS 信息，
	    并对请求给出权威应答。</para>
	</listitem>
	<listitem>
	  <para>注册了类似 <hostid role="domainname">example.org</hostid>
	    的域， 而需要将 IP 指定到其下的主机名上。</para>
	</listitem>
	<listitem>
	  <para>某个 IP 地址块需要反向 DNS 项 (IP 到主机名)。</para>
	</listitem>
	<listitem>
	  <para>需要备份服务器， 或常说的从 (slave) 服务器，
	    在主服务器出现问题或无法访问时来应答查询请求。</para>
	  </listitem>
      </itemizedlist>

      <para>下列情况需要有缓存域名服务器：</para>

      <itemizedlist>
	<listitem>
	  <para>本地的 DNS 服务器能够缓存，
	    并比直接向外界的域名服务器请求更快地得到应答。</para>
	</listitem>
	<listitem>
	  <para>减少所需的总体网络流量 (DNS
	    流量通常占全部 Internet 流量的 5% 或更多)。</para>
	</listitem>
      </itemizedlist>

      <para>当有人查询 <hostid
	role="fqdn">www.FreeBSD.org</hostid> 时，解析器通常会向上级
	ISP 的域名服务器发出请求， 并获得回应。 如果有本地的缓存 DNS
	服务器， 查询只有在第一次被缓存 DNS 服务器发到外部世界。
	其他的查询不会发向局域网外， 因为它们已经有在本地的缓存了。</para>

    </sect2>

    <sect2>
      <title>DNS 如何运作</title>
      <para>在 FreeBSD 中， BIND 服务程序被称为
	<application>named</application>， 其原因显而易见。</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>文件</entry>
	      <entry>描述</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><application>named</application></entry>
	      <entry>BIND 服务程序</entry>
	    </row>

	    <row>
	      <entry><command>ndc</command></entry>
	      <entry>域名服务控制程序</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>BIND 存放域名信息的位置</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/named.conf</filename></entry>
	      <entry>域名服务配置文件</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>
        域文件通常被放在
        <filename>/etc/namedb</filename>
        目录中， 它们包含域名服务器所提供的 DNS 域的信息。
      </para>
    </sect2>

    <sect2>
      <title>启动 BIND</title>
      <indexterm>
        <primary>BIND</primary>
	<secondary>启动</secondary>
      </indexterm>
      <para>
        由于 BIND 会在默认情况下安装， 因此配置它相对而言很简单。
      </para>
      <para>
        要确保 <application>named</application> 服务程序在引导时被自动启动，
         把下面的行加到 <filename>/etc/rc.conf</filename> 中：
      </para>
      <programlisting>named_enable="YES"</programlisting>
      <para>要手工启动服务 (在完成配置之后)：</para>
      <screen>&prompt.root; <userinput>ndc start</userinput></screen>
    </sect2>

    <sect2>
      <title>配置文件</title>
      <indexterm>
        <primary>BIND</primary>
	<secondary>配置文件</secondary>
      </indexterm>
      <sect3>
        <title>使用 <command>make-localhost</command></title>
        <para>一定要：
        </para>
        <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>sh make-localhost</userinput></screen>
        <para>以便创建正确的本地 DNS 反向解析域文件
          <filename>/etc/namedb/localhost.rev</filename>。
        </para>
      </sect3>

      <sect3>
        <title><filename>/etc/namedb/named.conf</filename></title>

        <programlisting>// &dollar;FreeBSD$
//
// Refer to the named(8) manual page for details.  If you are ever going
// to setup a primary server, make sure you've understood the hairy
// details of how DNS is working.  Even with simple mistakes, you can
// break connectivity for affected parties, or cause huge amount of
// useless Internet traffic.

options {
        directory "/etc/namedb";

// In addition to the "forwarders" clause, you can force your name
// server to never initiate queries of its own, but always ask its
// forwarders only, by enabling the following line:
//
//      forward only;

// If you've got a DNS server around at your upstream provider, enter
// its IP address here, and enable the line below.  This will make you
// benefit from its cache, thus reduce overall DNS traffic in the
Internet.
/*
        forwarders {
                127.0.0.1;
        };
*/</programlisting>

        <para>
	  如注视所说， 要从上级的缓存中受益， 可以在此处启用
          <literal>forwarders</literal>。 在一般情况下， 域名服务器会逐级地查询
          Internet 来找到特定的域名服务器， 直到得到答案为止。
          启用这个将让它首先查询上级域名服务器 (或另外提供的域名服务器)，
          从而从它们的缓存中得到结果。 如果上级域名服务器的负载很重，
          在更快的域名服务器上启用它将有助于改善服务品质。
        </para>

	<warning><para><hostid role="ipaddr">127.0.0.1</hostid>
            <emphasis>不会</emphasis> 正常工作。
            一定要把地址改为您上级服务器的 IP 地址。</para>
        </warning>

        <programlisting>        /*
         * If there is a firewall between you and name servers you want
         * to talk to, you might need to uncomment the query-source
         * directive below.  Previous versions of BIND always asked
         * questions using port 53, but BIND 8.1 uses an unprivileged
         * port by default.
         */
        // query-source address * port 53;

        /*
         * If running in a sandbox, you may have to specify a different
         * location for the dumpfile.
         */
        // dump-file "s/named_dump.db";
};

// Note: the following will be supported in a future release.
/*
host { any; } {
        topology {
                127.0.0.0/8;
        };
};
*/

// Setting up secondaries is way easier and the rough picture for this
// is explained below.
//
// If you enable a local name server, don't forget to enter 127.0.0.1
// into your /etc/resolv.conf so this server will be queried first.
// Also, make sure to enable it in /etc/rc.conf.

zone "." {
        type hint;
        file "named.root";
};

zone "0.0.127.IN-ADDR.ARPA" {
        type master;
        file "localhost.rev";
};

zone
"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.INT" {
        type master;
        file "localhost.rev";
};

// NB: Do not use the IP addresses below, they are faked, and only
// serve demonstration/documentation purposes!
//
// Example secondary config entries.  It can be convenient to become
// a secondary at least for the zone where your own domain is in.  Ask
// your network administrator for the IP address of the responsible
// primary.
//
// Never forget to include the reverse lookup (IN-ADDR.ARPA) zone!
// (This is the first bytes of the respective IP address, in reverse
// order, with ".IN-ADDR.ARPA" appended.)
//
// Before starting to setup a primary zone, better make sure you fully
// understand how DNS and BIND works, however.  There are sometimes
// unobvious pitfalls.  Setting up a secondary is comparably simpler.
//
// NB: Don't blindly enable the examples below. :-)  Use actual names
// and addresses instead.
//
// NOTE!!! FreeBSD runs BIND in a sandbox (see named_flags in rc.conf).
// The directory containing the secondary zones must be write accessible
// to BIND.  The following sequence is suggested:
//
//      mkdir /etc/namedb/s
//      chown bind:bind /etc/namedb/s
//      chmod 750 /etc/namedb/s</programlisting>

	<para>For more information on running BIND in a sandbox, see
	  <link linkend="network-named-sandbox">Running named in a sandbox</link>.
	</para>

	<programlisting>/*
zone "example.com" {
        type slave;
        file "s/example.com.bak";
        masters {
                192.168.1.1;
        };
};

zone "0.168.192.in-addr.arpa" {
        type slave;
        file "s/0.168.192.in-addr.arpa.bak";
        masters {
                192.168.1.1;
        };
};
*/</programlisting>
        <para>在 <filename>named.conf</filename> 中， 这是一些转发用的从域以及反向域的例子。</para>

        <para>对于每一个新域， 域对应的项必须加到
	  <filename>named.conf</filename> 中。</para>

        <para>例如， 最简单的用于
	  <hostid role="domainname">example.org</hostid> 域的条目类似下面的样子：</para>

        <programlisting>zone "example.org" {
	type master;
	file "example.org";
};</programlisting>

	<para>这是一个主域， 它由 <option>type</option> 语句标识出来，
	  而信息则在
	  <filename>/etc/namedb/example.org</filename> 域文件中，
	  这是由 <option>file</option> 语句指定的。</para>

        <programlisting>zone "example.org" {
	type slave;
	file "example.org";
};</programlisting>

        <para>在从域的例子中， 域的信息从该域的某个主服务器传送过来，
	  并保存在指定的文件中。 如果主服务器死掉了或不可达，
	  从域名服务器将使用这些传过来的域信息， 从而完成应答。</para>
      </sect3>

      <sect3>
        <title>域信息文件</title>
        <para>
          以下是一个用于 <hostid
	  role="domainname">example.org</hostid> 域的主域文件 (保存为
	  <filename>/etc/namedb/example.org</filename>)：
        </para>

        <programlisting>$TTL 3600

example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        86400 )         ; Minimum TTL

; DNS Servers
@       IN NS           ns1.example.org.
@       IN NS           ns2.example.org.

; Machine Names
localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30

; Aliases
www             IN CNAME        @

; MX Record
@               IN MX   10      mail.example.org.</programlisting>

        <para>
          请注意以 <quote>.</quote> 结尾的主机名是全称主机名， 而结尾没有
          <quote>.</quote> 的则是相对于原点的主机名。 例如，
          <literal>www</literal> 将被转换为
          <literal>www.<replaceable>原点</replaceable></literal>.
          在这个假想的域信息文件中， 我们的原点是
          <hostid>example.org.</hostid>， 因此 <literal>www</literal>
          将被当作 <hostid>www.example.org.</hostid>。
        </para>

        <para>
          域信息文件的格式如下：
        </para>
        <programlisting>记录名          IN 记录类型     值</programlisting>

	<indexterm>
	  <primary>DNS</primary>
	  <secondary>记录</secondary>
	</indexterm>
        <para>
          最常用的 DNS 记录：
        </para>

	<variablelist>
	  <varlistentry>
	    <term>SOA</term>

	    <listitem><para>域权威开始</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>NS</term>

	    <listitem><para>权威域名服务器</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>A</term>

	    <listitem><para>主机地址</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>CNAME</term>

	    <listitem><para>别名对应的正规名称</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>MX</term>

	    <listitem><para>邮件传递服务器</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>PTR</term>

	    <listitem><para>域名指针 (用于反向 DNS)
	      </para></listitem>
	  </varlistentry>
	</variablelist>

        <programlisting>
example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        86400 )         ; Minimum TTL of 1 day</programlisting>



	<variablelist>
	  <varlistentry>
	    <term><hostid role="domainname">example.org.</hostid></term>

	    <listitem><para>域名， 同时也是这个域信息文件的原点。</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><hostid role="fqdn">ns1.example.org.</hostid></term>

	    <listitem><para>该域的主/权威域名服务器。</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>admin.example.org.</literal></term>

	    <listitem><para>此域的负责人的电子邮件地址，
		其中 <quote>@</quote> 被换掉了。
          (<email>admin@example.org</email> 对应
		<literal>admin.example.org</literal>)</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>5</literal></term>

	      <listitem><para>文件的序号。 每次修改域文件时都必须增加这个数字。
		  现今， 许多管理员会考虑使用
		  <literal>yyyymmddrr</literal> 这样的格式来表示序号。
		  <literal>2001041002</literal> 通常表示上次修改于
		  04/10/2001， 而后面的
		  <literal>02</literal> 则表示在那天的第几次修改。
		  序号非常重要， 它用于通知从域服务器更新数据。</para>
	      </listitem>
	  </varlistentry>
	</variablelist>

        <programlisting>
@       IN NS           ns1.example.org.</programlisting>

        <para>
          这是一个 NS 项。 每个准备提供权威应答的服务器都必须有一个对应项。
	  这里的 <literal>@</literal> 表示
	  <hostid role="domainname">example.org.</hostid>。
	  <literal>@</literal> 会被理解为原点。
        </para>

        <programlisting>
localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30</programlisting>

        <para>
          A 记录代表及其名。 如上面看到的，
          <hostid role="fqdn">ns1.example.org</hostid> 将解析为
          <hostid role="ipaddr">3.2.1.2</hostid>。 在此再次使用了原点符，
          <literal>@</literal>， 它表示
          <hostid role="domainname">example.org</hostid> 应解析为
          <hostid role="ipaddr">3.2.1.30</hostid>。
        </para>

        <programlisting>
www             IN CNAME        @</programlisting>

        <para>
          正规名记录通常用于对某台机器的别名给出对应的正式名字。
          在这个例子中， <hostid>www</hostid> 是名字为原点， 或者说
          <hostid role="domainname">example.org</hostid>
          (<hostid role="ipaddr">3.2.1.30</hostid>) 那台机器的别名。
          CNAMEs 可以用来提供主机的别名， 或将同一名字在多台机器上作轮询。
        </para>

	<indexterm>
	  <primary>MX 记录</primary>
	</indexterm>

        <programlisting>
@               IN MX   10      mail.example.org.</programlisting>

        <para>
          MX 记录表示哪个邮件服务器负责接收发到这个域的邮件。
          <hostid role="fqdn">mail.example.org</hostid> 是邮件服务器的主机名，
          而 10 则是它的优先级。
        </para>

        <para>
          可以有多台邮件服务器， 其优先级分别是 3, 2,
          1。 向 <hostid
          role="domainname">example.org</hostid> 进行投递的邮件服务器首先会尝试优先级最高
          (数字最小) 的 MX， 然后是较低优先级的， 等等， 直到成功地投递了邮件为止。
        </para>

        <para>
          对于 in-addr.arpa 域名信息文件 (反向 DNS)， 使用了同样的格式，
          只是 PTR 项代替了 A 或 CNAME 的位置。
        </para>

        <programlisting>$TTL 3600

1.2.3.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        3600 )          ; Minimum

@       IN NS   ns1.example.org.
@       IN NS   ns2.example.org.

2       IN PTR  ns1.example.org.
3       IN PTR  ns2.example.org.
10      IN PTR  mail.example.org.
30      IN PTR  example.org.</programlisting>

        <para>这个文件给出了上述假想域中 IP 地址到域名的映射关系。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>缓存域名服务器</title>
      <indexterm>
        <primary>BIND</primary>
        <secondary>缓存域名服务器</secondary>
      </indexterm>

      <para>缓存域名服务器是对任何域都不提供权威解析的域名服务器。
        它自己简单地完成查询， 并记住这些查询以备后续使用。
        要建立这样的服务器， 只需像平时一样配置一个域名服务器，
        而不配置域就可以了。</para>
    </sect2>

    <sect2 id="network-named-sandbox">
      <title>在沙盒中运行 <application>named</application></title>
      <indexterm>
        <primary>BIND</primary>
        <secondary>在沙盒中运行</secondary>
      </indexterm>

      <indexterm>
        <primary><command>chroot</command></primary>
      </indexterm>
      <para>要更安全地运行 &man.named.8;， 应该以非特权用户来运行它，
	并配置为 &man.chroot.8; 到一个沙盒目录中。
	这使得 <application>named</application> 服务无法访问任何沙盒外面的东西。
	假如 <application>named</application> 被攻破，
	这将减少它所能带来的破坏。 默认情况下， FreeBSD 提供了名为
	<groupname>bind</groupname> 的用户和组来完成这样的目的。</para>

      <note><para>许多人建议不这样做， 而
	<application>named</application> 配置为 <command>chroot</command>，
	您应该在一个 &man.jail.8; 中运行 <application>named</application>。
	这一节并不涵盖这种情形。</para>
      </note>

      <para>由于 <application>named</application> 没有办法访问沙盒外面的任何东西
	(例如共享库， 日志 socket 等等)， 您需要做许多事情来让
	<application>named</application> 正常工作。 下面的清单假定沙盒是
	<filename>/etc/namedb</filename> 而您没有事先改过这个目录中的内容。
	以 <username>root</username> 的身份完成下列步骤：</para>

      <itemizedlist>
	<listitem>
	  <para>创建 <application>named</application>
	    需要访问的所有目录：</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>mkdir -p bin dev etc var/tmp var/run master slave</userinput>
&prompt.root; <userinput>chown bind:bind slave var/*</userinput><co id="chown-slave"></screen>



	  <calloutlist>
	    <callout arearefs="chown-slave">
	      <para><application>named</application> 只需要写这些目录，
		这也是我们赋予它的全部权限。</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
	  <para>重新组织基本的域和配置文件：</para>
	  <screen>&prompt.root; <userinput>cp /etc/localtime etc</userinput><co id="localtime">
&prompt.root; <userinput>mv named.conf etc && ln -sf etc/named.conf</userinput>
&prompt.root; <userinput>mv named.root master</userinput>
<!-- I don't like this next bit -->
&prompt.root; <userinput>sh make-localhost && mv localhost.rev localhost-v6.rev master</userinput>
&prompt.root; <userinput>cat > master/named.localhost
$ORIGIN localhost.
$TTL 6h
@	IN	SOA	localhost. postmaster.localhost. (
			1	; serial
			3600	; refresh
			1800	; retry
			604800	; expiration
			3600 )	; minimum
	IN	NS	localhost.
	IN	A		127.0.0.1
^D</userinput></screen>

	  <calloutlist>
	    <callout arearefs="localtime">
	      <para>这使得 <application>named</application> 能够将正确的时间传递给
		&man.syslogd.8;。</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>

        <indexterm><primary>syslog</primary></indexterm>
        <indexterm><primary>日志</primary>
	  <secondary>DNS</secondary></indexterm>

	  <para>如果您在运行 &os; 在 4.9-RELEASE 之前的版本， 需要联编一个静态连接的
	    <application>named-xfer</application>， 并将其复制到沙盒中：</para>

	      <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make NOSHARED=yes all</userinput>
&prompt.root; <userinput>cp named-xfer /etc/namedb/bin && chmod 555 /etc/namedb/bin/named-xfer</userinput><co id="clean-cruft"></screen>

	  <para>在把静态连接的
	    <command>named-xfer</command> 装好之后需要清理一下，
	    以免将过时的库或程序留在您的源代码副本中：</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	  <calloutlist>
	    <callout arearefs="clean-cruft">
	      <para>据说这一步有时会失败。 如果您遇到这样的问题， 执行下面的命令：</para>

	      <screen>&prompt.root; <userinput>cd /usr/src && make cleandir && make cleandir</userinput></screen>

	      <para>并删除 <filename>/usr/obj</filename> 目录：</para>

	      <screen>&prompt.root; <userinput>rm -fr /usr/obj && mkdir /usr/obj</userinput></screen>

		<para>这将把任何 <quote>垃圾</quote> 从您的源代码目录中删除，
		  而后续工作将得以正常进行。</para>
	    </callout>
	  </calloutlist>

	  <para>如果您运行 &os; 的 4.9-RELEASE 或更新的版本， 则默认情况下
	    <filename>/usr/libexec</filename> 中的 <command>named-xfer</command>
	    副本已经是静态连接的了。 您可以简单地把它用 &man.cp.1; 复制到沙盒中。</para>
	</listitem>

	<listitem>
	  <para>做一个 <application>named</application>
	    能够看到并写入的 <filename>dev/null</filename>：</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb/dev && mknod null c 2 2</userinput>
&prompt.root; <userinput>chmod 666 null</userinput></screen>
	</listitem>

	<listitem>
	  <para>将 <filename>/var/run/ndc</filename> 符号链接到
	    <filename>/etc/namedb/var/run/ndc</filename>：</para>

	  <screen>&prompt.root; <userinput>ln -sf /etc/namedb/var/run/ndc /var/run/ndc</userinput></screen>

	  <note>
	    <para>这主要是避免每次都不得不指定 &man.ndc.8;
	      <option>-c</option> 的选项。 由于
	      <filename>/var/run</filename> 会在每次启动时删除，
	      如果您发现这是您在每次启动时都需要做的事情，
	      则可以在 <username>root</username> 的
	      <filename>crontab</filename> 中增加相应的条目， 并使用
	      <option>@reboot</option> 选项。 参见 &man.crontab.5;
	      以了解更多细节。</para>
	  </note>

	</listitem>

	<listitem>

        <indexterm><primary>syslog</primary></indexterm>
        <indexterm><primary>日志</primary>
	  <secondary>named</secondary></indexterm>

	  <para>配置 &man.syslogd.8; 来创建一个 <application>named</application>
	    可以写的 <devicename>log</devicename> socket。 要完成它， 需要将
	    <literal>-l /etc/namedb/dev/log</literal> 加到
	    <filename>/etc/rc.conf</filename> 的
	    <varname>syslogd_flags</varname> 变量中。</para>
	</listitem>

	<listitem>

          <indexterm><primary><command>chroot</command></primary></indexterm>

	  <para>启动 <application>named</application> 并让它自动地把自己
	    <command>chroot</command> 到沙盒中， 方法是把下面的内容加到
	    <filename>/etc/rc.conf</filename>：</para>

	  <programlisting>named_enable="YES"
named_flags="-u bind -g bind -t /etc/namedb /etc/named.conf"</programlisting>

	  <note>
	    <para>请注意配置文件
	    <replaceable>/etc/named.conf</replaceable> 是以
	    <emphasis>相对于沙盒</emphasis> 的完整路径来指定的，
	    例如上面那一行， 文件所在的目录实际上是
	    <filename>/etc/namedb/etc/named.conf</filename>。</para>
	  </note>
	</listitem>
      </itemizedlist>

      <para>下一步是编辑
	<filename>/etc/namedb/etc/named.conf</filename> 让
	<application>named</application> 直到需要加载哪些域，
	以及它们在磁盘上的位置。 您可以用注释掉的那个例子
	(没有明确地注释掉的哪些和不在沙盒中运行 DNS 服务器时的配置无异)：</para>

	<programlisting>options {
        directory "/";<co id="directory">
        named-xfer "/bin/named-xfer";<co id="named-xfer">
        version "";		// Don't reveal BIND version
        query-source address * port 53;
};
// ndc control socket
controls {
        unix "/var/run/ndc" perm 0600 owner 0 group 0;
};
// Zones follow:
zone "localhost" IN {
        type master;
        file "master/named.localhost";<co id="master">
        allow-transfer { localhost; };
        notify no;
};
zone "0.0.127.in-addr.arpa" IN {
        type master;
        file "master/localhost.rev";
        allow-transfer { localhost; };
        notify no;
};
zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.int" {
	type master;
	file "master/localhost-v6.rev";
	allow-transfer { localhost; };
	notify no;
};
zone "." IN {
        type hint;
        file "master/named.root";
};
zone "private.example.net" in {
        type master;
        file "master/private.example.net.db";
	allow-transfer { 192.168.10.0/24; };
};
zone "10.168.192.in-addr.arpa" in {
        type slave;
        masters { 192.168.10.2; };
        file "slave/192.168.10.db";<co id="slave">
};</programlisting>

      <calloutlist>
	<callout arearefs="directory">
	  <para>
	    <literal>directory</literal> 语句被指定为
	    <filename>/</filename>， 因为所有的
	    <application>named</application> 需要在这个文件中
	    (这相当于在 <quote>普通</quote> 模式下运行时的
	    <filename>/etc/namedb</filename>)。</para>
	</callout>

	<callout arearefs="named-xfer">
	  <para>指定到 <command>named-xfer</command> 执行文件的完整路径 (相对
	    <application>named</application> 的参照系)。 这是必须的步骤，
	    因为 <application>named</application> 在默认情况下会从
	    <filename>/usr/libexec</filename> 查找 <command>named-xfer</command>。</para>
	</callout>
	<callout arearefs="master"><para>指定文件名 (相对于前面的
	  <literal>directory</literal> 语句指定的目录)， 
	  <application>named</application> 将在这里查找域信息文件。</para>
	</callout>
	<callout arearefs="slave"><para>指定文件名 (相对于前面的
	    <literal>directory</literal> 语句指定的目录)， 
	    <application>named</application> 将在这里写入成功地从主服务器拿到的域信息文件副本。
	    这使为什么我们在前面的步骤中将 <filename>slave</filename> 的属主改为
	    <groupname>bind</groupname> 的原因。</para>
	</callout>
      </calloutlist>

      <para>完成这些配置之后， 您可以重新启动服务器， 或重启
	&man.syslogd.8; 服务并启动 &man.named.8;， 以确认
	<varname>syslogd_flags</varname> 和
	<varname>named_flags</varname> 的新值生效了。
	现在您应该已经在沙盒中运行 <application>named</application> 了!</para>

    </sect2>

    <sect2>
      <title>安全</title>

      <para>尽管 BIND 是最为常用的 DNS 实现， 但它总是有一些安全问题。
        时常会有人发现一些可能的甚至可以利用的安全漏洞。
      </para>

      <para>
        经常阅读 <ulink
        url="http://www.cert.org/">CERT</ulink> 的安全公告并订阅
	&a.security-notifications; 会是一个帮助您时刻了解最新
        Internet 和 FreeBSD 安全问题的好习惯。
      </para>

      <tip><para>如果出现了问题， 将代码升级到最新版本并重新联编
        <application>named</application> 不会带来任何麻烦。</para></tip>
    </sect2>

    <sect2>
      <title>进一步阅读</title>

      <para>BIND/<application>named</application> 联机手册：
      &man.ndc.8; &man.named.8; &man.named.conf.5;</para>

      <itemizedlist>
	<listitem>
	  <para><ulink
	      url="http://www.isc.org/products/BIND/">官方的 ISC BIND
	      页面</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	  url="http://www.nominum.com/getOpenSourceResource.php?id=6">
	  BIND FAQ</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.oreilly.com/catalog/dns4/">O'Reilly
         DNS 和 BIND 第4版</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="ftp://ftp.isi.edu/in-notes/rfc1034.txt">RFC1034
	      - 域名 - 概念和工具</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="ftp://ftp.isi.edu/in-notes/rfc1035.txt">RFC1035
	      - 域名 - 实现及其标准</ulink></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="network-bind9">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>撰写者 </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title><acronym>BIND</acronym>9 和 &os;</title>

<!-- This section is here to get users up with BIND9 configurations!  It
  does not cover the terminology, theoretical discussion (why run a name
  server) or the further reading which is still in the previous section.
  I did things this way to avoid repetition of content and obviously we
  cannot just remove the previous section since other supported releases
  use it.  When the previous section is removed then those comments
  should be moved here.  // Tom Rhodes -->

    <indexterm><primary>bind9</primary>
      <secondary>安装</secondary></indexterm>

    <para>&os;&nbsp;5.3 将
      <acronym>BIND</acronym>9 <acronym>DNS</acronym> 服务软件引入了发行包。
      与此同时， 这带来了新的安全特性， 文件布局， 以及自动的
      &man.chroot.8; 配置。 这一节包含两部分，
      第一部分讨论了新特性以及如何配置它们， 而后一部分则介绍了升级的步骤，
      它将帮您顺利地迁移到 &os;&nbsp;5.3。 从此开始， 服务器将被简写为
      &man.named.8; 而不是 <acronym>BIND</acronym>。
      这一节跳过了前一节中所介绍的术语以及一些理论上的讨论， 因此，
      建议您阅读前一节然后再看这一节。</para>

    <para><command>named</command> 的配置文件目前存放在
      <filename role="directory">/var/named/etc/namedb/</filename>，
      在使用前需要进行一些修改。 这也是绝大多数配置所在的位置。</para>

    <sect2>
      <title>配置主域</title>

      <para>要配置主域您需要进入
	<filename role="directory">/var/named/etc/namedb/</filename>
	并执行下面的命令：</para>

      <screen>&prompt.root; <userinput>sh make-localhost</userinput></screen>

      <para>如果一切正常， 则将在
	<filename role="directory">master</filename> 目录中建立两个新的文件。
	它们的文件名是 <filename>localhost.rev</filename> 和
	<filename>localhost-v6.rev</filename>， 分别用来解析本地的名字和
	<acronym>IPv6</acronym> 配置中的名字。 作为默认的配置文件，
	它们已经在 <filename>named.conf</filename> 文件中进行了定义。</para>
    </sect2>

    <sect2>
      <title>配置从域</title>

      <para>可以通过配置从域来提供额外的域或子域的解析。
	多数情况下， <filename>master/localhost.rev</filename>
	可以复制到 <filename role="directory">slave</filename>
	中并进行修改。 一旦完成， 这些文件就可以加入到
	<filename>named.conf</filename> 类似
	<hostid role="fqdn">example.com</hostid> 的配置中：</para>

      <programlisting>zone "example.com" {
        type slave;
        file "slave/example.com";
        masters {
                10.0.0.1;
        };
};

zone "0.168.192.in-addr.arpa" {
        type slave;
        file "slave/0.168.192.in-addr.arpa";
        masters {
                10.0.0.1;
        };
};</programlisting>

      <para>请注意在这个例子中， 主服务器的
	<acronym>IP</acronym> 地址指明了我们要从哪里把域传过来；
	那台服务器本身并不一定要作为对外的
	<acronym>DNS</acronym> 服务器来用。</para>
    </sect2>

    <sect2>
      <title>系统的初始配置</title>

      <para>为了让 <command>named</command> 服务能够在系统启动时自动加载，
	需要把下面的选项加到 <filename>rc.conf</filename> 文件中：</para>

      <programlisting>named_enable="YES"</programlisting>

      <para>尽管还有其他的一些可用选项， 这是运行域名服务器所需要的最小配置。
	请参考 &man.rc.conf.5; 联机手册了解更多的选项。 在
	<filename>rc.conf</filename> 中进行了这些配置之后，
	可以通过下面的命令行来启动 <command>named</command>：</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/named start</userinput></screen>
    </sect2>

    <sect2>
      <title><acronym>BIND</acronym>9 的安全</title>

      <para>尽管 &os; 会自动地将 <command>named</command> 放到一个
	&man.chroot.8; 环境中， 您仍然可以采取一些更严密的措施来防止可能的针对
	<acronym>DNS</acronym> 服务的攻击。

      <sect3>
	<title>查询访问控制表</title>

	<para>查询访问控制表可以用来限制对于域的查询。
	  这些配置通过在 <literal>acl</literal> 语句中列出的
	  <acronym>IP</acronym> 地址来发挥作用。 要允许一个子网查询
	  example.org 中的主机， 可以做下面的定义：</para>

	<programlisting>acl "example.com" {
        192.168.0.0/24;
};

zone "example.com" {
        type slave;
        file "slave/example.com";
        masters {
                10.0.0.1;
        };
	allow-query { example.com; };
};

zone "0.168.192.in-addr.arpa" {
        type slave;
        file "slave/0.168.192.in-addr.arpa";
        masters {
                10.0.0.1;
        };
	allow-query { example.com; };
};</programlisting>
      </sect3>

      <sect3>
	<title>限制版本查询</title>

	<para>允许查询 <acronym>DNS</acronym> 服务的版本，
	  可能会给攻击者敞开方便之门。
	  心存恶意的用户能够利用这一信息找到存在已知漏洞的服务器，
	  并对其实施攻击。 在 <filename>named.conf</filename>
	  的 <literal>options</literal> 小节中可以伪造版本字符串：</para>

	<programlisting>options {
        directory       "/etc/namedb";
        pid-file        "/var/run/named/pid";
        dump-file       "/var/dump/named_dump.db";
        statistics-file "/var/stats/named.stats";
	version		"None of your business";</programlisting>
      </sect3>
<!-- Here is where I stopped for now
      <sect3>
        <title>Authentication</title>

	<para> ... </para>

-->
    </sect2>
  </sect1>

  <sect1 id="network-apache">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Apache HTTP Server ** 翻译进行中 **</title>

    <indexterm><primary>web server</primary>
      <secondary>setting up</secondary></indexterm>
    <indexterm><primary>Apache</primary></indexterm>

    <para></para>
  </sect1>

  <sect1 id="network-samba">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>File and Print Services for &microsoft.windows; clients (Samba) ** 翻译进行中 **</title>

    <indexterm><primary>Samba server</primary></indexterm>
    <indexterm><primary>Microsoft Windows</primary></indexterm>
    <indexterm>
      <primary>file server</primary>
      <secondary>Windows clients</secondary>
    </indexterm>
    <indexterm>
      <primary>print server</primary>
      <secondary>Windows clients</secondary>
    </indexterm>

    <sect2>
      <title>Overview ** 翻译进行中 **</title>

      <para></para>
    </sect2>

  </sect1>

  <sect1 id="network-ntp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Hukins</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Clock Synchronization with NTP ** 翻译进行中 **</title>

    <para></para>
  </sect1>

</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
<!--  LocalWords:  config mnt www -->
