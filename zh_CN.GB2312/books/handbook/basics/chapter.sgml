<!--
     The FreeBSD Documentation Project
     The FreeBSD Simplified Chinese Project

     Original Revision: 1.126
     $FreeBSD$
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>Rewritten by </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>UNIX 基础</title>

  <sect1 id="basics-synopsis">
    <title>概述</title>
    <indexterm><primary>基础</primary></indexterm>


   <para>下列章节的命令和功能适用于FreeBSD操作系统。
     同时这里许多内容和一些 &unix; 类似操作系统相关。
     假如您已经熟悉这些内容可跳过不阅读。
     假如您是FreeBSD新手， 那您应该认真详细地从头到尾读一遍这些章节。</para>

    <para>读取这些内容，您将会学到:</para>

    <itemizedlist>
      <listitem>
        <para>怎样在FreeBSD使用<quote>虚拟控制台</quote>。</para>
      </listitem>
      <listitem>
	<para>&unix;文件权限是怎样工作的。</para>
      </listitem>
      <listitem>
	<para>&os;默认文件系统的架构。</para>
      </listitem>
      <listitem>
	<para>&os;磁盘架构。</para>
      </listitem>
      <listitem>
	<para>怎样挂接或卸下文件系统。</para>
      </listitem>
      <listitem>
	<para>什么是进程、守护进程、信号。</para>
      </listitem>
      <listitem>
	<para>什么是shell，应当怎样去改变登录进入的默认环境。
	</para>
      </listitem>
      <listitem>
	<para>怎样使用基本的文本编辑器。</para>
      </listitem>
      <listitem>
	<para>什么是设备，什么是设备节点。</para>
      </listitem>
      <listitem>
	<para>&os; 下，使用的是什么可执行文件格式。</para>
      </listitem>
      <listitem>
	<para>怎样使用 man 手册并取得更多资讯。</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>虚拟控制台和终端</title>
    <indexterm><primary>虚拟控制台</primary></indexterm>
    <indexterm><primary>终端</primary></indexterm>

    <para>FreeBSD能多方面应用，其中之一它能在字符终端输入命令。
      您可以在这方面容易地使用FreeBSD这个有强大适应性和功能的 &unix; 系统，
      这部份介绍 <quote>多终端</quote> 和<quote>多控制台</quote>，
      和您在 FreeBSD 应怎样使用它们。</para>

    <sect2 id="consoles-intro">
      <title>控制台</title>
      <indexterm><primary>控制台</primary></indexterm>

      <para>假如您没有设置到 FreeBSD 在启动期间给出图形登录，
	那么系统将在引导和启动脚本正确运行完成后，给您一个登录的提示。
	您会看到类似这样的界面:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>这些信息可能和您的系统稍微有点不同，但不会有很大差别。
	最后两行是我们感兴趣的，
        理解这一行:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>这一行是您刚才启动的系统信息其中一块，
	您所看到的是一个<quote>FreeBSD</quote>控制台，
	运行在一个Intel或兼容的x86体系架构上面<footnote>
	  <para>现在理解一下<literal>i386</literal>的含义。 请注意
	    即使您的 FreeBSD 不是运行在一个 Intel 386 CPU， 都会定为<literal>i386</literal>。
	    他不是指您的处理器，而处理器的<quote>体系结构</quote>已经显示过去了。</para>
	</footnote>。这个结构名称 (每一种&unix;结构都有自己的名称) 叫
	<hostid>pc3.example.org</hostid>， 就是现在这个系统控制台&mdash;这个 <devicename>ttyv0</devicename>
	终端的样子。</para>

      <para>在最后，最后一行一直保持这样:</para>

      <programlisting>login:</programlisting>

      <para>假设在这一部份您的用户名
	<quote>username</quote>已经注册在FreeBSD里，
	那一步介绍您应怎样做。</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>进入FreeBSD</title>

      <para>FreeBSD是一个多用户和多重处理的系统，
	这个介绍换句话来说就是一个系统可容纳许多不同的用户，
	谁都可以同时在单一结构下运行大量的程序。</para>

      <para>每一个多用户系统都必须在某方面去区别<quote>user</quote>，
	在FreeBSD里 (和这&unix; 类似的操作系统)，完成这方面工作是有必要的，
	每位使用者在运行程之前都必须<quote>登录</quote>,
	每位用户都有他的用户名 (<quote>username</quote>) 和密码
	(<quote>password</quote>)。
	FreeBSD 会在用户进入之前作出两次询问。</para>

      <indexterm><primary>启动脚本</primary></indexterm>
      <para>在FreeBSD启动和启动脚本正确运行完后
	<footnote>
	  <para>启动脚本这些程序在FreeBSD在启动过程中运行。
	   它们的主要功能为其他每方面的运行作好准备，
	   和运行您的配置所用到的相关环境。</para>
	</footnote>，它将要求您提供一个有效的用户名:
	</para>

      <screen>login:</screen>

      <para>举个例子更容易理解，我们假设您的用户名叫<username>john</username>。
	在提示符下输入 <literal>john</literal>并单击<keycap>Enter</keycap>，
	此时您应该看到这个提示<quote>password</quote>:
     </para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>现在输入 <username>john</username>的密码，和单击
	<keycap>Enter</keycap>。这个密码是<emphasis>没有回显的!</emphasis>
	您在这时不必担心，它出于安全考虑才这样做的。</para>

      <para>假如您输入的密码是正确的，您应该尽快进入FreeBSD并为练习可用的命令作好准备。
      </para>

      <para>您应该看见 <acronym>MOTD</acronym> 或者出现一个命令提示符
	(<literal>#</literal>、<literal>$</literal> 或 <literal>%</literal> 字符).
	这表明您已成功登录进入FreeBSD。</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>多个控制台</title>

      <para>在一个控制台运行 &unix; 命令虽说很好， 但FreeBSD具有一次运行
	多个程序的能力。仅使用一个控制台只会浪费FreeBSD同时运行多任务的能力。
	而<quote>虚拟控制台</quote>在这方面发挥强大的功能。</para>

      <para>FreeBSD 能配置出给您不同需求的虚拟控制台，
	在键盘上您用一组键就能从各个虚拟控制台之间切换。
	各个控制台有自己的传输通道，
	当您从各个控制台切换时 FreeBSD
	会切换到合适的键盘传输通道和显示器传输通道。</para>

      <para>FreeBSD 各个控制台之间可利用特殊组键切换并保留原有控制台
	<footnote>
	  <para>关于 FreeBSD
	    的控制台和键盘设备这些详细资料或使用技巧可在手册里找到:
	    &man.syscons.4;、&man.atkbd.4;、&man.vidcontrol.1;
	    和 &man.kbdcontrol.1;。 我们不在这里详细介绍，
	    但是爱好者总会在手册里找到详细的答案。</para>
	</footnote>，您可这样做:
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>，
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>， 一直到
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	在FreeBSD里切换到其中一个虚拟控制台。</para>

      <para>同样地, 您正在从其中某个控制台切换到另一个控制台的时候,
	FreeBSD 会保存正在使用和恢复将要使用屏幕传输通道。
	这种结果形成一种 <quote>错觉</quote>，
	您拥有许多<quote>虚拟</quote>屏幕和键盘可以输入很多的命令。
	这些程序需要在一个虚拟控制台不能停止运行而又不需要观察它，
	它继续运行而您可以切换到其他的虚拟控制台。</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title><filename>/etc/ttys</filename>文件</title>

      <para>FreeBSD虚拟控制台的默认配置为8个，但并不是硬性设置，
        您可以很容易设置虚拟控制台的个数增多或减少。
        虚拟控制台的的编号和设置在<filename>/etc/ttys</filename> 文件里。</para>

      <para>您可以使用<filename>/etc/ttys</filename>文件在FreeBSD下配置虚拟控制台。
        文件里每一未加注释的行都能设置一个终端或虚拟控制台
        (当行里含有 <literal>#</literal> 这个字符时不能使用) 。
        FreeBSD 默认配置是配置出9个虚拟控制台而只能启动8个，
	以下这些行是 <literal>ttyv</literal> 一起启动:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>您能在这文件详细设置每行的参数，加载虚拟控制台启动所需要的物件。
	请参考 &man.ttys.5; 联机手册。</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>单用户模式的控制台</title>

      <para>关于 <quote>单用户模式</quote> 详细介绍在 <xref linkend="boot-singleuser">
	这里可以找到。 当您运行单用户模式时只能使用一个控制台，
	没有多个虚拟控制台可使用。 单用户模式的控制台同也可以在
	<filename>/etc/ttys</filename> 文件设置，
	可在这行找到要启动的<literal>控制台</literal>：</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
        <para>这个 <literal>console</literal> 已经注释掉,
        您可编辑这行把 <literal>secure</literal> 改为
	  <literal>insecure</literal>。 假如您这么做，
	  当用单用户进入 FreeBSD 时， 它仍然要求提供
	  <username>root</username> 用户的密码。</para>

	<para><emphasis>在把这个选项改为
	  <literal>insecure</literal></emphasis> 的时候一定要小心，
	  如果您忘记了
	  <username>root</username>用户的密码， 进入单用户会有点麻烦。
	  尽管仍然能进入单用户模式， 但如果您不熟悉它就会非常令人头疼。</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>权限</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD，是 BSD &unix; 的延续， 并基于几个关键的 &unix; 观念。
      从一开始就多处提到 FreeBSD 是一个多用户的操作系统，
      它能分别处理几个同时工作的用户所分配的毫无关联任务。
      并负责为每位用户的硬件设备、 外设、 内存和
      CPU 处理时间作出合理安排。</para>

    <para>因为系统有能力支持多用户， 在每一方面系统都会作出谁能读、
      写和执行的资源权力限制。 这点权限以三个八位元的方式储存着，
      一个是表示文件所属者， 一个是表示文件所属群组， 一个是表示其他人。
      这些数字以下列方式表示：</para>

    <indexterm><primary>权限</primary></indexterm>
    <indexterm>
      <primary>文件权限</primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>数值</entry>
	    <entry>权限</entry>
	    <entry>目录列表</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>不能读，不能写，不能执行</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>不能读，不能写，可执行</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>不能读，可写，不能执行</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>不能读，可写，可执行</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>可读，不能写，不能执行</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>可读，不能写，可执行</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>可读，可写，不能执行</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>可读，可写，可执行</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>目录</primary></indexterm>

    <para>使用命令的 <option>-l</option> (&man.ls.1;)
      参数可以显示出文件的所属者、 所属组和其他人等属性。
      请看以下的例子：</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>使用 <command>ls -l</command> 在每行的开始出现了：</para>

    <screen>-rw-r--r--</screen>

    <para>从左边起的第一个字，告诉我们这个文件是一怎样的文件:
      普通文件?目录?特殊设备?套接字(socket)?或是pseudo-file device?
      在这个例子，<literal>-</literal>表示一个普通文件。
      接下来三个字是<literal>rw-</literal>是文件拥有者的权限。
      再接下来的三个字是<literal>r--</literal>是文件所属群组的权限。
      最後三个字是<literal>r--</literal>是其他人的权限。
      以这一个文件为例，他的权限设定是拥有者可以读写这个文件、群组可以读取、
      其他使用者也能读取这个文件。
      根据上面的表格， 用数字表示这个文件其三部分的权限应该是
      <literal>644</literal>。 </para>

    <para>这样很好，但系统怎样对设备进行权限控制的?
       事实上FreeBSD将大部份设备(的每一个设备)当作一个文件看待，
       用程序能打开、读取、写入数据就如其他的文件一样。
       而设备文件放在<filename>/dev</filename> 目录。
       </para>

    <para>目录也视为一种文件，也有读取、写入、执行的权限。
         但目录的执行权限意义并不与普通文件相同，
         实际上执行权限是进入权限。
         当一个目录是被标示可以执行的时候，那表示它可以被进入，
         利用<quote>cd</quote> (变化目录位置)可以进入。
         这意味着访问这些目录必须是谁才有权力
      (当然目录下的文件也受到访问限制)。</para>

    <para>详细方面，想读取一个目录的列表就必须设为可读权限，
     同时想删除一个已知的文件，就必须把目录下这个文件设为可写
      <emphasis>和</emphasis> 执行权限。
     </para>

    <para>还有更多权限设定，
    但是他们大多用在特殊状况下如一个setuid的执行文件和粘贴性目录，
    如果想要得知有关文件权限和如何设定的更多资讯，请看手册&man.chmod.1;。
     </para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>权限符号</title>
      <indexterm><primary>权限</primary><secondary>符号</secondary></indexterm>

      <para>权限符号，某些时候就是指符号表达式，
      使用八进制的字符给目录或文件分配权限。
	  权限符号的使用语法是 (谁) (作用) (权限)。
      看看下列数值的在那些地方所起什么样的作用:</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>选项</entry>
	      <entry>字母</entry>
	      <entry>介绍</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(谁)</entry>
	    <entry>u</entry>
	    <entry>用户</entry>
	  </row>

	  <row>
	    <entry>(谁)</entry>
	    <entry>g</entry>
	    <entry>所属群体</entry>
	  </row>

	  <row>
	    <entry>(谁)</entry>
	    <entry>o</entry>
	    <entry>其他人</entry>
	  </row>

	  <row>
	    <entry>(谁)</entry>
	    <entry>a</entry>
	    <entry>所有人 (<quote>全部</quote>)</entry>
	  </row>

	  <row>
	    <entry>(作用)</entry>
	    <entry>+</entry>
	    <entry>增加权限</entry>
	  </row>

	  <row>
	    <entry>(作用)</entry>
	    <entry>-</entry>
	    <entry>减少权限</entry>
	  </row>

	  <row>
	    <entry>(作用)</entry>
	    <entry>=</entry>
	    <entry>确定权限</entry>
	  </row>

	  <row>
	    <entry>(权限)</entry>
	    <entry>r</entry>
	    <entry>可读</entry>
	  </row>

	  <row>
	    <entry>(权限)</entry>
	    <entry>w</entry>
	    <entry>可写</entry>
	  </row>

	  <row>
	    <entry>(权限)</entry>
	    <entry>x</entry>
	    <entry>执行</entry>
	  </row>

	  <row>
	    <entry>(权限)</entry>
	    <entry>t</entry>
	    <entry>粘贴位</entry>
	  </row>

	  <row>
	    <entry>(权限)</entry>
	    <entry>s</entry>
	    <entry>设置 UID 或 GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>这些数值 &man.chmod.1; 以习惯标定的。
      举个例子，用以下命令阻止其他人访问
      <replaceable>FILE</replaceable>文件:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>倘若对一个文件作太多的变化设置可用逗号分开，
      在下面的例子里，
      可以去掉<replaceable>FILE</replaceable>文件的群体和 <quote>全部</quote> 可写权限，
      但所有人都可以有执行权限:
      </para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>

<!--
    <para>大部份用户没有注意到这点，
      应当指出这个方法仅使用在配置一个文件权限，不会添加或删除(文件)。
      </para>
-->
    </sect2>
  </sect1>

  <sect1 id="dirstructure">
    <title>目录架构</title>
    <indexterm><primary>目录层次</primary></indexterm>

    <para>目录层次是理解一个系统的重要基础，
      最重要的莫过于它的根目录 <quote>/</quote>，
      这个目录在启动时就就挂上， 它包含了启动时所需的基本系统。
      这个根目录同样包含了您想挂上的每一个文件系统。</para>

    <para>挂接点 (mount point) 是新增的文件系统根目录接入现有文件系统的目录，
      标准的挂接点包含
      <filename>/usr</filename>、<filename>/var</filename>、
      <filename>/mnt</filename>和 <filename>/cdrom</filename>。
      这些目录通常被纪录在 <filename>/etc/fstab</filename> 文件。
      <filename>/etc/fstab</filename>
      文件是一个纪录系统上的多样文件系统和挂接点的表格，
      <filename>/etc/fstab</filename>
      文件会依据这一个脚本 &man.rc.8; 在开机的时候被自动挂上，
      除非加上 <option>noauto</option> (非自动) 这个选项。
      请查阅手册 &man.fstab.5; 以了解
      <filename>/etc/fstab</filename> 所用的格式和他包含的选项。</para>

    <para>您可以由 &man.hier.7;得知 man page 提供了完整的目录架构的介绍。
      现在，我们介绍一般目录以供参考。</para>

    <para>
      <informaltable frame="none">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>目录</entry>
	      <entry>介绍</entry>
	    </row>
	  </thead>
	  <tbody>
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>文件系统的根目录。</entry>
            </row>

	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>在单个用户和多用户环境下的基本工具目录。
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>在操作系统在启动加载期间所用的程序和配置。
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>默认每步引导启动的配置内容，请查阅&man.loader.conf.5;。
       </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>设备接点，请查阅 &man.intro.4;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>系统启动的配置和脚本。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>系统默认的启动配置和脚本，请参考 &man.rc.8; 。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>关系到邮件系统运作的配置， 请参考 &man.sendmail.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry><command>named</command> 配置文件，请参考 &man.named.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>每天、每星期和每月周期性地运行的脚本，
		请通过 &man.cron.8;查阅 &man.periodic.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry><command>ppp</command>配置文件，请查阅&man.ppp.8;。
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>由管理员习惯使用挂接点的临时空目录。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>运行中的文件系统，请参阅 &man.procfs.5;
	        和 &man.mount.procfs.8;。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry><username>root</username>用户的Home(主)目录。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>在单个用户和多用户环境下的存放系统程序和管理所需的基本实用目录。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
	      <entry>持久独一无二的程序环境。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>存放临时文件，通常存放一些系统重启后不需要保护的 &man.mfs.8;
		基于内存的文件系统。</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>存放大多数用户的应用软件。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>存放实用命令，程序设计工具，和应用软件。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>存放标准 C include 文件.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>存放库文件。</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>存放各种实用工具的数据文件。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>存放系统实用或后台程序 (从另外的程序启动执行)。</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>存放本地执行文件， 库文件等等，
	        同时也是 FreeBSD ports 安装的默认安装目录。
	        <filename>/usr/local</filename> 在
	        <filename>/usr</filename> 总体布置请查阅 man.hier.7;。
	        man 目录例外， 它们直接放在
	        <filename>/usr/local</filename> 而不是
	        <filename>/usr/local/share</filename> 下，
	        而 ports 说明文档在
	        <filename>share/doc/<replaceable>port</replaceable></filename>。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>通过联编 <filename>/usr/src</filename> 得到的目标文件。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
	      <entry>存放 FreeBSD 收集到的 ports (可选)。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>存放系统后台程序 和 系统工具 (由用户执行)。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>存放架构独立的文件。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>存放 BSD 或者本地源码文件。</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>存放 X11R6 可执行文件、 库文件、 配置文件等的目录(可选)。
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>存放多用途记录、临时性、短期的和打印假脱机系统文件.
	      </entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>存放各种的系统记录文件。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>存放用户mailbox(一种邮件存放格式)文件。</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>各种打印机和邮件系统spooling(回环)的目录。
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>存放系统重启前受控制的临时文件。</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>NIS 映射。</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="disk-organization">
      <title>磁盘组织</title>

      <para>FreeBSD 查找文件的最小单位是文件名。
	而文件名区分大小写，这就意味着
	<filename>readme.txt</filename> 和 <filename>README.TXT</filename>
	是两个不相同的文件。 FreeBSD 不凭文件扩展名
	(<filename>.txt</filename>) 去识别这个文件是
	程序、或是文档、或是其他格式的数据。</para>

      <para>各种文件存放在目录里。 一个目录可以含有许许多多的文件，
	允许含有其他的目录，同样允许您添加不同层次的目录在里面。
	可以轻松地组织您的数据。</para>

      <para>可以通过文件或目录名来指定文件和目录，
	在目录名后面加上一个斜线， <literal>/</literal>，
	如果需要的话。 如果您有一个名为 <filename>foo</filename>
	的目录， 它包含另一个目录
	<filename>bar</filename>， 后者重包括一个叫
	<filename>readme.txt</filename> 的文件， 则全名， 或者说到文件的
	<firstterm>路径</firstterm> 就是
	<filename>foo/bar/readme.txt</filename>。</para>

      <para>在文件系统里目录和文件的作用是存储数据。
	每一个文件系统都正确含有一个顶级目录<firstterm>根目录</firstterm>，
	这个根目录包含其他目录。</para>

      <para>您也许在其他的一些操作系统碰到类似这里的情况，
	当然也有不同的情况。 举些例子， &ms-dos; 是用
	<literal>\</literal> 分隔文件名或目录名，
	而 &macos; 则使用<literal>:</literal>。</para>

      <para>FreeBSD在路径方面不使用驱动器名符号或驱动器名称，
	在FreeBSD里您不能这样使用：
	<filename>c:/foo/bar/readme.txt</filename>。</para>

      <para>为了代替(驱动器名符号)， 一个文件系统会指定 <firstterm>根
	文件系统</firstterm>， 根文件系统的根目录是
	<literal>/</literal>。 其他每一个文件系统
	<firstterm>挂接在</firstterm>根文件系统下。
	无论有多少磁盘在FreeBSD 系统里， 每个磁盘都会以目录的方式加上。</para>

      <para>假设您有三个文件系统， 名为 <literal>A</literal>、
	<literal>B</literal>  和 <literal>C</literal>。
	每个文件系统有一个根目录， 而各自含有两个其他的目录， 名为
	<literal>A1</literal>, <literal>A2</literal> (
	<literal>B1</literal>, <literal>B2</literal> 和
	<literal>C1</literal>, <literal>C2</literal>)。</para>

      <para>看看 <literal>A</literal> 这个根文件系统。  假如您用
	<command>ls</command> 命令来查看这个目录您会见到两个子目录:
	 <literal>A1</literal> 和 <literal>A2</literal>。
	 这个目录树是这个样子:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>一个文件系统必须挂到另一个文件系统的某一目录，
	所以现在假设把 <literal>B</literal> 文件系统挂到
	<literal>A1</literal>目录， 那 <literal>B</literal> 根目录因此代替
	了 <literal>A1</literal>，而显示出 <literal>B</literal>
	目录(的内容)：</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>无论<literal>B1</literal> 或
	<literal>B2</literal> 目录在那里而延伸出来的路径必须为
	<filename>/A1/B1</filename> 或 <filename>/A1/B2</filename>。
	而在 <filename>/A1</filename> 里原有的文件会临时隐藏。
	想这些文件再出现把 <literal>B</literal> 从 A
	<firstterm>挂接释放</firstterm>。</para>

      <para>把 <literal>B</literal> 挂接在 <literal>A2</literal>
	那图表的样子就是这样子:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>这个路径分别是 <filename>/A2/B1</filename> 和
	<filename>/A2/B2</filename> 。</para>

      <para>文件系统能把顶部挂接上另一个文件系统上。
	继续这个例子， 把 <literal>C</literal> 文件系统挂接在
	<literal>B</literal> 文件系统里的 <literal>B1</literal> 目录，
	排列如下:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>或者把 <literal>C</literal> 文件系统挂接在 <literal>A</literal>
	文件系统里的<literal>A1</literal>目录：</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>假如您熟悉 &ms-dos;并知到<command>join</command> 命令，
	尽管不相同，其实是相似的。</para>

      <para>这方面不是普通知识而且涉及到您自己所关心的，
	当您安装FreeBSD并在以后添加新磁盘时，
	您必须知到该如何新建文件系统和挂接上。</para>

      <para>(FreeBSD系统)它有一个主要的根文件系统， 不需要另外新建立，
	但当需要手工处理时，这是一个有用的知识。</para>

      <itemizedlist>
	<title>多样性文件系统的益处</title>

	<listitem>
	  <para>不同的文件系统可用不同的 <firstterm>挂接参数</firstterm>。
	    举些例子， 仔细想一下， 根文件系统能用只读的方的方式挂接上，
	    防止不经意删除或编辑到一个危险的文件。
	    把各用户能写入的文件系统分开，
	    像<filename>/home</filename>这样，
	    由另外的文件系统分别用
	    <firstterm>nosuid</firstterm> 参数挂接，这个参数防止
	    <firstterm>suid</firstterm>/<firstterm>guid</firstterm>
	    在执行这个文件系统中的文件时生效， 从而缓解了一些安全问题。</para>
	</listitem>

	<listitem>
	  <para>FreeBSD 对一个文件系统的文件布局自动优化，
	    并依赖文件系统的使用习惯。
	    所以一个文件系统应有一个针对大量小型文件频繁写入的优化，
	    另外大型文件系统的优化也应落实。</para>
	</listitem>

	<listitem>
	  <para>FreeBSD 的文件系统能够在断电时尽可能避免损失。
	    然而， 在关键点时的电源失效仍然可能会破坏文件系统的结构。
	    将您的文件系统分成多个有助于分散风险， 并方便备份和恢复。</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>统一文件系统的益处</title>

	<listitem>
	  <para>文件系统是固定大小的。
	    当安装FreeBSD时新建一个文件系统并设定一个大小，
	    您会在稍后发觉到必须去建一个大的分区。
	    如果配置不当， 则需要备份、 重新创建文件系统，
	    然后再恢复数据。</para>

	  <important>
	    <para>FreeBSD&nbsp;4.4 或更高的版本提供了 &man.growfs.8;
	      命令。 这使得能够实时地调整文件系统的大小，
	      因而不再受其限制。</para>
	  </important>
	</listitem>
      </itemizedlist>

      <para>文件系统是和分区一一对应的。
	这里的分区和常用的术语分区 (例如， &ms-dos; 分区)
	的意思并不一样， 这是由于 &os; 的 &unix; 传统造成的。
	每一个分区使用一个从 <literal>a</literal> 到
	<literal>h</literal> 的字母来表示。 每个分区只能包含一个文件系统，
	这意味着文件系统通常可以由它们在文件系统目录结构中的挂接点，
	或对应的分区字母来表示。</para>

      <para>FreeBSD 的 <firstterm>交换分区</firstterm> 也需要使用磁盘空间。
	  交换分区是给 FreeBSD 作 <firstterm>虚拟内存</firstterm> 使用的，
	这样能令您的计算机有更多的内存可使用，
	当FreeBSD在运行而内存不够的时候，
	它会把其他一些可转移的数据转移到交换分区，
	空出内存的位置以供使用。</para>

      <para>某些 partitions 的用途是确定的。</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>分区</entry>

	      <entry>约定</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>通常指定为根文件系统</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>通常指定为交换分区</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>通常它和所在的 slice 大小相同。
		<literal>c</literal> 分区上工作时必定会影响到事整个
		slice (举个例子，坏块扫描器)。
		您通常不愿意在这个partition建立文件系统。</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>分区 <literal>d</literal> 曾经有特殊的含义，
		虽然(对我们来说)早已远离而去。
		但直到今天，一些工具在
		分区 <literal>d</literal>上运行会发生古怪事情， 所以
		<application>sysinstall</application> 通常不建立分区
		<literal>d</literal>。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>每一个包含了文件系统的分区被保存在
	FreeBSD 称为 <firstterm>slice</firstterm> 的部分上。
	Slice 是一个 FreeBSD 术语， 通常被叫做分区，
	再次强调， 这是由于
	FreeBSD 的 &unix; 背景。 Slices 有其编号， 从1到4。</para>

	<indexterm><primary>slices</primary></indexterm>
	<indexterm><primary>partitions</primary></indexterm>
	<indexterm><primary>专用 (dangerously dedicated)</primary></indexterm>

      <para>Slice 编号在设备名后面， 并有一个 <literal>s</literal>
	前缀， 从 1 开始。 因此 <quote>da0<emphasis>s1</emphasis></quote>
	是第一个 SCSI 驱动器的第一个 slice。 每个磁盘上只能有四个物理的
	slices， 但您可以在物理 slice 中使用适当的类型来创建逻辑 slice。
	这些扩展 slice 编号从 5 开始， 因此
	<quote>ad0<emphasis>s5</emphasis></quote> 是第一个 IDE 磁盘中的第一个
	扩展 slice。 文件系统所使用的设备应该占满 slice。</para> 

      <para>Slices, <quote>专项指定</quote> 物理驱动器，
	和其他驱动器都包含<firstterm>partitions</firstterm>，
	 那几个的partitions都是用字母
	从 <literal>a</literal> 到 <literal>h</literal>来标定的，
	而这些字母都在驱动器名字之后，所以
	<quote>da0<emphasis>a</emphasis></quote> 是指首个da设备的 a partition，
	而那个就是 <quote>专项指定</quote>。
	<quote>ad1s3<emphasis>e</emphasis></quote> 是指IDE磁盘第三个slice的第五个partition。
	</para>

      <para>最终，每个磁盘都被系统识别。
      一个磁盘名字是用磁盘类型代码和编号来标识的，
      它不像slices，磁盘的编号是由0开始的。
      对应代码请看这里所列出的<xref linkend="basics-dev-codes">。
	</para>

      <para>当提供一个partition名字给FreeBSD时，
      slice 和 磁盘所必须有这个partition，还应当提供所partition所涉及
      到的slice和磁盘的名字。可这样列出:
	磁盘名称,<literal>s</literal>,slice 编号,和partition标定字母。
	例子请看这里
	<xref linkend="basics-disk-slice-part">。</para>

      <para><xref linkend="basics-concept-disk-model">
      这里显示了一个磁盘的布局，有更清楚的帮助。
	</para>

      <para>在安装FreeBSD时，您首先要配置好磁盘slices，
      然后在FreeBSD使用的slice上建立partitions。
      并在每个partition上建立一个文件系统(或交换分区)，
      和指定文件系统的挂接位置。
	</para>

      <table frame="none" pgwide="1" id="basics-dev-codes">
	<title>磁盘设备的代码</title>

	<tgroup cols="2">
          <colspec colwidth="1*">
          <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>代码</entry>

	      <entry>说明</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

	      <entry>ATAPI (IDE) 磁盘</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>

	      <entry>SCSI 直接存取磁盘</entry>
	    </row>

	    <row>
	      <entry><devicename>acd</devicename></entry>

	      <entry>ATAPI (IDE) 光驱</entry>
	    </row>

	    <row>
	      <entry><devicename>cd</devicename></entry>

	      <entry>SCSI 光驱</entry>
	    </row>

	    <row>
	      <entry><devicename>fd</devicename></entry>

	      <entry>软驱</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example id="basics-disk-slice-part">
	<title>样例磁盘, Slice, 和 Partition 它们的命名</title>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*">
            <colspec colwidth="5*">

	    <thead>
	      <row>
		<entry>命名</entry>

		<entry>说明</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>

		<entry>在首个IDE磁盘(<literal>ad0</literal>)上的
              第一个slice (<literal>s1</literal>)里的
              第一个partition (<literal>a</literal>)。
		  </entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>

		<entry>在第二个SCSI磁盘(<literal>da1</literal>)上的
               第二个slice(<literal>s2</literal>)里的
               第五个partition(<literal>e</literal>)。
		  </entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="basics-concept-disk-model">
	<title>一个磁盘的布局</title>

	<para>
	   从在系统里的首个IDE磁盘图表可以显示出FreeBSD的见解。
	   假设磁盘大小为4&nbsp;GB，它里面包含了两个2&nbsp;GB 大小的slices (但在&ms-dos;叫partitions)。
	   首个slice是一个&ms-dos;磁盘叫<devicename>C:</devicename>，
	   而第二个slice是FreeBSD配置好的slice。
	   FreeBSD配置好的slice有三个partitions和另一个交换分区。
	  </para>

	<para>
        这三个partitions各自控制一个文件系。
        partition<literal>a</literal>用于根文件系统，
        partition<literal>e</literal>用于<filename>/var</filename>目录层，
        partition<literal>f</literal>用于<filename>/usr</filename>目录层。
	  </para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout" format="EPS">
          </imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     >  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     > referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     > referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       > filesystem, all
|                 |     > referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     > referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>



  <sect1 id="mount-unmount">
    <title>文件系统的挂接和卸下</title>

    <para>
      这种文件系统就像一棵树那样用<filename>/</filename>确立根部，
      是比较理想的文件系统。
      而<filename>/dev</filename>、 <filename>/usr</filename>和其他目录
      就是根目录的分枝，
      另外这些目录可以再分枝，例如<filename>/usr/local</filename>。
      </para>

    <indexterm><primary>根文件系统</primary></indexterm>
    <para>应该考虑给某些目录一些空间从而分散文件系统。
      <filename>/var</filename>
      之下包含目录 <filename>log/</filename>，目录<filename>spool/</filename>，
      和不同类型的临时文件，很可能把它塞满。
      把什么都塞进根文件系统不是一个好主意，
      好的做法是应该把 <filename>/var</filename> 从
      <filename>/</filename>分离出去。</para>

    <para>另一个要考虑的是，给物理设备或虚拟磁盘这些自带空间的文件系统确定目录结构树。
    例如 <link
	linkend="network-nfs">网络文件系统</link> 或光驱的挂接。
      </para>

    <sect2 id="disks-fstab">
      <title><filename>fstab</filename> 文件</title>
      <indexterm>
	<primary>文件系统</primary>
	<secondary>使用fstab的挂接</secondary>
      </indexterm>

      <para>在<link linkend="boot">导入处理</link>期间，
	自动挂上<filename>/etc/fstab</filename>所列出的文件系统。
	(除非他们注明为<option>noauto</option> 选项)。
	</para>

      <para> <filename>/etc/fstab</filename> 文件包含的各行的列表格式如下:
	</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>设备名称(设备必须存在)， 说明在
	      <xref linkend="disks-naming">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem><para>目录 (目录必须存在)，
	      用在那个挂接上的文件系统上。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem><para>文件系统类型，请通过&man.mount.8;查阅。
		 默认的FreeBSD文件系统类型是<literal>ufs</literal>。
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem><para>
          设为可读写文件系统的<option>rw</option>选项，
          或设为只读文件系统的<option>ro</option>选项，
          或其他一些选项，可随意选一个。
	      一个常用的选项 <option>noauto</option> 用在不需在导入期间挂接的文件系统。
	      其他的选项在 &man.mount.8; 手册里列出。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

         <listitem><para>&man.dump.8; 使用这项去决定那个
             文件系统必须移贮。假如缺少这项，默认的数值为0。
             </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>这一项决定文件系统的检查顺序，
           文件系统想跳过检查应将<literal>passno</literal>设为0。
           根文件系统(那个是在每方面开始之前必须检查的)
           应该将它的 <literal>passno</literal> 设为1，
           其他文件系统的 <literal>passno</literal>
           必须把数值设到大于1。假如多个文件系统的<literal>passno</literal>的值相同，
           那么&man.fsck.8; 在充许的情况下将尝试并行地去检查文件系统。
           </para>
         </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title> <command>mount</command> 命令</title>
      <indexterm>
	<primary>文件系统</primary>
	<secondary>挂接</secondary>
      </indexterm>

      <para>这个 &man.mount.8; 命令是挂接文件系统的基本运用。
	</para>

      <para>使用最多的基本格式:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>它的选项非常多，而&man.mount.8; 手册同样提及， 但常用的都在这里:</para>

      <variablelist>
	<title>挂接的各种选项</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>挂接<filename>/etc/fstab</filename>里所有列出的文件系统。
	      除非标记为 <quote>noauto</quote> 或作了排除在外的
	      <option>-t</option> 类型标记，或者在这之前已挂上。
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>除了实际上系统调用以外，可以完成任何事情，这个选项是和
	    <option>-v</option>参数一起连在一块使用，可以决定&man.mount.8;所做的事情。
     </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>强制去挂接一个未知的文件系统(会有危险)，
	    或当把一个文件系统挂接状态由可读写降为只读时，强制撤消可写通道。
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
          <term><option>-r</option></term>

	  <listitem>
	    <para>以只读的方式挂上文件系。
	      使用<option>-o</option> 选项加<option>rdonly</option>是一样的。
       </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>根据给出的文件系统类型挂接文件系统，
	       假如给于<option>-a</option>选项，仅挂接这个类型的文件系统。
	      </para>

	    <para><quote>ufs</quote> 是默认的文件系统类型。
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>在文件系统上修改挂接选项。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>版本模式。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>以可读写方式挂接文件系统。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>The <option>-o</option> 选项采用一个逗号分开以下多个选项:</para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	  <listitem>
	    <para>拒绝把文件系统识别为特别的设备。这是一个有用的安全选项。
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
              <para>不允许文件系统上的二进制程序执行。这也是一个有用的安全选项。
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>不允许文件系统上的 setuid 或 setgid 标记生效。这也是一个有用的安全选项。
	      </para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title> <command>umount</command> 命令</title>
      <indexterm>
	<primary>文件系统</primary>
	<secondary>卸下</secondary>
      </indexterm>

      <para>&man.umount.8; 命令同样采用一个参数、一个挂接点、一个设备名。
      或采用<option>-a</option>选项，又或采用<option>-A</option>选项。
	</para>

      <para>所有格式都可采用 <option>-f</option> 去强行卸下，
        或采用<option>-v</option> 用那适当的版本。 但警告，采用
        <option>-f</option>并不是一个好主意，
        强行卸下文件系统可能损坏计算机或破坏文件系统上的数据。
        </para>

      <para><option>-a</option> 和 <option>-A</option> 会卸下所有已挂接的文件系，
	可能通过<option>-t</option>后面列出的文件系统进行修改，
	但无论如何，<option>-A</option>都不会尝试去卸下根文件系统。
	</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>进程</title>

    <para>FreeBSD 是一个多任务操作系统。
    这就意味着好像一次可以运行一个以上的程序。
    每个占用一定时间运行的程序就叫<firstterm>process</firstterm>。
    每个程序启动运行时至少有一个新进程，并在所有运行的时候保持有一个系统进程的编号，
    而一直由系统对它监管。
    </para>

    <para>每个进程用来标识的一个编号就叫
      <firstterm>进程 ID</firstterm>， 或叫 <firstterm>PID</firstterm>。
      而且，就像文件那样，每个进程也有所属用户和所属群体。
      所属用户和所属群体使用在这方面:确定这个进程可以打开那些文件和那些设备，
      从而在初期使用文件的权限。 多数的进程都同样有一个父进程，
      而进程是依靠父进程来启动的。
      例如，假如您把命令输入到shell里那shell是一个进程，而您运行的各个命令同样是进程，
      那么，shell就是您各个运行进程的父进程。
      而这方面有一个例外的进程就叫&man.init.8;。
      <command>init</command>始终是首个进程,，所以他的PID始终是1，
      而<command>init</command>在FreeBSD起动时由内核自动启动。</para>

    <para>在系统上，有两个命令对进程观察非常有用:&man.ps.1; 和 &man.top.1;。
    这个<command>ps</command>命令作用是观察当前运行进程的状态，
    显示他们的PID，使用了多少内存，它们启动的命令行。
    而<command>top</command>命令则是显示所有运行进程，并在以秒计的短时内更新数据。
    您能交互式的观察您计算机的工作。
    </para>

    <para>默认情况下， <command>ps</command>仅显示出您自己所运行的命令。
     例如:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>在这个例子里您可看到，从 &man.ps.1; 输出的每一列是有规律的。
       <literal>PID</literal> 就是进程ID，这个较早前已讨论过了。
        PID号的分配由 1一直上升直到99999，
      当您运行到超过限制时，这些编号会回转分配。
      <literal>TT</literal>这一列显示了程序运行所在的终端， 目前可以安全地忽略。
      <literal>STAT</literal> 显示程序的状态，也可以安全地被忽略。
      <literal>TIME</literal>是程序在CPU处理时间&mdash;运行的时间量，
      并不是指您程序启动到现在的所用的时间。
      许多程序碰巧遇到某方面在他们之前要花费大量CPU处理时间时，他们就必须等候。

      Finally, <literal>COMMAND</literal> is the command line that was used to
      run the program.</para>

    <para>&man.ps.1;支持使用各种选项去改变显示出来的内容，
     最有用的一个就是<literal>auxww</literal>。
     <option>a</option>选项显示出所有运行进程的内容， 而不仅仅是您的进程。
      <option>u</option>选项显示出进程所归属的用户名字以及内存使用，
      <option>x</option> 选项显示出后台进程。 而
      <option>ww</option> 选项表示为 &man.ps.1; 把整个命令行全部显示完，
      而不是由于命令行过长就把它从屏幕上截去。</para>

    <para>下面和从&man.top.1;输出是类似的，一个示例式对话就象这样子:
      </para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>这个输出分成两部份。 前面部份(起始前五行)
      显示了:运行于最后进程的PID、 系统负载均衡
      (那个是指系统繁忙时的调节方式)、 系统正常运行时间 (
      指从启动算起所用的时间) 和当前时间。  前面部份另外的图表
      涉及:多少进程在运行(这个情况是47)， 多少内存和多少交换分区在使用，
      和在不同CPU状态里系统消耗多少时间。</para>

    <para>在那下面一连串的纵列和从&man.ps.1;输出的的内存是相似的。
    如以前&man.ps.1;一样，您能见到:PID、用户名、CPU处理时间合计、运行的命令。
     &man.top.1;默认是显示您的进程所用内存空间的合计。
     内存空间这里分成两列，一列为总体大小，另一列是必须请求驻留大小是多少内存&mdash;总体大小。
     而驻留大小实际上是瞬间使用的多少。
     在以上那个例子，您会看到那<application>&netscape;</application>总计需要30&nbsp;MB内存，
     但实际只用了9&nbsp;MB。
     </para>

    <para>&man.top.1; 每两秒自动刷新一次，您可以用<option>s</option>改变刷新的秒数。
      </para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>守护进程，信号和杀死进程</title>

    <para>当您运行一个编辑器时它是很容易控制的，告诉它去加载文件它就加载。
    您之所以能这样做，是因为编辑器提供这样便利去这样做，和因为有编辑器去附上的<firstterm>终端</firstterm>。
    一些程序在运行中不需要连续的用户输入，一有机会就从终端里分离到后台去。
    例如，一个web系统整天都在作web请求的响应，他不需要您输入任何东西就能完成，
    这个类别的另一个例子就是把email的传送。
    </para>

    <para>我们把那些程序叫<firstterm>守护进程</firstterm>。
    守护神是希腊神话中的一些人物，非正非邪，他们是些守护小幽灵，大体上为人类作出贡献。
    许多类似web系统或mail系统的系统对于今天仍有用途，
    这就是为什么在那么长的时间里，BSD的吉祥物保持为一双鞋加一把钢叉的守护神模样。
    </para>

    <para>守护进程的程序命名通常在最后加一个<quote>d</quote>。
    <application>BIND</application>是伯克莱互联网络守护进程命名(and the actual program that executes is called
      <command>named</command>)，
      <application>Apache</application>web系统的程序就叫<command>httpd</command>，
      在行式打印机上的打印守护进程就是<command>lpd</command>。
      这只是一种惯例，不是标准或硬性规定。
      例如，为<application>Sendmail</application>而应用的主要mail守护进程就叫<command>sendmail</command>，
      却不叫<command>maild</command>，这和您推测的一样。
      </para>

    <para>有时您必须和一个守护进程的程序通信，这些通信就叫<firstterm>信号</firstterm>。
    您能发送一个信号给守护进程(或有关的另一些运行进程)与它进行通信，
    各个不同的信号各自就是一个数字编号，而您所发送的&mdash;数字编号各自有一个特殊的含义。
    有些人把信号解悉为'请求'，并在'请求'的文档里告诉您怎样把信号理解为请求。
     您只能给所属于您的进程发信号，假如您给其他人的进程发信号，
     进程就会用&man.kill.1; 或 &man.kill.2;权限进行拒绝。
      当然,<username>root</username> 用户会例外，它能把各种信号发送给每个进程。
      </para>

    <para>在某些案例里，FreeBSD也会向应用软件发送信号。
    假如一个应用软件含有恶意写入并试图去访问内存，那是不可想象的，FreeBSD会向那个进程发送
    <firstterm>段式违规</firstterm> 信号 (<literal>SIGSEGV</literal>)。
    假如一个应用软件使用&man.alarm.3;系统去进行周期性调用闹钟功能，每当达到时间时，
    FreeBSD会向应用软件发送闹钟信号(<literal>SIGALRM</literal>)。
    </para>

    <para>有两个信号可以停止进程:<literal>SIGTERM</literal> 和 <literal>SIGKILL</literal>。
      <literal>SIGTERM</literal>比较友好，进程能<emphasis>捕捉</emphasis>这个信号，
      根据您的需要来关闭程序。在关闭程序之前，您可以结束打开的记录文件和完成正在做的任务。
      在一些案例里，假如进程正在进行作业而且不能中断，那么进程可以忽略这个<literal>SIGTERM</literal>信号。
     </para>

    <para>对于<literal>SIGKILL</literal>信号，进程是不能忽略的。 这是一个
       '<quote>我不管您在做什么,立刻停止</quote>'的信号。
      假如您发送<literal>SIGKILL</literal>信号给进程，
      FreeBSD就将进程停止在那里。<footnote>
	<para>有点不正确&mdash;少数的东西是不能中断的。
	  例如，假如进程试图从网络上另一个计算机的一个文件读取，
	  而那个的计算机会因为某些原因拿走了这个文件，那这个进程从上术情况来看是<quote>不能中断</quote>。
      最终这个进程会超时，典型的两分钟。一出现超时进程将被杀死。
    </para>
      </footnote>.</para>

    <para>您可能会去使用
      <literal>SIGHUP</literal>、 <literal>SIGUSR1</literal> 和
      <literal>SIGUSR2</literal>信号。  这都是些通用的信号，各种应用程序都可以应用
      在各方面的信号发送。
      </para>

    <para>假如您改变了web系统的配置文件&mdash;并想web系统去重读它的配置，
    您可以停止然后再启动<command>httpd</command>。但这样做web系统会导致一个短暂
    的中断周期，那样是不受欢迎的。几乎所有的守护进程在编写时，都会指定对<literal>SIGHUP</literal>
    信号进行响应从而重读配置文件。
    所以最好的方法就是不去杀死并重启<command>httpd</command>，而是发一个<literal>SIGHUP</literal>信号给他。
    因为在这方面没有一个标准，不同的守护进程有不同的用法，所以不了解时应读一下守护进程的文档。
     </para>

    <para>发送信号可用&man.kill.1; 命令， 请参考&man.kill.1;所列出的例子。
     </para>

    <procedure>
      <title>发送一个信号给进程</title>

      <para>这个例子显示了怎样去发一个信号给&man.inetd.8;。
      <command>inetd</command>配置文件是<filename>/etc/inetd.conf</filename>，
      如果想<command>inetd</command> 去重读文件系统的话，可以给它发一个<literal>SIGHUP</literal>
      信号。
	  </para>

      <step>
	<para>寻找您要发送信号的进程ID，可以用&man.ps.1; 加 &man.grep.1;来完成。
      &man.grep.1;命令被用在搜索输出方面，搜索您指定的字符串。
     这命令是由普通用户来执行的，而&man.inetd.8;是<username>root</username>用户运行的，
     所以必须给&man.ps.1;带上<option>ax</option>选项。
     </para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>得出 &man.inetd.8; PID号是198。 有时
	  <literal>grep inetd</literal> 命令也出现在输出中，
	  这是因为在这方面 &man.ps.1; 也是寻找列表中运行进程。
	  </para>
      </step>

      <step>
	<para>使用 &man.kill.1; 去发送信号。 因为 &man.inetd.8;
	  是由 <username>root</username>启动的， 您必须使用 &man.su.1; 去
	  变为 <username>root</username> 用户。</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>和大多数 &unix; 命令一样， &man.kill.1; 完成任务之是没有内容输出的。
	假如您发送信号给一个不属于您的进程，
	您会看到 <errorname>kill:
	    <replaceable>PID</replaceable>: Operation not
	    permitted</errorname>.
     假如输错了PID号，把信号发送到其他进程，那是坏事。
     或者您侥幸，把信号发送到不存在的进程，
     您会看见 <errorname>kill:
	    <replaceable>PID</replaceable>: No such process</errorname>.</para>

	<note>
	  <title>为什么使用 <command>/bin/kill</command>?</title>

	  <para>许多shell提供了内建<command>kill</command>命令，
	    这样， shell就能直接发送信号，而不是运行 <filename>/bin/kill</filename>。
	    这点非常有用， 但不同shell有不同的语法来指定发送信号的名字，
        与其试图把它们学完倒不如简单地直接使用
        <command>/bin/kill <replaceable>...</replaceable></command>。
        </para>
	</note>
      </step>
    </procedure>

    <para>发送其他的信号也很相似，只要在命令行替换<literal>TERM</literal>或<literal>KILL</literal>就行了。
     </para>

    <important>
      <para>在系统上随意杀死进程是个坏主意，特别是&man.init.8;，它的进程ID是1，它非常特殊。
	可以运行 <command>/bin/kill -s KILL 1</command> 命令来让系统迅速关机。
	当您按下 <keycap>Return</keycap> 键时， <emphasis>始终</emphasis> 必须
	去详细检查您所运行的 &man.kill.1;。

 </para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>shells</primary></indexterm>
    <indexterm><primary>命令行</primary></indexterm>

    <para>在FreeBSD里，每日有一大堆工作是在命令行的界面完成的,那就叫做shell。
    一个shell的主要功能就是从输入是取得命令然后去执行他。
    许多的shell同样能帮我们完成内建的每日功能，例如:文件管理、文件寻找、命令行编辑、
    宏指令和环境变量。FreeBSD内含了一些shell，例如:<command>sh</command>、Bourne Shell、
    <command>tcsh</command>和改良过的C-shell。
    另外也有些shell也可在FreeBSD的Ports得到，例如:<command>zsh</command>和<command>bash</command>。
    </para>

    <para>您想使用那一种shell取决于您的喜好，
    假如您是C程序设计师，您可能选择一个C-like shell例如<command>tcsh</command>。
    假如您是从Linux过来的或是一个命令行的新手，您可能会试一下<command>bash</command>。
    这一点告诉我们每一个shell都有各自的特性，可能适用于您的工作环境，也可能不适用于您的工作环境。
     </para>

    <para>每个shell都有一个共通点就是文件名补全。
          输入命令或文件名的前几个字，然后按<keycap>Tab</keycap>键，就能靠shell的自动补全功能得出
          命令或文件名。这里有一个例子，假设您有两个文件叫
      <filename>foobar</filename> 和<filename>foo.bar</filename>，而您想删除
      <filename>foo.bar</filename>，  可这样在键盘上输入
      <command>rm fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>。</para>

    <para>那么shell就会输出 <command>rm
      foo[BEEP].bar</command>。</para>

    <para>这个[BEEP] 是这控制台铃声， 那个是告诉我们它不能完成文件名补全，因为有多个文件名符合。
      <filename>foobar</filename> 和
      <filename>foo.bar</filename> 都是以 <literal>fo</literal>开头， 它只可以补全到
      <literal>foo</literal>。  输入
      <literal>.</literal>并再按一次 <keycap>Tab</keycap>，shell才把其余的文件名全部显示出来。
      </para>
    <indexterm><primary>环境变量</primary></indexterm>

    <para>另一个特点就是shell利用环境变量运行。环境变量是贮存在shell环境空间上相对应的键和可变值，
      这个空间能够补程序从shell里读出，而且包含了许多程序的配置。
      这个一个常用环境变量列和其含义的列表：</para>
    <indexterm><primary>环境变量</primary></indexterm>

    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>变量</entry>
	    <entry>说明</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>当前登录进入的用户名。</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>搜索程序路径，以两点的冒号分隔开。</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>假如有这个变量的话，就是X11显示器的网络名称。
     </entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>当前所用的shell。</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>用户终端的名字，通常用在确定终端的能力。</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>各种终端功能所用终端分离编码的基本数据项目。</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>操作系统类型，默认是FreeBSD。</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>是指系统上运行的CPU体系结构。
	      </entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>用户首选的文本编辑器。</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>用户首选的文本页面调度程序 。</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>搜索联机手册路径，以两点的冒号分隔开。</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>不同的shell设置环境变量也不相同。举个例子，
      在如<command>tcsh</command> 和 <command>csh</command>这样的C-Style shell，
      您必须使用<command>setenv</command>去设置环境变量。
      而在如<command>sh</command>和<command>bash</command>这样的Bourne shell，
      您必须使用<command>export</command>去设置当前环境变量。
      再举个例子，要去设置或改变<envar>EDITOR</envar>环境变量，
      在<command>csh</command>或<command>tcsh</command>下将<envar>EDITOR</envar>设为
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>而在Bourne shell下，则是:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>您也可以在命令行上加一个<literal>$</literal>字符在变量之前从而取得环境变量。
      举个例子，用<command>echo $TERM</command> 就会显示出<envar>$TERM</envar>的设定值，
      其实就是shell取得<envar>$TERM</envar>并传给<command>echo</command>来显示的。</para>

    <para>shell里有许多特别的字符代表着特别的资料，我们把叫做meta-characters。
      最常用的就是<literal>*</literal>字符，它可代表文件名的任何字符。
      这些特别字符应用到文件名全域方面。假如，输入
      <command>echo *</command>和输入
      <command>ls</command>的效果是相同的，其实就是 shell 取得了全部符合
      <literal>*</literal>的文件名，并传给
      <command>echo</command> 在命令行下显示出来。</para>

    <para>为了防止shell去分析这些特别字符， 我们可在它之前加一个
      <literal>\</literal>字符去说明它只是普通字符。
      <command>echo $TERM</command>就会显示出您的终端情况，
      而 <command>echo \$TERM</command> 就会显示出 <envar>$TERM</envar>
      这几个字。</para>

    <sect2 id="changing-shells">
      <title>改变您用的Shell</title>

      <para>改变您的Shell的最简单方法是使用
	<command>chsh</command> 命令。 执行 <command>chsh</command> 将根据您设定的<envar>EDITOR</envar>
	环境变量进入到那个编辑器，假如没有设定，就会进入<command>vi</command>编辑器。
	请改变<quote>Shell:</quote>这行对应值。</para>

      <para>您可使用<command>chsh</command> 的<option>-s</option>选项，
	这样就能设置您的shell却又不用编辑器。假如您想把shell改为<command>bash</command>
	可用下面的技巧。</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>运行<command>chsh</command> 不加参数只编辑shell也会达到相同的效果。
	</para>

      <note>
	<para>您使用的shells<emphasis>必须</emphasis>
	  在<filename>/etc/shells</filename> 文件里列出。 假如您从
	  <link linkend="ports">ports</link>里装一个shell， 那就不用做这步了。
	  假如您手工装一个shell，那就要手工添加进去。</para>

      <para>举个例了子，假如您手工把 <command>bash</command>装到
	<filename>/usr/local/bin</filename>里，您还要进行这一步:
	</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>然后运行<command>chsh</command>。</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>文本编辑器</title>
    <indexterm><primary>文本编辑器</primary></indexterm>
    <indexterm><primary>编辑器</primary></indexterm>

    <para>在FreeBSD里有许多的配置是依靠编辑文本文件来完成的，
      正因为这样，最好就是去熟悉一种文本编辑器。
      FreeBSD基本系统本身就自带有几种，还有许多已可在ports里得到。</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <para>最容易学的而又简单的编辑器是
      <application>ee</application>编辑器， 是个标准的简易编辑器。  要启动
      <application>ee</application>，首先就要在命令行输入
      <command>ee <replaceable>filename</replaceable></command>，
      <replaceable>filename</replaceable> 是一个要编辑的文件名。
      例如，要编辑 <filename>/etc/rc.conf</filename>就要输入
      <command>ee /etc/rc.conf</command>，在
      <command>ee</command>的控制内， 编辑器所有功能的操作方法都显示在最上方。
      这个<literal>^</literal> 字符代表
      键盘上的<keycap>Ctrl</keycap> 键， 所以<literal>^e</literal> 就是
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>组合键。
      假如想离开<application>ee</application>，
      按<keycap>Esc</keycap>键，就可选择离开编辑器。
      当您修改了内容的时候，编辑器会提示您保存。</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>编辑器</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>编辑器</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD本身也带许可多有强大功能的文本编辑器， 例如
      <application>vi</application>。还有其他在FreeBSD Ports里几种， 像
      <application>emacs</application> 和 <application>vim</application>。
      这些编辑器有着强大的功能，但同时学习起来比较复杂。
      不管怎样，假如您从事文字编辑方面的工作，
      学习如<application>vim</application> 或 <application>emacs</application>
      这些有强大功能的编辑器用法，
      在长时间工作里会帮您节省不少的时间。</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>设备和设备节点</title>

    <para>在一个系统里，硬件描述通常用法就是一个设备对应一个术语，包括磁盘、打印机、显卡和键盘。
      当FreeBSD导入时，大多数的设备都能探测到并显示出来，
      您也可以查阅<filename>/var/run/dmesg.boot</filename>，
      导入时所有信息都在里面。</para>

    <para>例如， <devicename>acd0</devicename> 就是
      首个 IDE 光盘设备， 而 <devicename>kbd0</devicename>
      则代表键盘。</para>

    <para>在&unix;操作系统里，大多数设备存在的特殊访问文件就是叫做设备节点，
      他们都定位在<filename>/dev</filename>目录里。</para>

    <sect2>
      <title>建立设备节点</title>
      <para>当增加一个新设备或附加设备需要寻求支持时，
      您也许需要在新设备上建立单个或多个的设备节点。</para>

      <sect3>
	<title>MAKEDEV 脚本</title>
	<para>当系统缺少<literal>DEVFS</literal> (涉及的是FreeBSD 5.0之前的版本)，
	建立设备节点可以使用&man.MAKEDEV.8;，就如下面显示的那样:</para>

	<screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV ad1</userinput>
	</screen>

	<para>这个是一个例子，在安装等二个IDE设备时去建立设备节点。</para>
      </sect3>

      <sect3>
	<title><literal>DEVFS</literal> (DEVice 文件系统)</title>

	<para> 这个设备文件系统， 或叫 <literal>DEVFS</literal>，
	  为内核的设备命名在整体文件系统命名里提供通道，
	  并不是建立或更改设备节点，
	  <literal>DEVFS</literal>只是为您的特别文件系统进行维护。</para>

	<para>更多的资料请查 &man.devfs.5; 手册。
	  </para>

	<para><literal>DEVFS</literal>在FreeBSD&nbsp;5.0或更高的版本里是默认使用。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <title>二进制文件格式</title>

    <para>要理解为什么 &os; 使用 &man.elf.5; 格式， 您必须首先了解一些 &unix; 系统中的
      三种 <quote>主要</quote> 可执行文件格式的有关知识：</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>是最古老和<quote>经典的</quote> &unix; 目标文件格式，
	  这种格式在其文件的开始处有一个短小而又紧凑的首部，
	  该首部带有一个魔幻数字，用来标识具体的格式(更多详情参见&man.a.out.5;)。
	  这种格式包含3个要装载入内存的段：.text， .data， 和 .bss，以及
	  一个符号表和一个字符串表。</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>SVR3目标文件格式。其文件头现在包括一个区段表(section table)，
          因此除了.text，.data，和.bss区段以外，您还可以包含其它的区段。</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para><acronym>COFF</acronym> 的后继， 其特点是可以有多个区段，
	  并可以使用32位或64位的值。 它有一个主要的缺点：
	  <acronym>ELF</acronym> 在其设计时假设每个系统体系结构只有一种 ABI。
	  这种假设事实上相当错误， 甚至在商业化的SYSV世界中都是错误的
	  (它们至少有三种ABI: SVR4, Solaris, SCO)。</para>

        <para>FreeBSD试图在某种程度上解决这个问题，它提供一个工具，可以
	  对一个已知的<acronym>ELF</acronym>可执行文件
	  <emphasis>标识</emphasis>它所遵从的ABI的信息。
	  更多这方面的知识可以参见手册页&man.brandelf.1;</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD从<quote>经典</quote>阵营中来，因此使用了&man.a.out.5;格式，
    	众多BSD版本的发行(直到3.X分支的开始)也证明了这种格式的有效性。
    	虽然在那以前的某段时间，在FreeBSD系统上创建和运行<acronym>ELF</acronym>格式
    	的二进制可执行文件(和内核)也是可能的，但FreeBSD一开始并不积极<quote>进步</quote>
    	到使用<acronym>ELF</acronym>作为其缺省的格式。为什么？噢，当Linux阵营完成了
    	转换到<acronym>ELF</acronym>格式的痛苦历程后，却发现并不足以由此而放弃
    	<filename>a.out</filename>可执行文件格式，因为正是由于它们不灵活的，
    	基于跳转表的共享库机制，使得销售商和开发者们构建共享库非常困难。
    	直到已有的<acronym>ELF</acronym>工具提供了一种解决共享库问题的办法，
    	并被普遍认为是<quote>前进方向</quote>以后，迁徙的代价在FreeBSD界才被接受，
    	并由此完成了迁徙。FreeBSD的共享库机制其基础更类似于Sun &sunos;的共享库机制，
    	并且正因为此，其易用性很好。</para>

    <para>那么，为什么会有这么多不同的格式呢？</para>

    <para>回溯到蒙昧和黑暗的过去，那时只有简单的硬件。这种简单的硬件支撑了一个简单
    	和小型的系统。在这样的简单系统上(PDP-11)<filename>a.out</filename>格式
    	足以胜任表达二进制文件的任务。当人们将&unix;从这种简单的系统中移植出来的时候，
    	<filename>a.out</filename>格式被保留了下来，因为对于早期将&unix移植到
    	Motorola 68k，VAXen等系统来说，它还是足够可用的。</para>

    <para>然后，一些聪明的硬件工程师认为，如果可以让软件完成一些简单的聪明操作，
    	那么他们就可以在硬件设计中减少若干门电路，并可以让CPU核心运行得更快。
    	当<filename>a.out</filename>格式用于这种新型的硬件系统时(现在我们叫它
    	<acronym>RISC</acronym>)，显得并不合适。因此，人们设计了许多新的格式
    	以便在这样的硬件系统上能获得比简单的<filename>a.out</filename>格式更优越
    	的性能。诸如<acronym>COFF</acronym>，<acronym>ECOFF</acronym>，还有其它
    	一些晦涩难懂的格式正是在这个阶段被发明出来的，人们也研究了这些格式的局限性，
    	慢慢地最终落实到<acronym>ELF</acronym>格式。</para>

    <para>同时，程序的大小变得越来越大，磁盘空间(以及物理内存)相对来说却仍然较小，
	因此共享库的概念便产生了。VM系统也变得越来越复杂了。当所有这些进步都建立在
	<filename>a.out</filename>格式的基础上的时候，它的可用性随着每个新特性
	的产生就受到了严重考验。并且，人们还希望可以在运行时动态装载某些东西，或者
	在初始化代码运行以后可以丢弃部分程序代码，以便节约主存储器和交换区。编程语言
	也变得越来越复杂，人们希望可以在main()函数执行之前自动执行某些代码。为了实现
	所有这些功能，人们对<filename>a.out</filename>格式作了很多改动(hack)，
	他们在某个阶段里基本也是可行的。随着时间的推移，<filename>a.out</filename>格式
	不得不增加大量的代码和复杂度来满足这些需求。虽然<acronym>ELF</acronym>格式
	解决了许多这样的问题，但是从一个可用的系统迁移到另一个系统却是痛苦的。因此
	直到继续保留<filename>a.out</filename>格式的代价比迁移到<acronym>ELF</acronym>格式
	的代价还大的时候，人们才会最终转换到<acronym>ELF</acronym>格式。</para>

    <para>然而，随着时间的推移，FreeBSD系统本身的编译工具(特别是汇编器和装载器)
    	赖以派生的编译工具，其发展却形成了两个平行的分支。FreeBSD这个分支增加了共享库，
    	并修改了一些错误。而原先编写了这些工具的GNU人则重写了这些工具，并对交叉编译提供了
    	更简化的支持，还随意插入了不同格式的支持，等等。虽然很多人希望创建针对FreeBSD的
    	交叉编译器，但他们却并未如愿以偿，因为FreeBSD的<application>as</application>
    	和<application>ld</application>的源代码更为老旧，所以无法完成这个任务。
    	新的GNU工具链(<application>binutils</application>)则确实支持交叉编译，<acronym>ELF</acronym>
    	格式，共享库，C++扩展，等等。并且，由于很多供应商都发布<acronym>ELF</acronym>格式的
    	二进制文件，因而让FreeBSD能够运行它们将是一个很好的事情。</para>

    <para><acronym>ELF</acronym>格式比<filename>a.out</filename>格式开销要大些，同时也
    	允许基础系统有更好的扩展性。<acronym>ELF</acronym>格式的有关工具有着更好的维护，
    	并且提供交叉编译支持，这对许多人来说是很重要的。<acronym>ELF</acronym>格式可能会稍微
    	慢一些，但很难测量出来。另外，在这两者之间，有许多细节也是不同的，比如它们映射页面的方式，
    	处理初始化代码的方式，等等。所有这些都不太重要，但这也确实是不同之处。在将来的适当时候，
    	<filename>GENERIC</filename>内核将不再支持<filename>a.out</filename>格式，并且，
    	当不再需要运行遗留的<filename>a.out</filename>格式程序时，内核也将不再提供对其的支持。</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>取得更多的资讯</title>

    <sect2 id="basics-man">
      <title>联机手册</title>
      <indexterm><primary>联机手册</primary></indexterm>

      <para>最详细的使用说明文档莫过于 FreeBSD 里的联机手册了。
	几乎每一个程序都会附上一份简短说明，
	以介绍这个程序的的基本功能以及参数的用法。
	我们能通过 <command>man</command> 命令来阅读这些说明， 而使用
	<command>man</command> 命令却是简单的事情:</para>

      <screen>&prompt.user; <userinput>man <replaceable>command</replaceable></userinput></screen>

      <para><literal>command</literal> 就是您要了解的命令命称。
        举个例子，想了解 <command>ls</command> 命令就输入:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>这些在线手册分下列章节:</para>

      <orderedlist>
	<listitem>
	  <para>用户命令。</para>
	</listitem>

	<listitem>
	  <para>系统调用以及错误代码。</para>
	</listitem>

	<listitem>
	  <para>C 库文件里的函数说明。</para>
	</listitem>

	<listitem>
	  <para>设备驱动程序。</para>
	</listitem>

	<listitem>
	  <para>文件格式。</para>
	</listitem>

	<listitem>
	  <para>游戏以及其他娱乐。</para>
	</listitem>

	<listitem>
	  <para>各种资讯。</para>
	</listitem>

	<listitem>
	  <para>系统维护以及命令。</para>
	</listitem>

	<listitem>
	  <para>内核开发情况。</para>
	</listitem>
      </orderedlist>

      <para>在某些情况下，同样的主题也会出现在在线手册的不同章节。
	举个例子，系统里有<command>chmod</command>这个用户命令，而又有个
	<function>chmod()</function> 系统调用。 在这种情形下，您应当向
	<command>man</command> 命令指定需要的内容:
	</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>这样就会显示出手册里的用户 <command>chmod</command> 命令。
	传统上，我们在写入文档时把特定详细参考内容在在线手册括号里注明。
	所以 &man.chmod.1; 是指 <command>chmod</command> 用户命令，
	而 &man.chmod.2; 是指系统调用。
	</para>

      <para>如果您已经知道命令的名字，只是不知道要怎样使用的话，那就比较好办。
	但您连名字都不知到呢?这个时候您就可以利用 <command>man</command> 的搜寻功能，
	它会在手册的介绍部份找寻您要搜寻的关键字，它的选项是 <option>-k</option>：</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>当您使用这个命令的时候，man会把介绍里含有<quote>mail</quote>关键字
      的命令列出来，实际上这和<command>apropos</command>命令的功能是相同的。</para>

      <para>有时您会看到<filename>/usr/bin</filename> 下有许多命令但不知他们的用途，
	您只需这样做:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>或者这样做</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>两个命令是一样的。</para>
    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info 文件</title>
      <indexterm><primary>Free软件基金会</primary></indexterm>

      <para>FreeBSD许多应用软件以及实用工具来自Free软件基金会(FSF)。
	  作为手册的扩充，这些程序提供了一种更具有活力的超文档说明<literal>info</literal>，
	  您可用<command>info</command>命令来阅读他们。
	  假如您装上<application>emacs</application>，也能利用<application>emacs</application>
	  的info模式来阅读。
	</para>

      <para>使用 &man.info.1; 这个命令只需简单地输入:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>想得到简单介绍， 请按 <literal>h</literal>。  想快速得到的命令说明，
	请按 <literal>?</literal>。</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
