<!--
     The FreeBSD Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/security/chapter.sgml,v 1.28 2004/10/21 13:44:42 den Exp $

     Original revision: 1.229
-->

<chapter id="security">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Matthew</firstname>
	<surname>Dillon</surname>
	<contrib>Большая часть этой главы была взята из страницы справочника
	security(7) которую написал </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Денис</firstname>
	<surname>Пеплин</surname>
	<contrib>Перевод на русский язык: </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Безопасность</title>
  <indexterm><primary>безопасность</primary></indexterm>

  <sect1 id="security-synopsis">
    <title>Краткое описание</title>

    <para>Эта глава представляет введение в основные концепции безопасности
      системы, некоторые эмпирические правила и более подробно обращается к
      отдельным темам, касающимся &os;.  Большая часть затрагиваемых тем может
      быть применена к безопасности системы и безопасности в интернет вообще.
      Интернет больше не то <quote>дружественное</quote> место, где каждый
      хочет быть вам добрым соседом.  Защита системы необходима для сохранения
      ваших данных, интеллектуальной собственности, времени и всего остального
      от хакеров и им подобных.</para>

    <para>FreeBSD предоставляет массу утилит и механизмов для обеспечения
      целостности и безопасности системы и сети.</para>

    <para>После прочтения этой главы вы узнаете:</para>

    <itemizedlist>
      <listitem>
	<para>Основные концепции безопасности системы, специфику &os;.</para>
      </listitem>

      <listitem>
	<para>О различных механизмах шифрования в &os;, таких как
	  <acronym>DES</acronym> и <acronym>MD5</acronym>.</para>
      </listitem>

      <listitem>
	<para>Как настроить аутентификацию с использованием одноразовых
	  паролей.</para>
      </listitem>

      <listitem>
	<para>Как настроить <acronym>TCP</acronym> Wrappers для
	  использования с <command>inetd</command>.</para>
      </listitem>

      <listitem>
	<para>Как настроить <application>KerberosIV</application> в релизах
	  &os; до 5.0.</para>
      </listitem>

      <listitem>
	<para>Как настроить <application>Kerberos5</application> в релизах &os;
	  после 5.0.</para>
      </listitem>

      <listitem>
	<para>Как создать межсетевые экраны с помощью
	  <acronym>IPFW</acronym>.</para>
      </listitem>

      <listitem>
	<para>Как настроить IPsec и создать <acronym>VPN</acronym> между
	  компьютерами на &os;/&windows;.</para>
      </listitem>

      <listitem>
	<para>Как настроить и использовать <application>OpenSSH</application>,
	  реализацию <acronym>SSH</acronym> в &os;.</para>
      </listitem>

      <listitem>
	<para>Что такое <acronym>ACL</acronym> и как их использовать.</para>
      </listitem>

      <listitem>
	<para>Как работать с сообщениями безопасности &os;.</para>
      </listitem>

    </itemizedlist>

    <para>Перед чтением этой главы вам потребуется:</para>

    <itemizedlist>
      <listitem>
	<para>Понимание основных концепций &os; и интернет.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="security-intro">
    <title>Введение</title>

    <para>Безопасность это первая и основная функция системного
      администратора.  Хотя все многопользовательские системы BSD &unix;
      уже снабжены некоторой защитой, работа по созданию и поддержке
      дополнительных механизмов безопасности, обеспечивающих защищенную работу
      пользователей, это одна из самых серьезных задач системного
      администратора.  Компьютеры безопасны настолько, насколько вы сделаете
      их безопасными и требования безопасности всегда находятся в противоречии
      с удобством работы пользователей.  Системы &unix; способны одновременно
      работать с огромным количеством процессов и многие из этих процессов
      серверные &mdash; это означает, что с ними могут взаимодействовать
      внешние программы.  Сегодня десктопы заменили мини-компьютеры и
      мэйнфрэймы, и поскольку компьютеры в наши дни подключены к сети
      интернет, безопасность важна как никогда.</para>

    <para>Наилучшая реализация системы безопасности представима в виде
      <quote>послойной</quote> системы.  Вообще говоря все, что нужно сделать,
      это создать столько слоев безопасности, сколько необходимо и затем
      внимательно следить за вторжениями в систему.  Не переусердствуйте в
      настройке системы безопасности, иначе она сделает невозможной
      обнаружение вторжений, являющееся одним из наиболее важных аспектов
      механизма безопасности.  Например, нет большого смысла в установке
      флага <literal>schg</literal> (&man.chflags.1;) на каждый исполняемый
      файл системы, поскольку хотя таким способом можно временно защитить
      исполняемые файлы, это помешает обнаружению факта взлома
      системы.</para>

    <para>Безопасность системы также относится к различным формам атак,
      имеющих своей целью вызвать крах системы, или сделать систему
      недоступной другим способом, но не пытающихся получить доступ к учетной
      записи <username>root</username> (<quote>break root</quote>).
      Угрозы безопасности могут быть поделены на несколько категорий:</para>

    <orderedlist>
      <listitem>
	<para>Отказ в обслуживании (Denial of service, DoS).</para>
      </listitem>

      <listitem>
	<para>Взлом пользовательских учетных записей.</para>
      </listitem>

      <listitem>
	<para>Взлом учетной записи root через доступные сервисы.</para>
      </listitem>

      <listitem>
	<para>Взлом учетной записи root через учетные записи
	  пользователей.</para>
      </listitem>

      <listitem>
	<para>Создание backdoor.</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>DoS атаки</primary>
      <see>отказ в обслуживании (Denial of Service, DoS)</see>
    </indexterm>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>DoS атаки</secondary>
      <see>отказ в обслуживании (Denial of Service, DoS)</see>
    </indexterm>
    <indexterm><primary>Отказ в обслуживании (Denial of Service, DoS)</primary></indexterm>

    <para>Атака <quote>отказ в обслуживании</quote> отбирает у машины
      необходимые ресурсы.  Обычно DoS атаки используют грубую силу, чтобы
      попытаться обрушить систему или сделать ее недоступной другим способом,
      превысив лимиты ее сервисов или сетевого стека.  Некоторые DoS атаки
      пытаются использовать ошибки в сетевом стеке для обрушения системы одним
      пакетом.  Эту проблему можно решить только исправив ядро системы.  Атаки
      зачастую можно предотвратить правильной установкой параметров,
      ограничивающих нагрузку на систему в неблагоприятных условиях. С
      атаками, использующими грубую силу, бороться сложно.  Например, атака с
      использованием пакетов с поддельными адресами, которую почти невозможно
      остановить, может быстро отключить вашу систему от интернет.  Возможно,
      она не приведет к отказу системы, но сможет переполнить соединение с
      интернет.</para>

    <indexterm>
      <primary>безопасность</primary>
      <secondary>взлом учетных записей</secondary>
    </indexterm>

    <para>Взлом учетной записи пользователя обычно встречается чаще, чем DoS
      атаки.  Многие системные администраторы все еще используют стандартные
      сервисы <application>telnetd</application>,
      <application>rlogind</application> и <application>ftpd</application> на
      своих серверах.  Эти сервисы по умолчанию не работают с зашифрованными
      соединениям.  В результате при среднем количестве пользователей пароль
      одного или нескольких пользователей, входящих в систему через внешнее
      соединение (это обычный и наиболее удобный способ входа в систему),
      будет перехвачен.  Внимательный системный администратор должен
      анализировать логи удаленного доступа на предмет подозрительных адресов
      пользователей даже в случае успешного входа.</para>

    <para>Кто-то может предположить, что атакующий при наличии доступа к
      учетной записи пользователя может взломать учетную запись
      <username>root</username>.  Однако, реальность такова, что в хорошо
      защищенной и поддерживаемой системе доступ к учетной записи пользователя
      не обязательно даст атакующему доступ к <username>root</username>.
      Разница между доступом к обычной учетной записи и к
      <username>root</username> важна, поскольку без доступа к
      <username>root</username> атакующий обычно не способен скрыть свои
      действия, и в худшем случае сможет лишь испортить файлы пользователя или
      вызвать крах системы.  Взлом пользовательских учетных записей
      встречается очень часто, поскольку пользователи заботятся о безопасности
      так, как системные администраторы.</para>

    <indexterm>
      <primary>безопасность</primary>
      <secondary>backdoors</secondary>
    </indexterm>

    <para>Системные администраторы должны помнить, что существует множество
      потенциальных способов взлома учетной записи <username>root</username>.
      Атакующий может узнать пароль <username>root</username>, найти ошибку в
      сервисе, работающем с привилегиями и взломать учетную запись
      <username>root</username> через сетевое соединение с этим сервисом, или
      узнать об ошибке в suid-root программе, позволяющей атакующему взлом
      <username>root</username> с помощью взломанной учетной записи
      пользователя.  Если атакующий нашел способ взлома
      <username>root</username>, ему может не понадобиться установка backdoor.
      Многие из обнаруженных и закрытых на сегодняшний день брешей
      в системе, позволяющие взлом <username>root</username>, требуют от
      атакующего серьезной работы по заметанию следов, поэтому большинство
      атакующих устанавливают backdoor.  Backdoor предоставляет атакующему
      простой способ восстановления доступа к системе с привилегиями
      <username>root</username>, но также дает системному администратору
      удобный способ обнаружения вторжения.  Устранение возможности установки
      backdoor возможно повредит безопасности системы, поскольку это
      не устранит брешь, позволившую проникнуть в
      систему.</para>

    <para>Меры безопасности всегда должны быть реализованы многоуровнево,
      и могут быть классифицированы следующим образом:</para>

    <orderedlist>
      <listitem>
	<para>Защита <username>root</username> и служебных учетных
	  записей.</para>
      </listitem>

      <listitem>
	<para>Защита работающих под <username>root</username>
	  сервисов и suid/sgid исполняемых файлов.</para>
      </listitem>

      <listitem>
	<para>Защита учетных записей пользователей.</para>
      </listitem>

      <listitem>
	<para>Защита файла паролей.</para>
      </listitem>

      <listitem>
	<para>Защита ядра, raw устройств и файловых
	  систем.</para>
      </listitem>

      <listitem>
	<para>Быстрое обнаружение несанкционированных изменений в
	  системе.</para>
      </listitem>

      <listitem>
	<para>Паранойя.</para>
      </listitem>
    </orderedlist>

    <para>В следующем разделе этой главы эти темы изложены более
      подробно.</para>
  </sect1>

  <sect1 id="securing-freebsd">
    <title>Защита FreeBSD</title>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>защита FreeBSD</secondary>
    </indexterm>

    <note>
      <title>Команда и протокол</title>
      <para>В этом документе мы будет использовать
	<application>выделенный</application> текст, упоминая приложение,
	и <command>моноширинный</command> шрифт, упоминая определенные
	команды.  Для протоколов используется обычный шрифт.  Это
	типографическое отличие полезно для таких случаев, как ssh, поскольку
	это и команда и протокол.</para>
    </note>

    <para>В последующем разделе будут рассмотрены методы защиты системы
      FreeBSD, упомянутые в <link
	linkend="security-intro">предыдущем разделе</link> этой главы.</para>

    <sect2 id="securing-root-and-staff">
      <title>Защита учетной записи <username>root</username> и служебных
	учетных записей</title>
      <indexterm>
	<primary><command>su</command></primary>
      </indexterm>

      <para>Во-первых, не беспокойтесь о защите служебных учетных записей,
	если не защищена учетная запись <username>root</username>.  В
	большинстве систем у учетной записи <username>root</username> есть
	пароль.  Использование пароля <username>root</username>
	опасно <emphasis>всегда</emphasis>.  Это не означает, что вы должны
	удалить пароль.  Пароль почти всегда необходим для доступа
	по консоли.  Но это означает, что вы должны сделать невозможным
	использование пароля не из консоли или может быть даже с помощью
	команды &man.su.1;.  Например, убедитесь, что псевдотерминалы
	в файле <filename>/etc/ttys</filename> перечислены с параметром
	<literal>insecure</literal>, что делает невозможным вход на них
	под <username>root</username> напрямую с помощью
	<command>telnet</command> или <command>rlogin</command>.  При
	использовании других средств входа, таких как
	<application>sshd</application>, убедитесь что вход под
	<username>root</username> напрямую отключен и в них.  Сделайте
	это, открыв файл <filename>/etc/ssh/sshd_config</filename>, и
	убедившись, что параметр <literal>PermitRootLogin</literal>
	установлен в <literal>NO</literal>.  Проверьте каждый метод доступа
	&mdash; сервис FTP и ему подобные часто подвержены взлому.  Прямой
	вход под <username>root</username> должен быть разрешен только с
	системной консоли.</para>
      <indexterm>
	<primary><groupname>wheel</groupname></primary>
      </indexterm>

      <para>Конечно, как системный администратор вы должны иметь доступ
	<username>root</username>, поэтому потребуется открыть несколько
	<quote>лазеек</quote>.  Но убедитесь, что для доступа к ним необходим
	дополнительный пароль.  Одним из способов доступа к
	<username>root</username> является добавление соответствующих учетных
	записей к группе <groupname>wheel</groupname> (в файле
	<filename>/etc/group</filename>).  Это позволяет использовать
	<command>su</command> для доступа к <username>root</username>.
	Вы никогда не должны давать таким учетным записям доступ
	к <groupname>wheel</groupname> непосредственно, помещая их в группу
	<groupname>wheel</groupname> в файле паролей.  Служебные учетные
	записи должны помещаться в группу <groupname>staff</groupname>,
	а затем добавляться к группе <groupname>wheel</groupname> в файле
	<filename>/etc/group</filename>.  Только те члены группы staff,
	которым действительно нужен доступ к <username>root</username>,
	должны быть помещены в группу <groupname>wheel</groupname>.
	При работе с такими методами аутентификации как Kerberos, возможно также
	использование файла <filename>.k5login</filename> в каталоге
	пользователя <username>root</username> для доступа к учетной записи
	<username>root</username> с помощью &man.ksu.1; без помещения
	кого-либо в группу <groupname>wheel</groupname>.  Это решение возможно
	лучше, поскольку механизм <groupname>wheel</groupname> все еще
	позволяет взлом <username>root</username>, если злоумышленник
	получил копию файла паролей и смог взломать служебную учетную запись.
	Хотя использование механизма <groupname>wheel</groupname> лучше,
	чем работа через <username>root</username> напрямую, это не
	обязательно самый безопасный способ.</para>

      <!-- XXX:
	This will need updating depending on the outcome of PR bin/71147.
	Personally I know what I'd like to see, which puts this in definite
	need of a rewrite, but we'll have to wait and see.  ceri@
      -->

      <para>Непрямой способ защиты служебных учетных записей и конечно
	<username>root</username> это использование альтернативных методов
	доступа и замена зашифрованных паролей на символ
	<quote><literal>*</literal></quote>.  Используя команду
	&man.vipw.8;, замените каждый зашифрованный пароль служебных учетных
	записей на этот символ для запрета входа с аутентификацией по паролю.
	Эта команда обновит файл <filename>/etc/master.passwd</filename> и
	базу данных пользователей/паролей.</para>

      <para>Служебная учетная запись вроде этой:</para>

      <programlisting>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Должна быть заменена на такую:</para>

      <programlisting>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Это изменение предотвратит обычный вход, поскольку зашифрованный
	пароль никогда не совпадет с <quote><literal>*</literal></quote>.
	После этого члены группы staff должны использовать другой механизм
	аутентификации, например &man.kerberos.1; или &man.ssh.1; с парой
	ключей: публичным и приватным.  При использовании такой	системы как
	Kerberos, потребуется защитить сервер Kerberos и рабочую станцию.
	При использовании пары публичного/приватного ключей с ssh,
	потребуется защитить компьютер, <emphasis>с</emphasis> которого
	происходит вход (обычно это рабочая станция).  Дополнительных слой
	защиты может быть добавлен путем защиты пары ключей при создании их
	с помощью &man.ssh-keygen.1;.  Возможность заменить пароли служебных
	учетных записей на <quote><literal>*</literal></quote> гарантирует
	также, что вход может быть осуществлен только через защищенные методы
	доступа, которые вы настроили.  Это принуждает всех членов staff
	использовать защищенные, шифрованные соединения для всех входов,
	что закрывает большую брешь, используемую многими нарушителями:
	перехват паролей с другого, слабо защищенного компьютера.</para>

      <para>Более непрямой механизм безопасности предполагает, что вы входите
	с более защищенного сервера на менее защищенный.  Например, если
	главный сервер работает со всеми сервисами, рабочая станция не должна
	работать ни с одним.  Для поднятия уровня безопасности до приемлемого
	уровня, число запущенных на ней сервисов необходимо сократить до
	минимума, вплоть до отключения их всех, кроме того необходимо
	использовать защищенный паролем хранитель экрана.  Конечно, при
	наличии физического доступа к рабочей станции атакующий может взломать
	любую систему безопасности.  Это определенно проблема, которую вы
	должны учитывать, но учтите также тот факт, что большинство взломов
	совершаются удаленно, через сеть, людьми, которые не имеют физического
	доступа к вашим рабочим станциям или серверам.</para>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>Использование такой системы как Kerberos дает возможность
	заблокировать или изменить пароль в одном месте, что сразу
	отразиться на всех компьютерах, где существует служебная учетная
	запись.  Если эта учетная запись будет взломана, возможность
	немедленно изменить пароль на всех компьютерах нельзя недооценивать.
	Без этой возможности изменение паролей на N машинах может стать
	проблемой.  Вы можете также наложить ограничения на смену паролей
	с помощью Kerberos: не только установить значения timeout в
	Kerberos, но и добавить требование смены пароля пользователем
	после определенного периода времени (скажем, раз в месяц).</para>
    </sect2>

    <sect2>
      <title>Защита работающих под root сервисов и suid/sgid исполняемых
	файлов</title>

      <indexterm>
	<primary><command>ntalk</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>comsat</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>finger</command></primary>
      </indexterm>
      <indexterm>
	<primary>sandboxes</primary>
      </indexterm>
      <indexterm>
	<primary><application>sshd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>telnetd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>rshd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>rlogind</application></primary>
      </indexterm>

      <para>Предусмотрительный системный администратор запускает только те
	сервисы, в которых нуждается, ни больше ни меньше.  Учитывайте, что
	сервисы сторонних разработчиков наиболее подвержены ошибкам.  К примеру,
	работа со старыми версиями <application>imapd</application> или
	<application>popper</application> это все равно что раздача доступа
	<username>root</username> всему миру.  Никогда не запускайте
	сервисы, которые вы не проверили достаточно внимательно.  Многим
	сервисам не требуется работа под <username>root</username>.
	Например, даемоны <application>ntalk</application>,
	<application>comsat</application>, и
	<application>finger</application> могут быть запущены в так
	называемых <firstterm>песочницах</firstterm>
	(<firstterm>sandboxes</firstterm>).  Песочница это не идеальное
	решение, поскольку вызывает много проблем, но она подходит под
	модель послойной безопасности: если кто-то сможет взломать сервис,
	работающий в песочнице, ему потребуется взломать еще и саму
	песочницу.  Чем больше уровней (<quote>слоев</quote>) потребуется
	пройти атакующему, тем меньше вероятность его успеха.  Ошибки,
	позволяющие получать root доступ, находили фактически во всех
	сервисах, запускаемых под <username>root</username>, включая
	основные системные сервисы.  Если вы обслуживаете машину, на которую
	входят только через <application>sshd</application> и никогда не
	входят через <application>telnetd</application>,
	<application>rshd</application> или
	<application>rlogind</application>, отключите эти сервисы!</para>

      <para>В FreeBSD сервисы
	<application>ntalkd</application>,
	<application>comsat</application> и
	<application>finger</application> теперь по умолчанию работают в
	<quote>песочнице</quote>.  Другая программа, которая может быть
	кандидатом на запуск в <quote>песочнице</quote> это
	&man.named.8;.  <filename>/etc/defaults/rc.conf</filename> включает
	необходимые для запуска <application>named</application>
	в <quote>песочнице</quote> аргументы в закомментированой форме.
	В зависимости от того, устанавливаете ли вы новую систему, или
	обновляете старую, учетные записи пользователей, используемые
	этими <quote>песочницами</quote> могут не быть созданы.
	Предусмотрительный системный администратор должен узнать о
	<quote>песочницах</quote> для сервисов и установить их если есть
	возможность.</para>
      <indexterm>
	<primary><application>sendmail</application></primary>
      </indexterm>

      <para>Есть множество других сервисов, которые обычно не работают в
	<quote>песочницах</quote>: <application>sendmail</application>,
	<application>popper</application>,
	<application>imapd</application>, <application>ftpd</application>,
	и другие.  Некоторым из этих сервисов есть альтернативы,
	но их установка может потребовать больше работы, чем вы готовы
	выполнить (фактор удобства).  Вы можете запустить эти сервисы под
	<username>root</username> и положиться на другие механизмы обнаружения
	вторжений, которые могут пройти через них.</para>

      <para>Другая большая потенциальная <username>root</username> брешь
	в системе это suid-root и sgid исполняемые файлы.  Большинство
	этих исполняемых файлов, таких как <application>rlogin</application>,
	установлены в <filename>/bin</filename>, <filename>/sbin</filename>,
	<filename>/usr/bin</filename>, или <filename>/usr/sbin</filename>.
	Хотя ничто не может быть безопасно на 100%, находящиеся по умолчанию
	в системе suid и sgid исполняемые файлы могут быть признаны
	достаточно безопасными.  Но <username>root</username> бреши все еще
	обнаруживаются в этих исполняемых файлах.  <username>root</username>
	брешь, обнаруженная в <literal>Xlib</literal> в 1998 делала
	<application>xterm</application> (который обычно suid) подверженным
	взлому.  Лучше сразу принять меры предосторожности, чем сожалеть
	потом. Предусмотрительный системный администратор ограничит права
	запуска suid исполняемых файлов, которые должны запускаться
	пользователями группы staff, только этой группой, а также запретит
	доступ (<command>chmod 000</command>) к тем исполняемым файлам
	suid, которые никем не используются.  Серверу без монитора обычно
	не требуется исполняемый файл <application>xterm</application>.
	Исполняемые sgid исполняемые файлы могут быть почти так же опасны.
	Если нарушитель сможет взломать sgid-kmem исполняемый файл, он
	возможно сможет прочесть <filename>/dev/kmem</filename> и
	таким образом получить файл зашифрованных паролей, что потенциально
	делает возможным взлом любой защищенной паролем учетной записи.
	Аналогично нарушитель, проникший в группу <literal>kmem</literal>,
	может отслеживать последовательности клавиш, отправленные через
	псевдотерминалы, включая псевдотерминалы, используемые через
	безопасные соединения.  Нарушитель, вошедший в группу
	<groupname>tty</groupname> может сделать вывод почти на любой
	пользовательский терминал.  Если пользователь работает с
	терминальной программой или эмулятором с возможностью эмуляции
	клавиатуры, взломщик может потенциально сгенерировать поток данных,
	который заставит терминал пользователя ввести команду, и она будет
	запущена с правами этого пользователя.</para>
    </sect2>

    <sect2 id="secure-users">
      <title>Защита учетных записей пользователей</title>

      <para>Учетные записи пользователей обычно сложнее всего защитить.
	Вы можете ввести драконовские ограничения доступа к служебным учетным
	записям, заменив их пароли на символ
	<quote><literal>*</literal></quote>, но возможно не сможете сделать
	то же с обычными учетными записями пользователей.  Если есть
	такая возможность, вы возможно сможете защитить учетные записи
	пользователей соответствующим образом.  Если нет, просто
	более бдительно отслеживайте эти учетные записи.  Использование
	ssh и Kerberos для учетных записей пользователей более
	проблематично, поскольку требует дополнительной административной
	работы и технической поддержки, но все же это решение лучше,
	чем файл с шифрованными паролями.</para>
    </sect2>

    <sect2>
      <title>Защита файла паролей</title>

      <para>Единственный абсолютно надежный способ это замена на
	<literal>*</literal> максимально возможного количества паролей и
	использование ssh или Kerberos для доступа к таким учетным записям.
	Хотя файл с шифрованными паролями (<filename>/etc/spwd.db</filename>)
	доступен для чтения только <username>root</username>, возможно, что
	нарушитель сможет получить доступ на чтение к этому файлу, даже если
	не получит права <username>root</username> на запись.</para>

      <para>Ваши скрипты безопасности должны всегда проверять и составлять
	отчет об изменениях файла паролей (обратитесь к разделу <link
	linkend="security-integrity">Проверка целостности файлов</link>
	ниже по тексту).</para>
    </sect2>

    <sect2>
      <title>Защита ядра, raw устройств и файловых
	систем</title>

      <para>Если атакующий взломает <username>root</username>, он сможет
	сделать практически все, но есть способы усложнить его задачу.
	Например, в большинстве современных ядер встроено устройство
	перехвата пакетов.  В FreeBSD оно называется
	<devicename>bpf</devicename>.  Нарушитель обычно пытается запустить
	перехват пакетов на взломанной машине.  Вы не должны предоставлять
	ему такой возможности, на большинстве систем устройство
	<devicename>bpf</devicename> не должно быть встроено в ядро.</para>

      <indexterm>
	<primary><command>sysctl</command></primary>
      </indexterm>
      <para>Но даже если вы выключите устройство <devicename>bpf</devicename>,
	все еще остаются проблемы, связанные с устройствами
	<filename>/dev/mem</filename> и
	<filename>/dev/kmem</filename>.
	Нарушитель все еще может писать на дисковые raw устройства.
	Есть также другая возможность ядра, загрузка модулей, &man.kldload.8;.
	Активный нарушитель может использовать KLD модуль для установки
	собственного устройства <devicename>bpf</devicename> или другого
	перехватывающего устройства на работающее ядро.  Для решения этих
	проблем запускайте ядро с большим уровнем безопасности, как минимум 1.
	Уровень безопасности может быть установлен с помощью
	<command>sysctl</command> через переменную
	<varname>kern.securelevel</varname>.  После установки уровня
	безопасности в 1 доступ на запись в raw устройства будет запрещена и
	полностью заработают специальные флаги <command>chflags</command>,
	такие как <literal>schg</literal>.  Убедитесь также, что
	флаг <literal>schg</literal> установлен на критически важных
	загрузочных исполняемых файлах, каталогах и файлах скриптов &mdash;
	на всем, что запускается до установке уровня безопасности.
	Это требует большого объема работы, и обновление системы на более
	высоком уровне безопасности может стать гораздо сложнее.  Вы можете
	пойти на компромисс и запускать систему на высоком уровне безопасности,
	но не устанавливать флаг <literal>schg</literal> для каждого
	существующего системного файла и каталога.  Другая возможность
	состоит в монтировании <filename>/</filename> и
	<filename>/usr</filename> только для чтения.  Необходимо заметить,
	что такие правила слишком жесткие и могут помешать обнаружению
	вторжения.</para>
    </sect2>

    <sect2 id="security-integrity">
      <title>Проверка целостности файлов: исполняемые, конфигурационные файлы
	и т.д.</title>

      <para>Вы можете защищать только ядро, файлы настройки и управления
	системой только до тех пор, пока эта защита не вступит в конфликт
	с удобством работы в системе.  Например, использование
	<command>chflags</command> для установки бита
	<literal>schg</literal> на большинство файлов в <filename>/</filename>
	вероятно может только навредить, поскольку хотя и может защитить
	файлы, препятствует обнаружению.  Последний слой системы безопасности,
	возможно, наиболее важный &mdash; обнаружение.  Остальные меры
	безопасности практически бесполезны (или, что еще хуже, могут дать
	вам ложное ощущение безопасности) если вы не обнаружите потенциальное
	вторжение.  Половина функций системы безопасности направлена на
	замедление атакующего, а не на его остановку, для того, чтобы дать
	системе обнаружения возможность поймать нарушителя на месте
	преступления.</para>

      <para>Лучший способ обнаружения вторжения &mdash; отслеживание
	измененных, отсутствующих, или неожиданно появившихся файлов.
	Для наблюдения за измененными файлами лучше всего использовать
	другую (зачастую централизованную) систему с ограниченным
	доступом.  Добавление написанных вами скриптов к этой дополнительно
	защищенной системе с ограниченным доступом делает ее практически
	невидимой для потенциальных взломщиков, и это важно.  В целях
	достижения максимального эффекта вам может потребоваться предоставить
	этой системе доступ к другим машинам в сети, обычно с помощью
	NFS экспорта только для чтения или сгенерировав пары ключей ssh
	для доступа к другим машинам по ssh.  Помимо большого объема
	сетевого трафика, NFS более скрытый метод &mdash; он позволяет
	контролировать файловые системы на каждом клиентском компьютере
	практически незаметно.  Если ваш сервер с ограниченным доступом
	подключен к клиентским компьютерам через коммутатор, NFS метод
	это зачастую лучший выбор.  При соединении через концентратор, или
	через несколько маршрутизаторов, NFS метод может стать слишком
	небезопасным и использование ssh может стать лучшим выбором даже
	несмотря на то, что ssh оставляет следы своей работы.</para>

      <para>Как только у вас появился сервер с ограниченным доступом,
	и как минимум доступ на чтение в клиентских системах, потребуется
	написать скрипты для выполнения мониторинга.  При наличии доступа
	по NFS вы можете написать скрипты с помощью простых системных утилит,
	таких как &man.find.1; и &man.md5.1;.  Лучше всего подсчитывать
	md5 файлов на клиентском компьютере как минимум один раз в день,
	а файлы, контролирующие запуск из <filename>/etc</filename> и
	<filename>/usr/local/etc</filename> даже более часто.  При
	обнаружении расхождений в md5, контролирующий компьютер должен
	просигналить системному администратору проверить изменившиеся
	файлы.  Хороший скрипт безопасности проверит также наличие
	несоответствующих исполняемых suid файлов и новых или измененных
	файлов в системных разделах <filename>/</filename> и
	<filename>/usr</filename>.</para>

      <para>При использовании ssh вместо NFS, написать скрипты безопасности
	гораздо сложнее.  Вам обязательно потребуется скопировать
	(<command>scp</command>) скрипты на клиентский компьютер,
	сделать из невидимыми, и для безопасности потребуется также
	скопировать исполняемые файлы (такие как find), которые будут
	использоваться скриптом.  Приложение <application>ssh</application>
	на клиентском компьютере может быть уже взломано.  В конечном итоге,
	без ssh не обойтись при работе через небезопасные соединения,
	но его гораздо сложнее использовать.</para>

      <para>Хороший скрипт безопасности проверит также изменения в файлах
	настройки, работающих при подключении пользователей и служебных учетных
	записей:
	<filename>.rhosts</filename>, <filename>.shosts</filename>,
	<filename>.ssh/authorized_keys</filename> и так далее&hellip;
	файлы, которые могли не попасть в область проверки
	<literal>MD5</literal>.</para>

      <para>Если для пользователей выделен большой объем дискового
	пространства, проверка каждого файла на таких разделах может занять
	слишком много времени.  В таком случае установка флагов монтирования
	для запрета suid исполняемых файлов и устройств на таких разделах
	это хорошая идея.  Примените параметры &man.mount.8;
	<literal>nodev</literal> и <literal>nosuid</literal>.  Проверяйте
	эти разделы в любом случае, хотя бы раз в неделю, поскольку
	необходимо обнаруживать попытки взлома, независимо от того,
	эффективны они или нет.</para>

      <para>Учет процессов (&man.accton.8;) это относительно несложная
	возможность операционной системы, которая может помочь
	как механизм обнаружения состоявшихся вторжений.  Она особенно
	полезна для обнаружения пути проникновения нарушителя в систему,
	если файл не был затронут проникновением.</para>

      <para>Наконец, скрипты безопасности должны обработать лог файлы,
	которые необходимо создавать настолько защищенным способом, насколько
	это возможно &mdash; подключение syslog удаленно может быть очень
	полезным.  Злоумышленник попытается уничтожить следы взлома,
	и лог файлы критически важны для системного администратора,
	пытающегося отследить время и метод первого проникновения.
	Один из надежных способов получения лог файлов является подключение
	системной консоли к последовательному порту и постоянный
	сбор информации через защищенную машину, отслеживающую
	консоли.</para>
    </sect2>

    <sect2>
      <title>Паранойя</title>

      <para>Немного паранойи никогда не повредит.  Как правило, системный
	администратор может добавлять элементы безопасности в любом
	количестве, пока это не влияет на удобство, а также некоторое
	количество элементов безопасности, <emphasis>влияющих</emphasis>
	на удобство.  Что даже более важно, системный администратор должен
	немного изменить их &mdash; если вы используете рекомендации, например
	те, что даны в этом документе, они становятся известны атакующему,
	который также имеет доступ к этому документу.
	prospective attacker who also has access to this document.</para>
    </sect2>

    <sect2>
      <title>Атаки DoS</title>
      <indexterm><primary>Отказ в обслуживании (DoS)</primary></indexterm>

      <para>Этот раздел охватывает DoS атаки.  DoS атаки это обычно
	пакетные атаки.  Хотя против современной атаки с подделкой пакетов,
	которая перегружает сеть, мало что можно сделать, вы можете
	ограничить повреждения, убедившись, что атака не может
	обрушить ваши сервера.</para>

      <orderedlist>
	<listitem>
	  <para>Ограничение количества порождаемых процессов.</para>
	</listitem>

	<listitem>
	  <para>Уменьшение последствий springboard атак (ICMP ответ,
	    широковещательный ping и т.д.).</para>
	</listitem>

	<listitem>
	  <para>Кэш маршрутизации ядра.</para>
	</listitem>
      </orderedlist>

      <para>Обычная DoS атака против порождающего процессы сервера пытается
	исчерпать ресурсы сервера по процессам, файловым дескрипторам и
	памяти до тех пор, пока машина не <quote>подвиснет</quote>.  У
	<application>inetd</application> (обратитесь к &man.inetd.8;)
	есть несколько параметров, позволяющих ограничить такие атаки.
	Необходимо учесть, что хотя можно предотвратить падение системы, в
	общем случае невозможно предотвратить прекращение работы сервиса.
	Внимательно прочтите страницу справочника и обратите особое внимание
	на параметры <option>-c</option>, <option>-C</option>, и
	<option>-R</option>.  Учтите, что параметр <option>-C</option> не
	работает в случае атак с использованием поддельных IP пакетов,
	поэтому как правило необходимо использование комбинации параметров.
	Некоторые standalone сервисы используют собственные параметры,
	ограничивающие порождение процессов.</para>

      <para>У <application>Sendmail</application> есть собственный параметр
	<option>-OMaxDaemonChildren</option>, которая работает гораздо лучше,
	чем параметр sendmail, ограничивающий нагрузку. Вам необходимо задать
	параметр запуска <application>sendmail</application>
	<literal>MaxDaemonChildren</literal> достаточно большим, чтобы
	обслуживать ожидаемую нагрузку, но так, чтобы компьютер мог обслужить
	такое количество приложений <application>sendmail</application> без
	падения системы.  Хорошей мерой является запуск sendmail в режиме
	очереди (<option>-ODeliveryMode=queued</option>) и запуск даемона
	(<command>sendmail -bd</command>) отдельно от очереди
	(<command>sendmail -q15m</command>).  Если вы все же хотите
	организовать доставку в режиме реального времени, запускайте
	очередь с меньшим интервалом <option>-q1m</option>, но убедитесь
	в правильной установке параметра sendmail
	<literal>MaxDaemonChildren</literal> для предотвращения
	ошибок.</para>

      <para><application>Syslogd</application> может быть атакован
	непосредственно, настоятельно рекомендуется использовать параметр
	<option>-s</option> если это возможно и параметр <option>-a</option>
	в остальных случаях.</para>

      <para>Вы также должны быть очень осторожны с сервисами, совершающими
	обратное подключение, такими как <application>tcpwrapper</application>
	с reverse-identd, который может быть атакован непосредственно.
	По этой причине возможность <application>tcpwrappers</application>
	reverse-ident обычно не следует использовать.</para>

      <para>Правильным будет запрет доступа к внутренним сервисам из внешней
	сети путем соответствующей настройки межсетевого экрана на внешнем
	маршрутизаторе.  Идея в том, чтобы предотвратить перегрузку сервисов
	атаками из внешней сети, а кроме того защитить
	<username>root</username> от взлома через сеть.  Всегда настраивайте
	исключающий межсетевой экран, т.е. <quote>закрыть все
	<emphasis>кроме</emphasis> портов A, B, C, D, и M-Z</quote>.
	Этим способом вы можете закрыть все порты нижнего диапазона,
	кроме явно указанных, таких как <application>named</application>
	(если вы поддерживаете интернет-зону),
	<application>ntalkd</application>,
	<application>sendmail</application>, и других сервисов, доступных
	из интернет.  Если вы попробуете настроить межсетевой экран другим
	способом &mdash; включающий, или разрешающий межсетевой экран, есть
	большой шанс забыть <quote>закрыть</quote> пару сервисов, или
	добавить новый внутрисетевой сервис и забыть обновить межсетевой
	экран.  Вы можете открыть диапазон портов с большими номерами
	для обычных приложений без угрозы портам нижнего диапазона.
	Учтите также, что FreeBSD позволяет вам контролировать диапазоны
	портов, используемые для динамической привязки через различные
	переменные <command>sysctl</command>
	<varname>net.inet.ip.portrange</varname> (<command>sysctl -a | fgrep
	portrange</command>), что позволяет упростить настройку
	межсетевого экрана.  Например, вы можете использовать обычный
	диапазон портов со значениями от 4000 до 5000, и диапазон портов с
	большими номерами от 49152 до 65535, а затем заблокировать все до
	4000 порта (конечно оставив доступ из интернет к определенным
	портам.</para>

      <indexterm><primary>ICMP_BANDLIM</primary></indexterm>

      <para>Другой распространенный тип DoS атак называется springboard
	&mdash; сервер атакуется таким образом, что генерируемые ответы
	перегружают его, локальную сеть или какие-то другие компьютеры.
	Наиболее распространенная атака этого вида это
	<emphasis>широковещательная ICMP ping атака</emphasis>.
	Атакующий подделывает пакеты ping, подставляя IP адрес машины, которую
	он намеревается атаковать, и отправляет их на широковещательный
	адрес вашей локальной сети.  Если ваш внешний маршрутизатор не
	настроен на отбрасывание пакетов ping на широковещательные адреса,
	ваша сеть начинает генерировать соответствующие ответы на
	поддельный адрес, что приводит к перегрузке хоста-жертвы, особенно
	если атакующий использует этот же трюк с множеством
	широковещательных адресов в множестве сетей одновременно.
	Были зарегистрированы широковещательные атаки свыше ста двадцати
	мегабит.  Другая распространенная springboard атака направлена на
	ICMP систему сообщения об ошибках.  Конструируя пакеты, вызывающие
	ICMP сообщения об ошибках, атакующий может нагрузить входящее
	соединение сервера и вынудить сервер нагрузить исходящее соединение
	ICMP ответами.  Этот тип атаки может также обрушить сервер, когда
	тот исчерпает mbuf, обычно если сервер не может ограничить число
	ответов ICMP, когда они генерируются слишком быстро.  В ядре
	FreeBSD есть новая опция сборки, <option>ICMP_BANDLIM</option>,
	которая ограничивает эффективность этого типа атак.  Последний
	основной класс springboard атак относится к определенным
	внутренним сервисам <application>inetd</application>, таким как
	сервис udp echo.  Атакующий просто подделывает адрес источника
	и адрес назначения UDP пакетов, устанавливая в их качестве
	соответственно echo порт сервера A и B, оба этих сервера принадлежат
	вашей локальной сети.  Эти два сервера начинают перебрасываться
	этим пакетом друг с другом.  Атакующий может вызвать перегрузку
	обеих серверов и их сетей, просто отправив несколько пакетов таким
	способом.  Аналогичные проблемы существуют с портом
	<application>chargen</application>.  Компетентный системный
	администратор должен отключить эти тестовые сервисы inetd.</para>

      <para>Атаки с поддельными пакетами могут также использоваться для
	переполнения кэша маршрутизации ядра.  Обратитесь к параметрам
	<command>sysctl</command> <varname>net.inet.ip.rtexpire</varname>,
	<varname>rtminexpire</varname>, и <varname>rtmaxcache</varname>.
	Атака с поддельными пакетами, использующая произвольный IP адрес
	источника, заставит ядро сгенерировать временный кэшированный
	маршрут в таблице маршрутизации, который можно увидеть с помощью
	<command>netstat -rna | fgrep W3</command>.  Эти маршруты обычно
	удаляются через 1600 секунд или около того.  Если ядро определит,
	что кэшированная маршрутная таблица стала слишком большой, оно
	динамически уменьшит <varname>rtexpire</varname>, но никогда не
	станет делать его меньше чем <varname>rtminexpire</varname>.
	С этим связаны две проблемы:</para>
	
      <orderedlist>
	<listitem>
	  <para>Ядро не отреагирует достаточно быстро, когда легко нагруженный
	    сервер будет внезапно атакован.</para>
	</listitem>
	
	<listitem>
	  <para>Значение <varname>rtminexpire</varname> недостаточно мало
	    для поддержки работоспособности в условиях продолжительной
	    атаки.</para>
	</listitem>
      </orderedlist>

      <para>Если ваши серверы подключены к интернет через линию T3 или
	более быструю, предусмотрительно будет изменить оба значения
	<varname>rtexpire</varname> и <varname>rtminexpire</varname>
	с помощью &man.sysctl.8;.  Никогда не устанавливайте ни один из этих
	параметров в нуль (если только вы не хотите обрушить систему).
	Установка обеих параметров в значение 2 секунды должна предотвратить
	таблицу маршрутизации от атак.</para>
    </sect2>

    <sect2>
      <title>Проблемы, связанные с доступом к Kerberos и SSH</title>
      <indexterm><primary><command>ssh</command></primary></indexterm>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>При использовании Kerberos и ssh необходимо учесть несколько
	возможных проблем.  Kerberos V это отличный протокол
	аутентификации, но в адаптированных к нему приложениях
	<application>telnet</application> и
	<application>rlogin</application> есть несколько ошибок, которые
	могут сделать их непригодными к работе с бинарными потоками.
	К тому же, по умолчанию Kerberos не шифрует сессию, если вы не
	используете параметр <option>-x</option>.
	<application>ssh</application> шифрует все по умолчанию.

      <para>ssh работает очень хорошо во всех ситуациях, но пересылает
	ключи по умолчанию.  Это означает, что если вы работаете с
	защищенной рабочей станции, ключи на которой дают доступ к
	остальной сети, и заходите по ssh на незащищенный компьютер,
	эти ключи могут быть использованы для взлома.  Атакующему
	не удастся получить сами ключи, но поскольку ssh открывает порт
	во время входа в систему, то если на незащищенной машине
	взломан <username>root</username>, эти ключи могут быть использованы
	для доступа к другим компьютерам, на которых они действуют.</para>

      <para>Мы рекомендуем использовать ssh в комбинации с Kerberos
	для служебных учетных записей если это возможно.
	<application>ssh</application> может быть собран с поддержкой
	Kerberos.  Это уменьшает зависимость от потенциально подверженных
	взлому ssh ключей, и в то же время защищает пароли через
	Kerberos.  Ключи ssh должны использоваться только для работы
	скриптов на защищенных компьютерах (там, где Kerberos использовать
	не получится).  Мы также рекомендуем или выключить передачу ключей
	в настройках ssh, или использовать параметр
	<literal>from=IP/DOMAIN</literal>, поддерживаемый ssh в файле
	<filename>authorized_keys</filename>, который позволяет использовать
	ключи только с определенных компьютеров.</para>
    </sect2>
  </sect1>

  <sect1 id="crypt">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Swingle</surname>
	  <contrib>Частично переписал и обновил </contrib>
	</author>
      </authorgroup>
      <!-- 21 Mar 2000 -->
    </sect1info>

    <title>DES, MD5, и шифрование</title>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>шифрование</secondary>
    </indexterm>

    <indexterm><primary>шифрование</primary></indexterm>
    <indexterm><primary>DES</primary></indexterm>
    <indexterm><primary>MD5</primary></indexterm>

    <para>У каждого пользователя &unix; системы есть пароль, связанный с его
      учетной записью.  Очевидно, что эти пароли должны быть известны только
      пользователю и соответствующей операционной системе.  Для защиты паролей
      они шифруются способом, известным как <quote>односторонний хэш</quote>,
      то есть их можно легко зашифровать, но нельзя расшифровать.  Другими
      словами, то, что мы сказали чуть раньше было очевидно, но не совсем
      верно: операционной системе <emphasis>сам пароль</emphasis>
      неизвестен.  Ей известен только пароль в
      <emphasis>зашифрованной</emphasis> форме.  Единственный способ получить
      <quote>обычный</quote> пароль это простой перебор всех возможных
      паролей.</para>

    <para>К сожалению, единственный способ шифрования пароля при появлении
      &unix; был основан на DES, Data Encryption Standard.  Это не было
      проблемой для пользователей, живущих в США, но поскольку исходный код
      DES нельзя было экспортировать из США, FreeBSD нашла способ одновременно
      не нарушать законов США и сохранить совместимость со всеми другими
      вариантами &unix;, где все еще использовался DES.</para>

    <para>Решение было в разделении библиотек шифрования, чтобы пользователи
      в США могли устанавливать и использовать библиотеки DES, а у остальных
      пользователей был метод шифрования, разрешенный к экспорту.  Так
      FreeBSD пришла к использованию MD5 в качестве метода шифрования по
      умолчанию.  MD5 считается более безопасным, чем DES, поэтому установка
      DES рекомендуется в основном из соображений совместимости.</para>

    <sect2>
      <title>Определения механизма шифрования</title>

      <para>До FreeBSD&nbsp;4.4 <filename>libcrypt.a</filename> была
	символической ссылкой на библиотеку, используемую для шифрования.
	В FreeBSD&nbsp;4.4 <filename>libcrypt.a</filename> была изменена
	для предоставления настраиваемой библиотеки аутентификации по хэшу
	пароля.  На данный момент библиотека поддерживает хэши DES, MD5 и
	Blowfish.  По умолчанию FreeBSD использует для шифрования паролей
	MD5.</para>

      <para>Довольно легко определить какой метод шифрования используется
	в FreeBSD.  Один из способов это проверка файла
	<filename>/etc/master.passwd</filename>.  Пароли, зашифрованные в
	хэш MD5 длиннее, чем те, что зашифрованы с помощью DES и начинаются
	с символов <literal>&dollar;1&dollar;</literal>.  Пароли, начинающиеся
	с символов <literal>&dollar;2a&dollar;</literal> зашифрованы с помощью
	Blowfish.  Пароли, зашифрованные DES не содержат каких-то определенных
	идентифицирующих символов, но они короче, чем пароли MD5 и
	закодированы в 64-символьном алфавите, не содержащем символа
	<literal>&dollar;</literal>, поэтому относительно короткая строка,
	не начинающаяся с этого символа это скорее всего DES пароль.</para>

      <para>Формат паролей, используемых для новых паролей, определяется
	параметром <literal>passwd_format</literal> в
	<filename>/etc/login.conf</filename>, которое может принимать значения
	<literal>des</literal>, <literal>md5</literal> или
	<literal>blf</literal>.  Обратитесь к странице справочника
	&man.login.conf.5; за дополнительной информацией о параметрах
	login.</para>

    </sect2>
  </sect1>

  <sect1 id="one-time-passwords">
    <title>Одноразовые пароли</title>
    <indexterm><primary>одноразовые пароли</primary></indexterm>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>одноразовые пароли</secondary>
    </indexterm>

    <para>S/Key это схема с одноразовыми паролями, основанная на одностороннем
      хэше.   FreeBSD использует хэш MD4 для совместимости, но другие системы
      используют MD5 и DES-MAC.  S/Key была частью базовой системы FreeBSD
      начиная с версии 1.1.5 и используется также во все большем числе
      операционных систем.  S/Key это зарегистрированная торговая марка
      Bell Communications Research, Inc.</para>

    <para>Начиная с FreeBSD версии 5.0, S/Key была замещена на функциональный
      эквивалент &mdash; OPIE (One-time Passwords In Everything).
      OPIE по умолчанию использует MD5.</para>

    <para>Есть три различных вида паролей, о которых мы поговорим ниже.
      Первый вид это ваш обычный пароль &unix; или пароль Kerberos; мы
      будем называть его <quote>пароль &unix;</quote>.  Второй вид это
      одноразовый пароль, сгенерированный программой S/Key
      <command>key</command> или программой OPIE &man.opiekey.1; и принимаемый
      командами <command>keyinit</command> или &man.opiepasswd.1;
      и в приглашении login; мы будем называть их <quote>одноразовыми
      паролями</quote>.  Последний вид паролей это защищенные пароли, которые
      вы передаете программам
      <command>key</command>/<command>opiekey</command> (и иногда
      программам <command>keyinit</command>/<command>opiepasswd</command>),
      и которые эти программы используют для создания одноразовых паролей;
      мы будем называть его <quote>защищенными паролями</quote> или просто
      <quote>паролями</quote>.</para>

    <para>Защищенный пароль не имеет никакого отношения к вашему паролю
      &unix;; они могут быть одинаковыми, но это не рекомендуется.
      Защищенные пароли S/Key и OPIE не ограничены 8-ю символами, как
      старые &unix; пароли<footnote><para>В &os; стандартный пароль
      может быть до 128 символов длиной.</para></footnote>,
      они могут быть настолько длинными, насколько вы захотите.  Очень часто
      используются пароли длиной в шесть или семь символов.  По большей части
      система S/Key или OPIE работает полностью независимо от системы
      паролей &unix;.</para>

    <para>Помимо паролей, есть два других вида данных, важных для S/Key и
      OPIE.  Первый, известный как <quote>seed</quote> или
      <quote>ключ</quote>, состоит из двух букв и пяти цифр.  Другой,
      называемый <quote>счетчиком цикла</quote>, это номер от 1 до 100.
      S/Key создает одноразовый пароль, соединяя ключ и защищенный пароль,
      а затем применяя MD4/MD5 столько раз, сколько указано счетчиком цикла и
      выдает результат в виде шести коротких слов на английском.  Эти шесть
      слов на английском и есть ваш одноразовый пароль.  Система
      аутентификации (как правило PAM) хранит последний использованный
      одноразовый пароль, и пользователь аутентифицитуется если хэш вводимого
      пользователем пароля совпадает с предыдущим паролем.  Поскольку
      используется односторонний хэш, невозможно сгенерировать следующий
      одноразовый пароль если получен предыдущий; счетчик цикла уменьшается
      после каждого успешного входа для поддержки синхронизации пользователя
      с программой login.  Когда счетчик цикла уменьшается до 1, S/Key и OPIE
      должны быть переинициализированы.</para>

    <para>В каждой из обсуждаемых ниже систем задействованы три программы.
      Программы <command>key</command> и <command>opiekey</command>
      получают счетчик цикла, ключ и защищенный пароль и создают одноразовый
      пароль или последовательный список одноразовых паролей.  Программы
      <command>keyinit</command> и <command>opiepasswd</command>
      используются для инициализации S/Key и OPIE соответственно,
      и для смены паролей, счетчиков цикла, или ключей; они принимают
      защищенный пароль или счетчик цикла, ключ и одноразовый пароль.
      Программы <command>keyinfo</command> и <command>opieinfo</command>
      проверяют соответствующие файлы (<filename>/etc/skeykeys</filename>
      или <filename>/etc/opiekeys</filename>) и печатают текущий счетчик
      цикла и ключ вызывающего пользователя.</para>

    <para>Мы рассмотрим четыре вида операций.  Первая это использование
      <command>keyinit</command> или <command>opiepasswd</command> через
      защищенное соединение для первоначальной настройки системы одноразовых
      паролей, или для изменения пароля или ключа.  Вторая операция это
      использование в тех же целях <command>keyinit</command> или
      <command>opiepasswd</command> через незащищенное соединение, в сочетании
      с <command>key</command> или <command>opiekey</command> через защищенное
      соединение.  Третья это использование
      <command>key</command>/<command>opiekey</command> для входа через
      незащищенное соединение.  Четвертая это использование
      <command>key</command> или <command>opiekey</command> для генерации
      набора ключей, которые могут быть записаны или распечатаны для
      соединения из места, где защищенное соединение недоступно.</para>

    <sect2>
      <title>Защищенная установка соединения</title>

      <para>Для первоначальной настройки S/Key, измените ваш пароль или
	ключ при входе через защищенное соединение (например, с консоли
	компьютера или через <application>ssh</application>), используйте
	команду <command>keyinit</command> без параметров при входе под
	своим именем:</para>

      <screen>&prompt.user; <userinput>keyinit</userinput>
Adding unfurl:
Reminder - Only use this method if you are directly connected.
If you are using telnet or rlogin exit with no password and use keyinit -s.
Enter secret password: 
Again secret password: 

ID unfurl s/key is 99 to17757
DEFY CLUB PRO NASH LACE SOFT</screen>

      <para>Для OPIE, вместо этого используется
	<command>opiepasswd</command>:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
</screen>

      <para>В приглашениях <prompt>Enter new secret pass phrase:</prompt> или
	<prompt>Enter secret password:</prompt>, введите пароль или фразу.
	Запомните, это не тот пароль, с которым вы будете входить, он
	используется для генерации одноразовых паролей.  Строка
	<quote>ID</quote> содержит информацию для вашего конкретного случая:
	имя пользователя, счетчик цикла и ключ.  При входе система запомнит
	эти параметры и отправит их вам, поэтому их не надо запоминать.  В
	последней строке находится одноразовый пароль, соответствующий
	этим параметрам и секретному паролю; если вы войдете в систему сразу,
	используйте этот одноразовый пароль.</para>
    </sect2>

    <sect2>
      <title>Незащищенная установка соединения</title>

      <para>Для инициализации или изменения защищенного пароля через
	незащищенное соединение, вам потребуется существующее защищенное
	соединение куда-то, где вы сможете запустить <command>key</command>
	или <command>opiekey</command>; это может быть средство доступа
	&macintosh; или shell на компьютере, которому вы доверяете.
	Вам потребуется также установить значение счетчика цикла (100
	возможно подойдет), и задать ключ или использовать сгенерированный.
	Через незащищенное соединение (к компьютеру, на котором производится
	настройка), используйте команду <command>keyinit -s</command>:</para>

      <screen>&prompt.user; <userinput>keyinit -s</userinput>
Updating unfurl:
Old key: to17758
Reminder you need the 6 English words from the key command.
Enter sequence count from 1 to 9999: <userinput>100</userinput>
Enter new key [default to17759]: 
s/key 100 to 17759
s/key access password:
s/key access password:<userinput>CURE MIKE BANE HIM RACY GORE</userinput>
</screen>

      <para>Для OPIE, используйте <command>opiepasswd</command>:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
</screen>

	<!--russian translation issue: seed/key == ключ? -->
      <para>Чтобы принять ключ по умолчанию <!--(which the
	<command>keyinit</command> program confusingly calls a
	<literal>key</literal>), --> нажмите <keycap>Enter</keycap>.
	Затем, перед вводом пароля доступа введите те же параметры в
	вашем защищенном соединении или средстве доступа S/Key:</para>

      <screen>&prompt.user; <userinput>key 100 to17759</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;secret password&gt;</userinput>
CURE MIKE BANE HIM RACY GORE</screen>

      <para>Или для OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</screen>

      <para>Теперь переключитесь на незащищенное соединение и скопируйте
	одноразовый пароль, сгенерированный соответствующей программой.</para>
    </sect2>

    <sect2>
      <title>Создание одного одноразового пароля</title>

      <para>Как только вы настроите S/Key или OPIE, во время входа появится
	приглашение вроде этого:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: </screen>

      <para>Или для OPIE:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para>Кроме того, у S/Key и OPIE есть полезная особенность (не
	показанная здесь): если вы нажмете <keycap>Enter</keycap>
	в приглашении на ввод пароля, включится эхо, и вы сможете увидеть
	то, что вводите.  Это может быть очень полезно, если вы пытаетесь
	ввести пароль вручную, например с распечатки.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>В этот момент вам потребуется сгенерировать одноразовый пароль,
	чтобы ввести его в приглашение.  Это должно быть выполнено на
	защищенной системе, в которой вы можете запустить
	<command>key</command> или <command>opiekey</command> (есть версии
	для DOS, &windows; и &macos;).  Им требуются значения счетчика цикла
	и ключ в качестве параметров командной строки.  Вы можете скопировать
	и вставить их прямо из приглашения login компьютера, на который
	входите.</para>

      <para>В защищенной системе:</para>

      <screen>&prompt.user; <userinput>key 97 fw13894</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: 
WELD LIP ACTS ENDS ME HAAG</screen>

      <para>Для OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Теперь, когда у вас есть одноразовый пароль, можете продолжить
	вход в систему:</para>

      <screen>login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: <userinput>&lt;return to enable echo&gt;</userinput>
s/key 97 fw13894
Password [echo on]: WELD LIP ACTS ENDS ME HAAG
Last login: Tue Mar 21 11:56:41 from 10.0.0.2 ... </screen>

    </sect2>

    <sect2>
      <title>Создание нескольких одноразовых паролей</title>

      <para>Иногда вы отправляетесь туда, где нет доступа к защищенному
	компьютеру или защищенному соединению.  В этом случае, можно
	использовать команды <command>key</command> и
	<command>opiekey</command> для создания нескольких одноразовых
	паролей, которые вы сможете распечатать и забрать с собой.
	Например:</para>

      <screen>&prompt.user; <userinput>key -n 5 30 zz99999</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;secret password&gt;</userinput>
26: SODA RUDE LEA LIND BUDD SILT 
27: JILT SPY DUTY GLOW COWL ROT  
28: THEM OW COLA RUNT BONG SCOT  
29: COT MASH BARR BRIM NAN FLAG  
30: CAN KNEE CAST NAME FOLK BILK</screen>

      <para>Или для OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para>Параметр <option>-n 5</option> запрашивает пять паролей,
	<option>30</option> указывает значение последнего счетчика цикла.
	Обратите внимание, что пароли печатаются в
	<emphasis>обратном</emphasis> по сравнению с обычным использованием
	порядке.  Если вы действительно параноик, перепишите результат
	вручную; иначе скопируйте и передайте его <command>lpr</command>.
	Обратите внимание, что каждая линия содержит как счетчик цикла, так
	и одноразовый пароль; вам может показаться удобным отрывать пароль
	после использования.</para>
    </sect2>

    <sect2>
      <title>Ограничение использования &unix; паролей</title>

      <para>S/Key может наложить ограничения на использование &unix; паролей
	на основе имени хоста, имени пользователя, порта терминала или IP
	адреса сессии.  Эти ограничения можно найти в файле настройки
	<filename>/etc/skey.access</filename>.  Страница справочника
	&man.skey.access.5; содержит дополнительную информацию о полном
	формате файла а также детали о некоторых предосторожностях, которые
	должны быть предприняты перед тем, как положиться в вопросах
	безопасности на этот файл.</para>

      <para>Если файла <filename>/etc/skey.access</filename> нет (это
	ситуация по умолчанию в системах FreeBSD 4.X), всем пользователям
	будет разрешено входить с паролями &unix;.  Если файл существует,
	использование S/Key станет обязательно для всех, если только
	параметры настройки в файле <filename>skey.access</filename> не
	указывают иначе.  В любом случае, пароли &unix; разрешены при входе
	с консоли.</para>

      <para>Вот пример файла настройки <filename>skey.access</filename>,
	иллюстрирующий три наиболее распространенных вида параметров
	настройки:</para>

      <programlisting>permit internet 192.168.0.0 255.255.0.0
permit user fnord
permit port ttyd0</programlisting>

      <para>Первая строка (<literal>permit internet</literal>) разрешает
	пользователям, чей IP адрес (который подвержен подделке)
	соответствует заданному значению и маске, входить с использованием
	паролей &unix;.  Это должно рассматриваться не как механизм
	безопасности, а как напоминание пользователям, что они работают через
	небезопасное соединение и должны использовать для аутентификации
	S/Key.</para>

      <para>Вторая строка (<literal>permit user</literal>) позволяет
	определенным пользователям, в данном случае
	<username>fnord</username>, всегда использовать пароли &unix;.
	Вообще говоря, это должно использоваться только для тех, кто
	не может использовать программу <command>key</command>, например
	если они работают с простых терминалов или необучаемы.</para>

      <para>Третья строка (<literal>permit port</literal>) позволяет всем
	пользователям, вошедшим с определенного терминала использовать
	пароли &unix;; этот параметр должен использоваться для подключений
	по dial-up.</para>

      <para>OPIE может ограничивать использование паролей &unix; на основе IP
	адреса как и S/Key.  Соответствующий файл называется
	<filename>/etc/opieaccess</filename>, он существует по умолчанию в
	FreeBSD 5.0 и более современных системах.  Обратитесь к
	&man.opieaccess.5; за более подробной информацией об этом файле и о
	предосторожностях, которые вы должны предпринять при использовании
	этого файла.</para>
	
      <para>Вот пример файла <filename>opieaccess</filename>:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>Эта строка позволяет пользователям, чей IP адрес (который
	подвержен подделке) соответствует указанному значению и маске,
	входить с паролем &unix;.</para>
	
      <para>Если ни одно из правил в <filename>opieaccess</filename> не
	сработало, поведением по умолчанию является запрет всех не-OPIE
	входов.</para>

    </sect2>
  </sect1>

  <sect1 id="tcpwrappers">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Написал: </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>TCP Wrappers</primary></indexterm>
      
    <title>TCP Wrappers</title>

    <para>Каждый, кто знаком с &man.inetd.8;, возможно когда-то слышал
      о <acronym>TCP</acronym> Wrappers.  Но немногие полностью
      понимают их полезность в сетевой среде: большинство
      используют брандмауэр.  Хотя его применимость очень широка,
      есть вещи, с которыми брандмауэр не может работать, такие
      как отправка текста обратно вызывающей стороне.  Программное
      обеспечение уровня <acronym>TCP</acronym> может делать это
      и многое другое.  В следующих нескольких разделах обсуждаются
      многие возможности <acronym>TCP</acronym> Wrappers, и, когда
      это необходимо, даются примеры настроек.</para>

    <para>Программное обеспечение <acronym>TCP</acronym> Wrappers
      расширяет возможность <command>inetd</command> по поддержке
      каждого даемона.  С ним становится возможным протоколирование,
      возврат сообщений вызывающей стороне, ограничение подключений
      внутренней сетью и т.п.  Хотя некоторые из этих возможностей
      могут быть реализованы брандмауэром, <acronym>TCP</acronym>
      Wrappers не только предоставляют дополнительный уровень защиты,
      но и дают больше контроля над системой, чем это возможно
      с брандмауэром.</para>
<!-- removed from translation: reudant info
    <para>The added functionality of <acronym>TCP</acronym> Wrappers
      should not be considered a replacement for a good firewall;
      however, but should used in conjunction with a firewall and
      other security configurations to add an extra layer of protection
      for the system.</para>
-->
    <para>Поскольку рассматривается расширение к настройкам
      <command>inetd</command>, предполагается, что читатель ознакомился
      с разделом о <link linkend="network-inetd">настройке
      inetd</link>.</para>

    <note>
      <para>Хотя программы, запускаемые из &man.inetd.8;, на самом деле не
	соответствуют термину <quote>даемоны</quote>, существует традиция
	называть их именно так.  Этот термин и используется в данном
	разделе.</para>
    </note>

    <sect2>
      <title>Начальная настройка</title>

      <para>Единственное требование для использования <acronym>TCP</acronym>
	Wrappers в &os; это наличие в <filename>rc.conf</filename>
	параметров запуска <command>inetd</command> <option>-Ww</option>;
	это настройки по умолчанию.  Конечно, ожидается также наличие
	правильной настройки <filename>/etc/hosts.allow</filename>,
	но &man.syslogd.8; отправит сообщения в системный протокол если
	что-то не так.</para>

      <note>
	<para>В отличие от других реализаций <acronym>TCP</acronym>
	  Wrappers, использование <filename>hosts.deny</filename> не
	  поддерживается.  Все параметры настройки должны быть помещены
	  в <filename>/etc/hosts.allow</filename>.</para>
      </note>

      <para>В простейшей конфигурации, политика подключения сводится к
	разрешению или блокированию в зависимости от параметров в
	<filename>/etc/hosts.allow</filename>.  Настройка в &os;
	по умолчанию заключается в разрешении подключения к любому
	даемону, запущенному из <command>inetd</command>.  Изменение
	этого поведения будет обсуждаться только после рассмотрения
	базовой настройки.</para>

      <para>Базовая настройка обычно принимает форму
	<literal>daemon : address : action</literal>, где
	<literal>daemon</literal> это имя даемона, который запускается
	<command>inetd</command>.  В поле <literal>address</literal>
	может находиться имя хоста, <acronym>IP</acronym> адрес, или
	IPv6 адрес, заключенный в квадратные скобки ([&nbsp;]).
	Поле action может принимать значения allow или deny,
	чтобы соответственно разрешать или запрещать доступ.
	Помните, что поиск правил производится до первого совпадения.
	При обнаружении совпадения применяется соответствующее правило
	и поиск прерывается.</para>

      <para>Существуют и другие параметры, но они будут описаны в следующих
	разделах.  Простая конфигурация может быть, например, такой:
	для разрешения соединений по протоколу <acronym>POP</acronym>3
	к даемону <filename role="package">mail/qpopper</filename>,
	в <filename>hosts.allow</filename> необходимо добавить следующие
	строки:</para>

      <programlisting># This line is required for POP3 connections:
qpopper : ALL : allow</programlisting>

      <para>После добавления этой строки, <command>inetd</command>
	необходимо перезапустить.  Это можно выполнить командой
	&man.kill.1; или скриптом <filename>/etc/rc.d/inetd</filename>
	с параметром <parameter>restart</parameter>.</para>
      </sect2>

      <sect2>
        <title>Расширенная конфигурация</title>

      <para>У <acronym>TCP</acronym> Wrappers имеются дополнительные
	параметры; они дают дополнительные возможности контроля над
	соединениями.  Иногда бывает полезно возвращать комментарий
	определенным хостам или при подключении к определенным
	даемонам.  В других случаях может быть необходимо добавить
	запись в лог файл, или отправить письмо администратору.
	В определенных ситуациях сервис должен использоваться
	только для локальных соединений.  Все это возможно с
	использованием параметров c шаблонами, символами подстановки
	и путем выполнения внешних команд.  Следующие два раздела
	посвящены этим типам настроек.</para>

      <sect3>
	<title>Внешние команды</title>

	<para>Предположим ситуацию, в которой соединение должно
	  быть запрещено, а о причине необходимо сообщить вызывающей
	  стороне.  Как это можно сделать?  Соответствующую
	  возможность предоставляет параметр <option>twist</option>.
	  При попытке подключения выполняется команда или скрипт,
	  заданный этим параметром.  Пример дан в файле
	  <filename>hosts.allow</filename>:</para>

	<programlisting># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

	<para>В этом примере сообщение,
	  <quote>You are not allowed to use <literal>daemon</literal>
	  from <literal>hostname</literal>.</quote> будет возвращено
	  от всех даемонов, которые не были предварительно настроены
	  в файле доступа.  Обратите внимание, что возвращаемое
	  сообщение <emphasis>должно</emphasis> быть заключено в
	  кавычки; из этого правила нет исключений.</para>

	<warning>
	  <para>Возможна реализация DoS атаки, когда группа
	    атакующих производит множество запросов на подключение.</para>
	</warning>

	<para>Возможно также использование параметра <option>spawn</option>.
	  Как и параметр <option>twist</option>, параметр
	  <option>spawn</option> подразумевает запрет соединения
	  и может использоваться для запуска команд или скриптов.
	  В отличие от <option>twist</option>, <option>spawn</option> не
	  отправляет ответ вызывающей стороне.  Например, следующая
	  конфигурация:</para>

	<programlisting># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</programlisting>

	<para>отклонит все попытки соединения из домена
	  <hostid role="fqdn">*.example.com</hostid>; имя хоста,
	  <acronym>IP</acronym> адрес и даемон протоколируются в файл
	  <filename>/var/log/connections.log</filename>.</para>

	<para>Помимо приведенных выше символов подстановки, например
	  %a, существует еще несколько символов.  Обратитесь к странице
	  &man.hosts.access.5; справочной системы за полным списком.</para>
      </sect3>

      <sect3>
	<title>Параметры &ndash; шаблоны</title>

	<para>До этого момента в примерах использовался шаблон 
	  <literal>ALL</literal>.  Существуют и другие параметры,
	  функциональность которых в дальнейшем может быть расширена.
	  <literal>ALL</literal> соответствует любому даемону,
	  домену или <acronym>IP</acronym> адресу.  Другой доступный
	  шаблон это <literal>PARANOID</literal>, который соответствует
	  хосту, <acronym>IP</acronym> адрес которого может быть
	  подделан.  Другими словами, <literal>paranoid</literal>
	  может быть использован для определения действия с хостами,
	  <acronym>IP</acronym> адрес которых не соответствует имени
	  хоста.  Вот пример применения этого параметра:</para>

	<programlisting># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</programlisting>

	<para>В этом примере все запросы на подключения к
	  <command>sendmail</command> от хостов, <acronym>IP</acronym>
	  адрес которых не соответствует имени хоста, будут
	  отклонены.</para>

	<caution>
	  <para>Использование <literal>PARANOID</literal> невозможно,
	    если у клиента или сервера неправильно настроен
	    <acronym>DNS</acronym>.  В таких случаях необходимо
	    вмешательство администратора.</para>
	</caution>

	<para>Более подробная информация о шаблонах и их возможностях
	  дана на странице &man.hosts.access.5; справочной
	  системы.</para>

	<para>Для того, чтобы любая выбранная конфигурация заработала,
	  в <filename>hosts.allow</filename> необходимо закомментировать
	  первую строку настройки.  В начале раздела об этом не
	  упоминалось.</para>
      </sect3>
    </sect2>
  </sect1>

<!--
  Разделы по Kerberos переведены не вполне корректно в связи с использованием
  следующих терминов: principal, ticket, realm, credentials.
  Возможно, требуется существенная переработка перевода.
-->

  <sect1 id="kerberosIV">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Murray</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Dapoz</surname>
	  <contrib>Оригинальный текст предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>KerberosIV</application></title>

    <para>Kerberos это сетевая дополнительная система/протокол, которая
      делает возможной аутентификацию пользователей через сервисы на защищенном
      сервере.  Такие сервисы, как удаленный вход, удаленное копирование,
      защищенное копирование файлов между системами и другие задачи с
      высоким риском становятся допустимо безопасными и более
      контролируемыми.</para>

    <para>Последующие инструкции могут использоваться в качестве руководства
      по настройке поставляемого с FreeBSD Kerberos.  Тем не менее, вам
      могут потребоваться страницы справочника полного дистрибутива.</para>

    <sect2>
      <title>Установка <application>KerberosIV</application></title>

      <indexterm><primary>MIT</primary></indexterm>
      <indexterm>
	<primary>KerberosIV</primary>
	<secondary>установка</secondary>
      </indexterm>
      <para>Kerberos это опциональный компонент &os;.  Простейший способ
	установки этой программы это выбор <literal>krb4</literal> или
	<literal>krb5</literal> из <application>sysinstall</application>
	во время первой установки FreeBSD.  Будет установлен
	<quote>eBones</quote> (KerberosIV) или <quote>Heimdal</quote>
	(Kerberos5) вариант Kerberos.  Включение этих реализаций объясняется
	тем, что они разработаны вне США/Канады и доступны вне этих стран,
	поскольку на них не влияют ограничения на экспорт криптографического
	кода из США.</para>

      <para>Кроме того, реализация MIT Kerberos доступна из коллекции портов
	в виде пакета
	<filename role="package">security/krb5</filename>.</para>
    </sect2>

    <sect2>
      <title>Создание базы данных</title>

      <para>Это необходимо сделать только на сервере Kerberos.  Во-первых,
	убедитесь что не осталось старой базы данных Kerberos.  Войдите
	в каталог <filename>/etc/kerberosIV</filename> и убедитесь, что в нем
	находятся только эти файлы:</para>

      <screen>&prompt.root; <userinput>cd /etc/kerberosIV</userinput>
&prompt.root; <userinput>ls</userinput>
README		krb.conf        krb.realms</screen>

      <para>Если присутствуют еще какие-то файлы (такие как
	<filename>principal.*</filename> или <filename>master_key</filename>),
	используйте команду <command>kdb_destroy</command> для удаления старой
	базы данных Kerberos, или, если Kerberos не запущен, просто удалите
	эти файлы.</para>

      <para>Затем отредактируйте файлы <filename>krb.conf</filename> и
	<filename>krb.realms</filename>, введя ваши данные.  В этом примере
	уникальный идентификатор <literal>EXAMPLE.COM</literal>, сервер
	<hostid role="fqdn">grunt.example.com</hostid>.  Отредактируем или
	создадим файл <filename>krb.conf</filename>:</para>

      <screen>&prompt.root; <userinput>cat krb.conf</userinput>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</screen>

      <para>В этом примере другие идентификаторы введены для иллюстрации
	настройки c несколькими хостами.  С целью упрощения
	настройки вы можете не включать их.</para>

      <para>Первая строка содержит идентификатор, под которым работает эта
	система.  Остальные строки связывают идентификаторы с именами хостов.
	Сначала указывается идентификатор, затем хост под этим
	идентификатором, работающий как <quote>центр распространения
	ключей</quote>.  Слова <literal>admin server</literal> с последующим
	именем хоста означают, что этот хост также является сервером
	администрирования базы данных.  За дальнейшей информацией об этих
	терминах обратитесь к страницам справочника по Kerberos.</para>

      <para>Мы добавили <hostid role="fqdn">grunt.example.com</hostid>
	к идентификатору <literal>EXAMPLE.COM</literal> и кроме того
	сопоставили всем хостам в домене
	<hostid role="domainname">.example.com</hostid> идентификатор
	<literal>EXAMPLE.COM</literal>.  Файл
	<filename>krb.realms</filename> будет выглядеть так:</para>

      <screen>&prompt.root; <userinput>cat krb.realms</userinput>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</screen>

      <para>Как и в предыдущем примере, другие идентификаторы добавлены только
	для примера.  С целью упрощения настройки вы можете не включать
	их.</para>

      <para>В первой строке <emphasis>определенная</emphasis> система
	сопоставляется с идентификатором.  В остальных строках показано,
	сопоставить идентификатору остальные системы определенного
	поддомена.</para>

      <para>Теперь мы готовы к созданию базы данных.  Потребуется всего лишь
	запустить сервер Kerberos (или центр распространения ключей).
	Используйте для этого <command>kdb_init</command>:</para>

      <screen>&prompt.root; <userinput>kdb_init</userinput>
<prompt>Realm name [default  ATHENA.MIT.EDU ]:</prompt> <userinput>EXAMPLE.COM</userinput>
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.
		
<prompt>Введите главный ключ Kerberos:</prompt> </screen>

      <para>Теперь мы должны сохранить ключ, чтобы сервера на локальных
	компьютерах могли его взять.  Используйте для этого команду
	<command>kstash</command>:</para>
	
      <screen>&prompt.root; <userinput>kstash</userinput>

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!</screen>
	
      <para>Этой командой зашифрованный главный пароль сохранен в
	<filename>/etc/kerberosIV/master_key</filename>.</para>
    </sect2>

    <sect2>
      <title>Запуск Kerberos</title>
	
      <indexterm>
	<primary>KerberosIV</primary>
	<secondary>первый запуск</secondary>
      </indexterm>

      <para>Для каждой системы, защищаемой Kerberos, в базу данных должны
	быть добавлены две записи.  Это <literal>kpasswd</literal> и
	<literal>rcmd</literal>.  Они добавляются вместе с именем
	системы.</para>

      <para>Эти даемоны, <application>kpasswd</application> и
	<application>rcmd</application> позволяют другим системам изменять
	пароли Kerberos и запускать такие команды как &man.rcp.1;,
	&man.rlogin.1;, &man.rsh.1;.</para>

      <para>Теперь добавим эти записи:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>passwd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: passwd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- enter RANDOM here
Verifying password

<prompt>New Password:</prompt> &lt;---- enter RANDOM here

<prompt>Random password [y] ?</prompt> <userinput>y</userinput>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt> <userinput>rcmd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt>

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>		&lt;---- enter RANDOM here
Verifying password

<prompt>New Password:</prompt>           &lt;---- enter RANDOM here

<prompt>Random password [y] ?</prompt>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>         &lt;---- null entry here will cause an exit</screen>
    </sect2>

    <sect2>
      <title>Создание файла настройки сервера</title>

      <para>Теперь необходимо создать все записи сервисов, которые были
	определены для каждого компьютера.  Используем для этого команду
	<command>ext_srvtab</command>.  Будет создан файл, который должен
	быть скопирован или перемещен <emphasis>безопасным способом</emphasis>
	в каталог <filename>/etc/kerberosIV</filename> каждого Kerberos
	клиента.  Этот файл должен присутствовать на каждом сервере и
	клиенте, он необходим для работы Kerberos.</para>

      <screen>&prompt.root; <userinput>ext_srvtab grunt</userinput>
<prompt>Enter Kerberos master key:</prompt>
		
Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating 'grunt-new-srvtab'....</screen>

      <para>Эта команда создаст временный файл, который должен быть
	переименован в <filename>srvtab</filename>, чтобы серверы смогли
	обратиться к нему.  Используйте команду &man.mv.1; для перемещения
	его в исходной системе:</para>

      <screen>&prompt.root; <userinput>mv grunt-new-srvtab srvtab</userinput></screen>

      <para>Если файл предназначен для клиентской системы, и сеть не
	безопасна, скопируйте
	<filename><replaceable>client</replaceable>-new-srvtab</filename>
	на съемный носитель и перенесите файл с его помощью.  Убедитесь, что
	переименовали его в <filename>srvtab</filename> в каталоге
	<filename>/etc/kerberosIV</filename> клиента, и что режим доступа к
	нему 600:</para>

      <screen>&prompt.root; <userinput>mv grumble-new-srvtab srvtab</userinput>
&prompt.root; <userinput>chmod 600 srvtab</userinput></screen>
    </sect2>

    <sect2>
      <title>Пополнение базы данных</title>

      <para>Теперь необходимо добавить в базу данных пользователей.
	Во-первых, создадим запись для пользователя <username>jane</username>.
	Используйте команду <command>kdb_edit</command>:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: jane, Instance: , kdc_key_ver: 1
<prompt>New Password:</prompt>                &lt;---- enter a secure password here
Verifying password

<prompt>New Password:</prompt>                &lt;---- re-enter the password here
Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		   &lt;---- null entry here will cause an exit</screen>
    </sect2>

    <sect2>
      <title>Тестирование всей системы</title>

      <para>Во-первых, запустите даемоны Kerberos.  При правильном
	редактировании файла <filename>/etc/rc.conf</filename> они запустятся
	автоматически при перезагрузке.  Это необходимо только на сервере
	Kerberos.  Клиенты Kerberos получат все необходимые данные из
	каталога <filename>/etc/kerberosIV</filename>.</para>

      <screen>&prompt.root; <userinput>kerberos &amp;</userinput>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
&prompt.root; <userinput>kadmind -n &amp;</userinput>
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>Теперь для получения доступа через созданного пользователя
	<username>jane</username> используйте <command>kinit</command>:</para>

      <screen>&prompt.user; <userinput>kinit jane</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane"
<prompt>Password:</prompt> </screen>

      <para>Попробуйте просмотреть имеющиеся данные с помощью
	<command>klist</command>:</para>

      <screen>&prompt.user; <userinput>klist</userinput>
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>

      <para>Теперь попробуйте изменить пароль с помощью &man.passwd.1;,
	чтобы убедиться, что даемон <application>kpasswd</application>
	может получить информацию из базы данных Kerberos:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
realm EXAMPLE.COM
<prompt>Old password for jane:</prompt>
<prompt>New Password for jane:</prompt>
Verifying password
<prompt>New Password for jane:</prompt>
Password changed.</screen>
    </sect2>

    <sect2>
      <title>Включение <command>su</command></title>

      <para>Kerberos позволяет назначить <emphasis>каждому</emphasis>
	пользователю, который нуждается в привилегиях
	<username>root</username>, свой <emphasis>собственный</emphasis>
	пароль &man.su.1;.  Необходимо добавить учетную запись, которой
	разрешено получать <username>root</username> доступ через &man.su.1;.
	Это делается путем связывания учетной записи <username>root</username>
	с пользовательской учетной записью.  Создадим в базе данных Kerberos
	запись <literal>jane.root</literal> с помощью
	<command>kdb_edit</command>:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt> <userinput>root</userinput>

&lt;Not found&gt;, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- enter a SECURE password here
Verifying password

<prompt>New Password:</prompt>    	 	 &lt;---- re-enter the password here

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt> <userinput>12</userinput> &lt;--- Keep this short!
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		         &lt;---- null entry here will cause an exit</screen>

      <para>Теперь проверим работоспособность этой записи:</para>

      <screen>&prompt.root; <userinput>kinit jane.root</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane.root"
<prompt>Password:</prompt></screen>

      <para>Необходимо добавить пользователя к <username>root</username>
	файлу <filename>.klogin</filename>:</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>Теперь попробуйте выполнить &man.su.1;:</para>

      <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt></screen>

      <para>и посмотрите на имеющиеся данные:</para>

      <screen>&prompt.root; <userinput>klist</userinput>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>
    </sect2>

    <sect2>
      <title>Использование других команд</title>

      <para>В примере выше мы создали запись (principal)
	<literal>jane</literal> с доступом к <literal>root</literal>
	(instance).  Она основана на пользователе с таким же именем, как
	и идентификатор, что принято Kerberos по умолчанию;
	<literal>&lt;principal&gt;.&lt;instance&gt;</literal> в форме
	<literal>&lt;username&gt;.</literal><username>root</username>
	позволяет использовать &man.su.1; для доступа к
	<username>root</username>, если соответствующие записи находятся
	в файле <filename>.klogin</filename> домашнего каталога
	<username>root</username>:

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>Подобно этому, если в файле <filename>.klogin</filename>
	из домашнего каталога пользователя есть строки в форме:</para>

      <screen>&prompt.user; <userinput>cat ~/.klogin</userinput>
jane@EXAMPLE.COM
jack@EXAMPLE.COM</screen>

      <para>это позволит любому с идентификатором
	<literal>EXAMPLE.COM</literal>, кто аутентифицировался как
	<username>jane</username> или <username>jack</username>
	(с помощью команды <command>kinit</command>, см. выше)
	получить доступ к учетной пользователя <username>jane</username>
	или файлам этой системы (<hostid>grunt</hostid>) через
	&man.rlogin.1;, &man.rsh.1; или &man.rcp.1;.</para>

      <para>Например, <username>jane</username> может входить в другую систему
	используя Kerberos:</para>

	    <screen>&prompt.user; <userinput>kinit</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
&prompt.user; <userinput>rlogin grunt</userinput>
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>

      <para>Или <username>jack</username> входит в учетную запись
	<username>jane</username>'s на этом же компьютере
	(файл <filename>.klogin</filename> <username>jane</username>
	настроен как показано выше, и в Kerberos настроена учетная
	запись <emphasis>jack</emphasis>):</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
&prompt.user; <userinput>rlogin grunt -l jane</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
    </sect2>
  </sect1>

  <sect1 id="kerberos5">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tillman</firstname>
	  <surname>Hodgson</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Murray</surname>
	  <contrib>Оригинальный материал предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>Kerberos5</application></title>

    <para>Все релизы &os; после &os;-5.1 включают поддержку только
      <application>Kerberos5</application>.  Таким образом,
      <application>Kerberos5</application> это единственная включаемая в
      поставку версия и его конфигурация похожа на
      <application>KerberosIV</application> во многих аспектах.  Эта
      информация применима только к <application>Kerberos5</application>
      из релизов после &os;-5.0.  Пользователи, желающие использовать
      пакет <application>KerberosIV</application>, могут установить его из
      порта <filename role="package">security/krb4</filename>.</para>

    <para><application>Kerberos</application> это дополнительная сетевая
      система/протокол, позволяющая пользователям авторизоваться через
      защищенные сервисы на защищенном сервере.  Такие сервисы как
      удаленный вход, удаленное копирование, защищенное копирование файлов
      между системами и другие задачи с высоким риском становятся
      допустимо безопасными и более контролируемыми.</para>

    <para><application>Kerberos</application> может быть описана как
      прокси система идентификации-проверки.  Она также может быть описана
      как защищенная внешняя система аутентификации.
      <application>Kerberos</application> предоставляет только одну функцию
      &mdash; защищенную аутентификацию пользователей сети.  Он не предоставляет
      Он не предоставляет функций авторизации (что разрешено делать
      пользователям) или функций аудита (какой пользователь что делает).
      После того, как клиент и сервер использовали
      <application>Kerberos</application> для идентификации, они могут
      зашифровать все соединения для гарантирования собственной безопасности и
      целостности данных.<!--as they go about their business--></para>

    <para>Следовательно крайне рекомендуется использовать
      <application>Kerberos</application> с другими методами безопасности,
      предоставляющими сервисы авторизации и аудита.</para>

    <para>Последующие инструкции могут использоваться в качестве руководства
      по настройке <application>Kerberos</application>, поставляемого с &os;.
      Тем не менее, вам потребуется обратиться к соответствующим страницам
      справочника за полным описанием.</para>

    <para>В целях демонстрации установки <application>Kerberos</application>,
      будут применены следующие обозначения:</para>

    <itemizedlist>
      <listitem>
	<para><acronym>DNS</acronym> домен (<quote>зона</quote>)
	  example.org.</para>
      </listitem>

      <listitem>
	<para>Уникальный идентификатор <application>Kerberos</application>
	  EXAMPLE.ORG.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Используйте действующие имена доменов при настройке
	<application>Kerberos</application> даже если вы будете использовать
	его во внутренней сети.  Это позволит избежать проблем с
	<acronym>DNS</acronym> и гарантирует возможность связи с
	<application>Kerberos</application> под другими
	идентификаторами.</para>
    </note>

    <sect2>
      <title>История</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>история</secondary>
      </indexterm>

      <para><application>Kerberos</application> был создан
	<acronym>MIT</acronym> в качестве решения проблем с безопасностью
	сети.  Протокол <application>Kerberos</application> использует
	стойкую криптографию, так что клиент может идентифицироваться на
	сервере (и обратно) через незащищенное сетевое соединение.</para>

      <para><application>Kerberos</application> это и имя сетевого протокола
	аутентификации и общий термин для описания программ, где он
	реализован (например, <application>Kerberos</application> telnet).
	Текущая версия протокола 5 описана в
	<acronym>RFC</acronym>&nbsp;1510.</para>

      <para>Доступно несколько свободных реализаций этого протокола,
	работающих на множестве операционных систем.  Massachusetts
	Institute of Technology (<acronym>MIT</acronym>), где
	<application>Kerberos</application> был первоначально разработан,
	продолжает разрабатывать собственный пакет
	<application>Kerberos</application>.  Он обычно использовался
	в <acronym>США</acronym> как криптографический продукт,
	и в этом качестве попадал под действие ограничений на экспорт.
	<acronym>MIT</acronym> <application>Kerberos</application>
	доступен в виде порта (<filename
	role="package">security/krb5</filename>).  Heimdal
	<application>Kerberos</application> это другая реализация версии
	5, которая разрабатывалась исключительно вне <acronym>США</acronym>
	для обхода экспортных ограничений (и поэтому часто включалась в
	некоммерческие реализации &unix;).  Heimdal
	<application>Kerberos</application> доступен в виде порта
	(<filename role="package">security/heimdal</filename>),
	его минимальный комплект включен в базовую установку &os;.</para>

    <para>В целях получения наибольшей аудитории, в этих инструкциях
	предполагается использование Heimdal включаемого в &os;.</para>

    </sect2>

    <sect2>
      <title>Настройка Heimdal <acronym>KDC</acronym></title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>настройка центра распространения ключей</secondary>
      </indexterm>

      <para>Центр распространения ключей (Key Distribution Center,
	<acronym>KDC</acronym>) это централизованный сервис аутентификации,
	предоставляемый <application>Kerberos</application> &mdash;
	это компьютер, который предоставляет доступ через
	<application>Kerberos</application>.  <acronym>KDC</acronym>
	считается доверяемым всеми другими компьютерами с определенным
	идентификатором <application>Kerberos</application> и поэтому
	к нему предъявляются высокие требования безопасности.</para>

    <para>Имейте ввиду, что хотя работа сервера
	<application>Kerberos</application> требует очень немного
	вычислительных ресурсов, из соображений безопасности для него
	рекомендуется отдельный компьютер, работающий только в качестве
	<acronym>KDC</acronym>.</para>

    <para>Перед началом настройки <acronym>KDC</acronym>, убедитесь что в
	файле <filename>/etc/rc.conf</filename> содержатся правильные
	настройки для работы в качестве <acronym>KDC</acronym> (вам может
	потребоваться изменить пути в соответствии с собственной
	системой):</para>

    <programlisting>kerberos5_server_enable="YES"
kadmind5_server_enable="YES"
kerberos_stash="YES"</programlisting>

      <note>
	<para>Параметр <option>kerberos_stash</option> существует только в
	  &os; 4.X.</para>
      </note>

      <para>Затем приступим к редактированию файла настройки
	<application>Kerberos</application>,
	<filename>/etc/krb5.conf</filename>:</para>

      <programlisting>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</programlisting>

      <para>Обратите внимание что в файле <filename>/etc/krb5.conf</filename>
	подразумевается наличие у <acronym>KDC</acronym> полного имени
	<hostid role="fqdn">kerberos.example.org</hostid>.  Вам потребуется
	добавить CNAME (синоним) к файлу зоны, если у
	<acronym>KDC</acronym> другое имя.</para>

      <note>
	<para>Для больших сетей с правильно настроенным сервером
	  <acronym>BIND</acronym> <acronym>DNS</acronym> пример выше
	  может быть урезан до:</para>

	<programlisting>[libdefaults]
      default_realm = EXAMPLE.ORG</programlisting>

	<para>Со следующими строками, добавленными в файл зоны
	  <hostid role="fqdn">example.org</hostid>:</para>

	<programlisting>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG.</programlisting></note>

      <para>Создадим теперь базу данных <application>Kerberos</application>.
	Эта база данных содержит ключи всех основных хостов, зашифрованных
	с помощью главного пароля.  Вам не требуется помнить этот пароль,
	он хранится в файле (<filename>/var/heimdal/m-key</filename>).
	Для создания главного ключа запустите <command>kstash</command>
	и введите пароль.</para>

      <para>Как только будет создан главный ключ, вы можете инициализировать
	базу данных с помощью программы <command>kadmin</command> с ключом
	<literal>-l</literal> (означающим <quote>local</quote>).  Этот
	ключ сообщает <command>kadmin</command> обращаться к файлам базы
	данных непосредственно вместо использования сетевого сервиса
	<command>kadmind</command>.  Это помогает решить <quote>проблему
	курицы и яйца</quote>, когда обращение идет к еще не созданной базе
	данных.  Как только вы увидите приглашение <command>kadmin</command>,
	используйте команду <command>init</command> для создания базы
	данных идентификаторов.</para>

      <para>Наконец, оставаясь в приглашении <command>kadmin</command>,
	создайте первую запись с помощью команды <command>add</command>.
	Оставьте неизменными параметры по умолчанию, вы всегда сможете
	изменить их позже с помощью команды <command>modify</command>.
	Обратите внимание, что вы всегда можете использовать команду
	<literal>?</literal> для просмотра доступных параметров.</para>

      <para>Пример создания базы данных показан ниже:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
Master key: <userinput>xxxxxxxx</userinput>
Verifying password - Master key: <userinput>xxxxxxxx</userinput>

&prompt.root; <userinput>kadmin -l</userinput>
kadmin> <userinput>init EXAMPLE.ORG</userinput>
Realm max ticket life [unlimited]:
kadmin> <userinput>add tillman</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: <userinput>xxxxxxxx</userinput>
Verifying password - Password: <userinput>xxxxxxxx</userinput></screen>

      <para>Теперь пришло время запустить сервисы <acronym>KDC</acronym>.
	Выполните команды <command>/etc/rc.d/kerberos start</command> и
	<command>/etc/rc.d/kadmind start</command> для запуска сервисов.
	Ни один из поддерживающих <application>Kerberos</application>
	даемонов на этот момент запущен не будет, но у вас должна быть
	возможность убедиться в том, что <acronym>KDC</acronym> функционирует
	путем получения списка доступа для пользователя, которого вы только
	что самостоятельно создали из командной строки самого
	<acronym>KDC</acronym>:</para>

      <screen>&prompt.user; <userinput>k5init <replaceable>tillman</replaceable></userinput>
tillman@EXAMPLE.ORG's Password:

&prompt.user; <userinput>k5list</userinput>
Credentials cache: FILE:<filename>/tmp/krb5cc_500</filename>
	Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</screen>

      </sect2>

      <sect2>
	<title>Сервер <application>Kerberos</application> с сервисами
	  Heimdal</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>включение сервисов</secondary>
	</indexterm>

	<para>Для начала нам потребуется копия файла настройки
	  <application>Kerberos</application>,
	  <filename>/etc/krb5.conf</filename>.
	  Просто скопируйте его с <acronym>KDC</acronym> на клиентский
	  компьютер безопасным способом (используя сетевые утилиты, такие
	  как &man.scp.1;, или физически, с помощью дискеты).</para>

	<para>Затем вам понадобится файл <filename>/etc/krb5.keytab</filename>.
	  Это основное различие между сервером, поддерживающим
	  <application>Kerberos</application> и рабочими станциями &mdash;
	  на сервере должен быть файл <filename>keytab</filename>.
	  В этом файле находится центральный ключ сервера, который позволяет
	  <acronym>KDC</acronym> проверять все другие идентификаторы.  Он
	  должен быть помещен на сервер безопасным способом, поскольку
	  безопасность сервера может быть нарушена, если ключ станет
	  общедоступен.  Это означает, что его передача через незашифрованный
	  канал, такой как <acronym>FTP</acronym> &mdash; очень плохая
	  идея.</para>

	<para>Обычно перенос файла <filename>keytab</filename> на сервер
	  производится с помощью программы <command>kadmin</command>.
	  Это удобно, поскольку вам потребуется также создать запись хоста
	  (<acronym>KDC</acronym> часть <filename>krb5.keytab</filename>)
	  с помощью <command>kadmin</command>.</para>

	<para>Обратите внимание, что должны быть уже зарегистрированы в
	  системе и необходимо наличие прав на использование интерфейса
	  <command>kadmin</command> в файле <filename>kadmind.acl</filename>.
	  Обратитесь к разделу <quote>Remote administration</quote> в info
	  страницах Heimdal (<command>info heimdal</command>) за деталями по
	  составлению списка доступа.  Если вы не хотите включать удаленный
	  доступ <command>kadmin</command>, можете просто подключиться к
	  <acronym>KDC</acronym> через защищенное соединение (локальную
	  консоль, &man.ssh.1; или <application>Kerberos</application>
	  &man.telnet.1;) и выполнять администрирование локально с помощью
	  <command>kadmin -l</command>.</para>

	<para>После добавления файла <filename>/etc/krb5.conf</filename>,
	  вы можете использовать <command>kadmin</command> с сервера
	  <application>Kerberos</application>.  Команда
	  <command>add --random-key</command> позволит вам добавить запись
	  для сервера, а команда <command>ext</command> позволит перенести
	  эту запись в собственный keytab файл сервера. Например:</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> add --random-key host/myserver.example.org</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin><userinput> ext host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

	<para>Обратите внимание, что команда <command>ext</command>
	  (сокращение от <quote>extract</quote>) сохраняет полученный ключ в
	  файле <filename>/etc/krb5.keytab</filename> по умолчанию.</para>

	<para>Если на <acronym>KDC</acronym> не запущен
	  <command>kadmind</command> (возможно по соображениям безопасности)
	  и вы не можете получить доступ к <command>kadmin</command>
	  удаленно, возможно добавление записи хоста
	  (<username>host/myserver.EXAMPLE.ORG</username>) непосредственно
	  на <acronym>KDC</acronym> с последующим извлечением ее во временный
	  файл (и перезаписью <filename>/etc/krb5.keytab</filename> на
	  <acronym>KDC</acronym>) примерно так:</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> ext --keytab=/tmp/example.keytab host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

	<para>Затем вы можете скопировать keytab на сервер защищенным способом
	  (например, используя <command>scp</command> или дискету).
	  Убедитесь, что используемое имя keytab не совпадает с именем
	  по умолчанию во избежание перезаписывания  keytab на
	  <acronym>KDC</acronym>.</para>

	<para>Теперь ваш сервер может связываться с <acronym>KDC</acronym>
	  (добавлен файл <filename>krb5.conf</filename>) и идентифицировать
	  себя (добавлен файл <filename>krb5.keytab</filename>).  Теперь вы
	  готовы к включению некоторых сервисов
	  <application>Kerberos</application>.  В этом примере мы включим
	  сервис <command>telnet</command>, поместив в
	  <filename>/etc/inetd.conf</filename> нижеприведенную строку и
	  перезапустив сервис &man.inetd.8; командой
	  <command>/etc/rc.d/inetd restart</command>:</para>

	<programlisting>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</programlisting>

	<para>Очень важно установить ключ <command>-a</command> (тип
	  аутентификации) в user.  Обратитесь к странице справочника
	  &man.telnetd.8; за подробной информацией.</para>

      </sect2>

      <sect2>
	<title>Клиент <application>Kerberos</application> с Heimdal</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>настройка клиента</secondary>
	</indexterm>

	<para>Настройка клиентского компьютера почти тривиально проста.
	  Как только настройка <application>Kerberos</application> закончена,
	  вам потребуется только файл настройки
	  <application>Kerberos</application>,
	  <filename>/etc/krb5.conf</filename>.  Просто скопируйте его
	  безопасным способом на клиентский компьютер с
	  <acronym>KDC</acronym>.</para>

	<para>Протестируйте клиентский компьютер, попытавшись использовать
	  <command>kinit</command>, <command>klist</command>, и
	  <command>kdestroy</command> для получения, отображения и удаления
	  списка доступа.  Соединитесь с <application>Kerberos</application>
	  севером используя клиент <application>Kerberos</application>, если
	  соединение не работает и получение доступа является проблемой,
	  это скорее всего проблема сервера, а не клиента или
	  <acronym>KDC</acronym>.</para>

	<para>При тестировании приложения вроде <command>telnet</command>,
	  попробуйте использовать программу перехвата пакетов (такую
	  как &man.tcpdump.1;), чтобы убедиться, что ваш пароль не передается
	  незашифрованным.  Попробуйте использовать <command>telnet</command>
	  с параметром <literal>-x</literal>, чтобы зашифровать весь поток
	  данных (подобно <command>ssh</command>).</para>

	<para>Основные клиентские приложения
	  <application>Kerberos</application> (традиционно называющиеся
	  <command>kinit</command>, <command>klist</command>,
	  <command>kdestroy</command>, и
	  <command>kpasswd</command>) находятся в базовой установке &os;.
	  Обратите внимание, что в &os; версий до 5.0 они были переименованы
	  в <command>k5init</command>, <command>k5list</command>,
	  <command>k5destroy</command>, <command>k5passwd</command>, и
	  <command>k5stash</command> (хотя их обычно использовали лишь
	  однократно).</para>

	<para>Различные неосновные клиентские приложения
	  <application>Kerberos</application> также устанавливаются по
	  умолчанию.  Здесь проявляется <quote>минимальность</quote>
	  базовой установки Heimdal: <command>telnet</command> это
	  единственное приложение, поддерживающее
	  <application>Kerberos</application>.</para>

	<para>Порт Heimdal добавляет некоторые отсутствующие клиентские
	  приложения: поддерживающие
	  <application>Kerberos</application> версии
	  <command>ftp</command>, <command>rsh</command>,
	  <command>rcp</command>, <command>rlogin</command>, и некоторые
	  другие реже используемые программы.  Порт <acronym>MIT</acronym>
	  также содержит полный пакет клиентских приложений
	  <application>Kerberos</application>.</para>

      </sect2>

      <sect2>
	<title>Пользовательские файлы настройки: <filename>.k5login</filename>
	  и <filename>.k5users</filename></title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>пользовательские файлы настройки</secondary>
	</indexterm>

	<para>Учетные записи пользователя в
	  <application>Kerberos</application> (например
	  <username>tillman@EXAMPLE.ORG</username>) обычно связаны с
	  локальными учетными записями (например с локальной учетной записью6
	  <username>tillman</username>).  Клиентские приложения, такие как
	  <command>telnet</command>, обычно не требуют указания имени
	  пользователя или учетной записи.</para>

	<para>Тем не менее, время от времени вам может потребоваться дать
	  доступ к локальной учетной записи кому-то, у кого нет
	  соответствующей учетной записи <application>Kerberos</application>.
	  Например, пользователю <username>tillman@EXAMPLE.ORG</username>
	  может потребоваться доступ к локальной учетной записи
	  <username>webdevelopers</username>.  Другим учетным записям
	  также может потребоваться доступ к этой локальной учетной
	  записи.</para>

	<para>Файлы <filename>.k5login</filename> и
	  <filename>.k5users</filename>, помещенные в домашний каталог
	  пользователя, могут быть использованы подобно действенной
	  комбинации <filename>.hosts</filename> и
	  <filename>.rhosts</filename> для решения этой проблемы.
	  Например, файл <filename>.k5login</filename>
	  со следующим содержанием:</para>

	<screen>tillman@example.org
jdoe@example.org</screen>

	<para>помещен в домашний каталог локального пользователя
	  <username>webdevelopers</username>, то обе упомянутые учетные
	  записи получат доступ к этой учетной записи без необходимости
	  наличия общего пароля.</para>

	<para>Рекомендуется прочитать страницу справочника по этим командам.
	  Обратите внимание, что страница справочника о
	  <command>ksu</command> содержит информацию по
	  <filename>.k5users</filename>.</para>

      </sect2>

      <sect2>
	<title>Подсказки, советы и решение проблем с
	  <application>Kerberos</application></title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>решение проблем</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para>При использовании портов как Heimdal так и
	      <acronym>MIT</acronym> <application>Kerberos</application>
	      убедитесь, что в <envar>PATH</envar> версии
	      <application>Kerberos</application> клиентов указаны перед
	      их версиями в базовой системе.</para>
	  </listitem>

	  <listitem>
	    <para>Все ли компьютеры в пределах данного realm
	      синхронизированы по времени?  Если нет, аутентификация может
	      завершиться неудачно.  <xref linkend="network-ntp"> описывает
	      как синхронизировать часы с использованием
	      <acronym>NTP</acronym>.</para>
	  </listitem>

	  <listitem>
	    <para><acronym>MIT</acronym> и Heimdal успешно взаимодействуют.
	      За исключением <command>kadmin</command>, протокол для которого
	      не стандартизован.</para>
	  </listitem>

	  <listitem
	    <para>Если вы изменяете hostname, потребуется также изменить
	      учетную запись <username>host/</username> и обновить keytab.
	      Это также необходимо для специальных записей в keytab, таких
	      как <username>www/</username> запись модуля Apache
	      <filename role="package">www/mod_auth_kerb</filename>.</para>
	  </listitem>

	  <listitem>
	    <para>Все хосты под общим идентификатором должны разрешаться
	      <acronym>DNS</acronym> (прямое и обратное разрешение), или
	      как минимум через <filename>/etc/hosts</filename>. Записи
	      CNAME будут работать, но записи A и PTR должны быть корректны
	      и находиться на своем месте.  Сообщение об ошибке не всегда
	      интуитивно понятно:
	      <errorname>Kerberos5 refuses authentication because Read req
	      failed: Key table entry not found</errorname>.</para>
	  </listitem>

	  <listitem>
	    <para>Некоторые операционные системы, способные работать в качестве
	      клиентов <acronym>KDC</acronym> не устанавливают права
	      для <command>ksu</command> в setuid <username>root</username>.
	      Это означает, что <command>ksu</command> не работает, что хорошо
	      является хорошей идеей для безопасности, но неудобно.  Это не
	      ошибка <acronym>KDC</acronym>.</para>
	  </listitem>

	  <listitem>
	    <para>С <acronym>MIT</acronym>
	      <application>Kerberos</application>, если вы хотите продлить
	      действие доступа до значения большего, чем десять часов по
	      умолчанию, используйте команду
	      <command>modify_principal</command> в
	      <command>kadmin</command> для изменения maxlife доступа к самой
	      учетной записи и к учетной записи <username>krbtgt</username>.
	      Затем возможно использование <command>kinit</command>
	      с параметром <literal>-l</literal> для запроса доступа с большим
	      временем действия.</para>
	  </listitem>

	  <listitem>
	    <note><para>Если вы запускаете перехватчик пакетов на
	      <acronym>KDC</acronym> для разрешения проблем, а затем
	      запускаете <command>kinit</command> с рабочей станции, то
	      увидите, что <acronym>TGT</acronym> посылается непосредственно
	      при запуске <command>kinit</command> &mdash; даже до того, как
	      вы введете пароль!  Объяснение в том, что сервер
	      <application>Kerberos</application> свободно распространяет
	      <acronym>TGT</acronym> (Ticket Granting Ticket) на каждый
	      неавторизованный запрос; однако, каждый <acronym>TGT</acronym>
	      зашифрован ключом, полученным из пароля пользователя.
	      Следовательно, когда пользователь вводит свой пароль, он не
	      отправляется на <acronym>KDC</acronym>, а используется для
	      расшифровка <acronym>TGT</acronym>, который уже получен
	      <command>kinit</command>.  Если в процессе расшифровки
	      получается правильный билет с правильным значением времени,
	      у пользователя есть действующее <quote>удостоверение</quote>.
	      Это удостоверение содержит ключ сессии для установления
	      безопасного соединения с сервером
	      <application>Kerberos</application>, как и действующий
	      <acronym>TGT</acronym>, зашифрованный ключом сервера
	      <application>Kerberos</application>.  Второй уровень шифрования
	      недоступен пользователю, но позволяет серверу
	      <application>Kerberos</application> проверять правильность
	      каждого <acronym>TGT</acronym>.</para></note>
	  </listitem>

	  <listitem>
	    <para>Если вы хотите установить большое время жизни доступа
	      (например, неделю), и используете
	      <application>OpenSSH</application> для соединения с компьютером,
	      где хранится <quote>билет</quote>, убедитесь, что параметр
	      <application>Kerberos</application>
	      <option>TicketCleanup</option> установлен в
	      <literal>no</literal> в файле <filename>sshd_config</filename>,
	      или билеты будут уничтожены при выходе из сеанса.</para>
	  </listitem>

	  <listitem>
	    <para>Запомните, что время жизни билетов хостов больше.
	      Если время жизни билета для учетной записи пользователя
	      составляет неделю, а время жизни учетной записи хоста, к
	      которому вы подсоединяетесь девять часов, учетная запись хоста
	      в кэше устареет и кэш билетов будет работать не так, как
	      ожидается.</para>
	  </listitem>

	  <listitem>
	    <para>При настройке файла <filename>krb5.dict</filename> на
	    предотвращение использования определенных плохих паролей
	    (страница справочника для <command>kadmind</command> кратко
	    рассказывает об этом), запомните, что это применимо только
	    к учетным записям, для которых действует политика паролей.
	    Формат файла <filename>krb5.dict</filename> прост: одно слово
	    на строку.  Может помочь создание символической ссылки на
	    <filename>/usr/share/dict/words</filename>.</para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>Отличия от порта <acronym>MIT</acronym></title>

	<para>Основное различие между установками <acronym>MIT</acronym> и
	  Heimdal относится к программе <command>kadmin</command>,
	  которая имеет другой (но эквивалентный) набор команд и
	  использует другой протокол.  Если ваш <acronym>KDC</acronym>
	  работает на <acronym>MIT</acronym>, вы не сможете использовать
	  <command>kadmin</command> для удаленного администрирования
	  <acronym>KDC</acronym> (и наоборот, по этой же причине).</para>

	<para>Опции командной строки клиентов также могут немного отличаться
	  для одинаковых задач.  Рекомендуется следование инструкциям
	  на <acronym>MIT</acronym> <application>Kerberos</application>
	  веб сайте (<ulink url="http://web.mit.edu/Kerberos/www/"></ulink>).
	  Будьте внимательны при определении <envar>PATH</envar>:
	  порт <acronym>MIT</acronym> устанавливается по умолчанию в
	  <filename>/usr/local/</filename>, и если в <envar>PATH</envar>
	  вначале указаны системные каталоги, вместо приложений
	  <acronym>MIT</acronym> могут быть запущены системные
	  приложения.</para>

	<note><para>С портом <acronym>MIT</acronym>
	  <filename role="package">security/krb5</filename>, предоставляемым
	  &os;, убедитесь что файл
	  <filename>/usr/local/share/doc/krb5/README.FreeBSD</filename>
	  установлен портом, если вы хотите понять почему вход через
	  <command>telnetd</command> и <command>klogind</command>
	  иногда происходит так странно.  Наиболее важно, исправление
	  <quote>incorrect permissions on cache file</quote> требует
	  использования бинарного файла <command>login.krb5</command>
	  для аутентификации, чтобы права на переданное удостоверение
	  передавались правильно.</para></note>

      </sect2>

      <sect2>
	<title>Преодоление ограничений, обнаруженных в
	  <application>Kerberos</application></title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>ограничения и недостатки</secondary>
	</indexterm>

	<sect3>
	 <title><application>Kerberos</application> это все или ничего</title>

	  <para>Каждый сервис, работающий в сети, должен быть модифицирован
	    для работы с <application>Kerberos</application> (или другим
	    способом защищен от атак по сети) или удостоверения пользователей
	    могут быть украдены или использованы повторно.  В качестве примера
	    может быть приведено использование
	    <application>Kerberos</application> версий
	    оболочек для удаленной работы (например через
	    <command>rsh</command> и <command>telnet</command>), при
	    наличии <acronym>POP3</acronym> сервера, получающего пароли в
	    незашифрованном виде.</para>

	</sect3>

	<sect3>
	  <title><application>Kerberos</application> предназначен для
	    однопользовательских рабочих станций</title>

	  <para>В многопользовательской среде
	    <application>Kerberos</application> менее безопасен.
	    Это потому, что он хранит билеты в каталоге
	    <filename>/tmp</filename>, которая доступна для чтения всем.
	    Если пользователь работает с несколькими другими пользователями
	    одновременно на одном компьютере (т.е. в многопользовательской
	    среде), возможна кража (копирование) билета другим
	    пользователем.</para>

	  <para>Решить проблему можно с помощью параметра командной
	    строки <literal>-c</literal> или (предпочтительно) с помощью
	    переменной окружения <envar>KRB5CCNAME</envar>, но это делается
	    редко.  Для преодоления ограничения достаточно сохранять билет
	    в домашнем каталоге пользователя и использовать простые
	    ограничения на доступ к файлам.</para>

	</sect3>

	<sect3>
	  <title>От KDC зависит вся система</title>

	  <para>Архитектура системы такова, что <acronym>KDC</acronym> должен
	    быть максимально защищен, поскольку главный пароль базы данных
	    содержится в нем.  На <acronym>KDC</acronym> не должно быть
	    запущено никаких других сервисов и он должен быть защищен
	    физически.  Опасность велика, поскольку
	    <application>Kerberos</application> хранит все пароли
	    зашифрованными одним ключом (<quote>главным</quote> ключом),
	    который хранится в файле на <acronym>KDC</acronym>.</para>

	  <para>Хорошей новостью является то, что кража главного ключа
	    не станет такой проблемой, как может показаться.  Главный ключ
	    используется только для шифрования базы данных
	    <application>Kerberos</application> и в качестве seed для
	    генератора случайных чисел.  Поскольку доступ к
	    <acronym>KDC</acronym> защищен, атакующий мало что сможет сделать
	    с главным ключом.</para>

	  <para>Кроме того, если <acronym>KDC</acronym> станет недоступен
	    (возможно по причине атак DoS или проблем в сети) сетевые сервисы
	    будет невозможно использовать, поскольку аутентификация не
	    может быть выполнена.<!-- recipe for a denial-of-service attack-->
	    Уменьшить последствия можно при наличии нескольких
	    <acronym>KDC</acronym> (один главный и один или несколько
	    резервных) и с аккуратно реализованной резервной аутентификацией
	    (отлично подойдет <acronym>PAM</acronym>).</para>

	</sect3>

	<sect3>
	  <title>Недостатки <application>Kerberos</application></title>

	  <para><application>Kerberos</application> позволяет пользователям,
	    хостам и сервисам производить аутентификацию друг друга.
	    В нем нет механизма аутентификации <acronym>KDC</acronym>
	    для пользователей, хостов или сервисов.  Это означает, что
	    поддельный <command>kinit</command> (например) может записывать
	    все имена пользователей и паролей.  Помочь решить проблему может
	    <filename role="package">security/tripwire</filename> или
	    другой инструмент проверки целостности файловой системы.</para>

	</sect3>
      </sect2>

      <sect2>
	<title>Ресурсы и информация для дальнейшего изучения</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>внешние ресурсы</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	  <para><ulink
	    url="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">
	    <application>Kerberos</application> FAQ</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="http://web.mit.edu/Kerberos/www/dialogue.html">Разработка
	    системы аутентификации: диалог в четырех сценах</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510,
	    <application>Kerberos</application> Network Authentication Service
	    (V5)</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="http://web.mit.edu/Kerberos/www/">Домашняя страница
	    <acronym>MIT</acronym>
	    <application>Kerberos</application></ulink></para>
	</listitem>

	<listitem>
	<para><ulink
	  url="http://www.pdc.kth.se/heimdal/">Домашняя страница
	  Heimdal <application>Kerberos</application></ulink></para>
	</listitem>

	</itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="firewalls">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Gary</firstname>
	  <surname>Palmer</surname>
	  <contrib>Предоставили </contrib>
	</author>
	<author>
	  <firstname>Alex</firstname>
	  <surname>Nash</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>Межсетевые экраны</title>
    <indexterm><primary>firewall</primary></indexterm>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>межсетевые экраны</secondary>
    </indexterm>

    <para>Интерес к межсетевым экранам (брандмауэр, firewall) со стороны людей,
      подключенных к интернет, все возрастает и появились даже приложения
      для локальной сети, предоставляющие повышенный уровень безопасности.
      В этом разделе мы надеемся изложить что такое межсетевые экраны, как
      их использовать, и как использовать возможности, предоставляемые
      ядром FreeBSD для их реализации.</para>

    <note>
      <para>Люди часто думают, что наличие межсетевого экрана между
	внутренней сетью и <quote>Большим плохим интернетом</quote> решит все
	их проблемы безопасности.  Это может помочь, но плохо настроенный
	межсетевой экран представляет более серьезную угрозу безопасности,
	чем его полное отсутствие.  Межсетевой экран добавляет еще один
	уровень безопасности вашим системам, но не может остановить
	проникновение решительно настроенного взломщика в вашу сеть.  Если
	вы снижаете внутреннюю безопасность системы, поскольку верите в
	надежность межсетевого экрана, это существенно упрощает работу
	взломщика.</para>
    </note>

    <sect2>
      <title>Что такое межсетевой экран?</title>

      <para>Есть два четко различающихся типа межсетевых экранов, повседневно
	используемых в современном интернет.  Первый тип правильнее называть
	<emphasis>маршрутизатор с фильтрацией пакетов</emphasis>.  Этот тип
	межсетевого экрана работает на машине, подключенной к нескольким сетям
	и применяет к каждому пакету набор правил, определяющий переправлять
	ли этот пакет или блокировать.  Второй тип, известный как
	<emphasis>прокси сервер</emphasis>, реализован в виде даемонов,
	выполняющих аутентификацию и пересылку пакетов, возможно на
	машине с несколькими сетевыми подключениями, где пересылка
	пакетов в ядре отключена.</para>

      <para>Иногда эти два типа межсетевых экранов используются вместе, так
	что только определенной машине (известной как <emphasis>защитный
	хост (bastion host)</emphasis>) позволено отправлять пакеты через
	фильтрующий маршрутизатор во внутреннюю сеть.  Прокси сервисы работают
	на защитном хосте, что обычно более безопасно, чем обычные механизмы
	аутентификации.</para>

      <para>FreeBSD поставляется с встроенным в ядро фильтром пакетом
	(известным как IPFW), ему будет посвящена оставшаяся часть раздела.
	Прокси серверы могут быть собраны на FreeBSD из программного
	обеспечения сторонних разработчиков, но их слишком много и невозможно
	описать их в этом разделе.</para>

      <sect3 id="firewalls-packet-filters">
	<title>Маршрутизаторы с фильтрацией пакетов</title>

	<para>Маршрутизатор это машина, пересылающая пакеты между двумя или
	  несколькими сетями.  Маршрутизатор с фильтрацией пакетов
	  запрограммирован на сравнение каждого пакета со списком правил
	  перед тем как решить, пересылать его или нет.  Большинство
	  современного программного обеспечения маршрутизации имеет
	  возможности фильтрации, и по умолчанию пересылаются все пакеты.
	  Для включения фильтров, вам потребуется определить набор
	  правил.</para>

	<para>Для определения того, должен ли быть пропущен пакет, межсетевой
	  экран ищет в наборе правило, совпадающее с содержимым заголовков
	  пакета.  Как только совпадение найдено, выполняется действие,
	  присвоенное данному правилу.  Действие может заключаться в
	  отбрасывании пакета, пересылке пакета, или даже в отправлении
	  ICMP сообщения в адрес источника.  Учитывается только первое
	  совпадение, поскольку правила просматриваются в определенном
	  порядке.  Следовательно, список правил можно назвать
	  <quote>цепочкой правил</quote>.</para>

	<para>Критерий отбора пакетов зависит от используемого программного
	  обеспечения, но обычно вы можете определять правила, зависящие от
	  IP адреса источника пакета, IP адреса назначения, номера порта
	  источника пакета, номера порта назначения (для протоколов,
	  поддерживающих порты), или даже от типа пакета (UDP, TCP, ICMP,
	  и т.д.).</para>
      </sect3>

      <sect3 id="firewalls-proxy-servers">
	<title>Прокси серверы</title>

	<para>Прокси серверы это компьютеры, где обычные системные даемоны
	  (<application>telnetd</application>,
	  <application>ftpd</application>, и т.д.) заменены специальными
	  серверами.  Эти серверы называются <emphasis>прокси
	  серверами</emphasis>, поскольку они обычно работают только с
	  входящими соединениями.  Это позволяет запускать (например)
	  <application>telnet</application> прокси сервер на межсетевом
	  экране, и делать возможным вход по <application>telnet</application>
	  на межсетевой экран, прохождение механизма аутентификации,
	  и получение доступа к внутренней сети (аналогично, прокси серверы
	  могут быть использованы для выхода во внешнюю сеть).</para>

	<para>Прокси серверы обычно лучше защищены, чем другие серверы,
	  и зачастую имеют более широкий набор механизмов аутентификации,
	  включая системы <quote>одноразовых</quote> паролей, так что
	  даже если кто-то узнает, какой пароль вы использовали, он не
	  сможет использовать его для получения доступа к системе,
	  поскольку срок действия пароля истекает немедленно после его
	  первого использования.  Поскольку пароль не дает доступа
	  непосредственно к компьютеру, на котором находится прокси-сервер,
	  становится гораздо сложнее установить в систему
	  backdoor.</para>

	<para>Прокси серверы обычно имеют способ дополнительного ограничения
	  доступа, так что только определенные хосты могут получить доступ
	  к серверам.  Большинство также позволяют администратору указывать,
	  пользователей и компьютеры, к которым они могут обращаться.
	  Опять же доступные возможности в основном зависят от используемого
	  программного обеспечения.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Что позволяет делать IPFW?</title>
      <indexterm><primary><command>ipfw</command></primary></indexterm>

      <para>Программное обеспечение IPFW, поставляемое с
	FreeBSD, это система фильтрации и учета пакетов, находящаяся в ядре
	и снабженная пользовательской утилитой настройки, &man.ipfw.8;.
	Вместе они позволяют определять и просматривать правила, используемые
	ядром при маршрутизации.</para>

      <para>IPFW состоит из двух связанных частей.  Межсетевой экран
	осуществляет фильтрацию пакетов.  Часть, занимающаяся учетом
	IP пакетов, отслеживает использование маршрутизатора на основе
	правил подобных тем, что используются в части межсетевого экрана.
	Это позволяет администратору определять, например, объем трафика,
	полученного маршрутизатором от определенного компьютера, или объем
	пересылаемого WWW трафика.</para>

      <para>Благодаря тому, как реализован IPFW, вы можете использовать
	его и на компьютерах, не являющихся маршрутизаторами для фильтрации
	входящих и исходящих соединений.  Это особый случай более общего
	использования IPFW, и в этой ситуации используются те же команды
	и техника.</para>
    </sect2>

    <sect2>
      <title>Включение IPFW в FreeBSD</title>
      <indexterm>
	<primary><command>ipfw</command></primary>
	<secondary>включение</secondary>
      </indexterm>

      <para>Поскольку основная часть системы IPFW находится в ядре,
	вам потребуется добавить один или несколько параметров в файл
	настройки ядра, в зависимости от требуемых возможностей, и пересобрать
	ядро.  Обратитесь к главе о пересборке ядра (<xref
	linkend="kernelconfig">) за подробным описанием этой процедуры.</para>

      <warning>
	<para>Правилом IPFW по умолчанию является <literal>deny ip from any to
	  any</literal>.  Если вы не добавите других правил во время загрузки
	  для разрешения доступа, то <emphasis>заблокируете доступ</emphasis>
	  к серверу с включенным в ядро межсетевым экраном после перезагрузки.
	  Мы предлагаем указать <literal>firewall_type=open</literal> в
	  файле <filename>/etc/rc.conf</filename> при первоначальном
	  добавлении межсетевого экрана, а затем, после тестирования
	  его работоспособности, отредактировать правила в файле
	  <filename>/etc/rc.firewall</filename>.  Дополнительной
	  предосторожностью может быть первоначальная настройка межсетевого
	  экрана с локальной консоли, вместо входа через
	  <application>ssh</application>.  Кроме того, возможна сборка
	  ядра с параметрами <literal>IPFIREWALL</literal> и
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal>.  В этом случае
	  правило IPFW по умолчанию будет изменено на <literal>allow ip from
	  any to any</literal>, что предотвратит возможную блокировку.</para>
      </warning>

      <para>Существует четыре параметра настройки ядра, относящихся к
	IPFW:</para>

      <variablelist>
	<varlistentry>
	  <term><literal>options IPFIREWALL</literal></term>

	  <listitem>
	    <para>Включает в ядро код для фильтрации пакетов.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options IPFIREWALL_VERBOSE</literal></term>

	  <listitem>
	    <para>Включает протоколирование пакетов через &man.syslogd.8;.
	      Без этого параметра, даже если вы укажете в правилах фильтрации
	      протоколировать пакеты, это не сработает.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options IPFIREWALL_VERBOSE_LIMIT=10</literal></term>

	  <listitem>
	    <para>Ограничивает число пакетов, протоколируемых каждым правилом
	      через &man.syslogd.8;.  Вы можете использовать этот параметр
	      если хотите протоколировать работу межсетевого экрана, но не
	      хотите делать возможной DoS атаку путем переполнения
	      syslog.</para>

	    <para>Когда для одного из правил в цепочке достигается
	      определенный параметром предел, протоколирование для этого
	      правила выключается.  Для включения протоколирования,
	      вам потребуется сбросить соответствующий счетчик с помощью
	      утилиты &man.ipfw.8;:</para>

	    <screen>&prompt.root; <userinput>ipfw zero 4500</userinput></screen>
	    <para>где 4500 это номер правила, для которого вы хотите
	      возобновить протоколирование.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options IPFIREWALL_DEFAULT_TO_ACCEPT</literal></term>

	  <listitem>
	    <para>Изменяет правило по умолчанию с <quote>deny</quote> на
	      <quote>allow</quote>.  Это предотвращает возможное блокирование,
	      если ядро загружено с поддержкой <literal>IPFIREWALL</literal>,
	      но межсетевой экран еще не настроен.  Этот параметр также
	      полезен, если вы используете &man.ipfw.8; в качестве средства
	      от определенных проблем по мере их возникновения.  Тем не менее,
	      используйте параметр с осторожностью, поскольку он открывает
	      межсетевой экран и изменяет его поведение.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note><para>Предыдущие версии FreeBSD содержали параметр
	<literal>IPFIREWALL_ACCT</literal>.  Этот параметр устарел, поскольку
	код автоматически включает возможность учета.</para>
      </note>
    </sect2>

    <sect2>
      <title>Настройка IPFW</title>
      <indexterm>
	<primary><command>ipfw</command></primary>
	<secondary>настройка</secondary>
      </indexterm>

      <para>Настройка программного обеспечения IPFW выполняется с помощью
	утилиты &man.ipfw.8;.  Синтаксис этой команды выглядит очень сложным,
	но он становится относительно прост как только вы поймете его
	структуру.</para>

      <para>В настоящее время утилита использует четыре различных категории
	команд: добавление/удаление (addition/deletion), просмотр (listing),
	сброс (flushing) и очистка (clearing).  Добавление/удаление
	используется для создания правил, определяющих как пакеты принимаются,
	отбрасываются и протоколируются.  Просмотр используется для
	определения содержимого набора правил (называемого еще цепочкой) и
	счетчиков пакетов (учет).  Сброс используется для удаления всех
	правил цепочки.  Очистка используется для обнуления одного или
	нескольких счетчиков.</para>

      <sect3>
	<title>Изменение правил IPFW</title>

	<para>Синтаксис этой формы команды такой:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg>-N</arg>
	    <arg choice="plain">команда</arg>
	    <arg>номер</arg>
	    <arg choice="plain">действие</arg>
	    <arg>log</arg>
	    <arg choice="plain">протокол</arg>
	    <arg choice="plain">адреса</arg>
	    <arg>параметры</arg>
	  </cmdsynopsis></para>

	<para>При использовании этой формы команды доступен один
	  флаг:</para>

	<variablelist>
	  <varlistentry>
	    <term>-N</term>

	    <listitem>
	      <para>Разрешение адресов и имен сервисов при отображении.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Задаваемая <emphasis>команда</emphasis> может быть сокращена
	  до более короткой уникальной формы.  Существующие
	  <emphasis>команды</emphasis>:</para>

	<variablelist>
	  <varlistentry>
	    <term>add</term>

	    <listitem>
	      <para>Добавление правила к списку фильтрации/учета</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>delete</term>

	    <listitem>
	      <para>Удаление правила из списка фильтрации/учета</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Предыдущие версии IPFW использовали отдельные записи для
	  фильтрации и учета пакетов.  Современные версии учитывают
	  пакеты для каждого правила.</para>

	<para>Если указано значение <emphasis>номер</emphasis>, оно
	  используется для помещения правила на определенную позицию в
	  цепочке.  Иначе правило помещается в конец цепочки с номером
	  на 100 больше, чем у предыдущего правила (сюда не включается
	  правило по умолчанию с номером 65535).</para>

	<para>С параметром <literal>log</literal> соответствующие правила
	  выводят информацию на системную консоль, если ядро собрано с
	  опцией <literal>IPFIREWALL_VERBOSE</literal>.</para>

	<para>Существующие <emphasis>действия</emphasis>:</para>

	<variablelist>
	  <varlistentry>
	    <term>reject</term>

	    <listitem>
	      <para>Отбросить пакет и отправить в адрес источникаICMP пакет,
		сообщающий о недостижимости хоста или порта.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>allow</term>

	    <listitem>
	      <para>Пропустить пакет как обычно.  (синонимы:
		<literal>pass</literal>, <literal>permit</literal>, и
		<literal>accept</literal>)</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>deny</term>

	    <listitem>
	      <para>Отбросить пакет.  Источнику не выдается ICMP сообщение
		(как если бы пакет вообще не достиг цели).</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>count</term>

	    <listitem>
	      <para>Обновить счетчик пакета, но не применять по отношению к
		нему правила allow/deny.  Поиск продолжится со следующего
		правила в цепочке.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Каждое <emphasis>действие</emphasis> может быть записано в
	  виде более короткого уникального префикса.</para>

	<para>Могут быть определены следующие
	  <emphasis>протоколы</emphasis>:</para>

	<variablelist>
	  <varlistentry>
	    <term>all</term>

	    <listitem>
	      <para>Соответствует всем IP пакетам</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>icmp</term>

	    <listitem>
	      <para>Соответствует ICMP пакетам</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>tcp</term>

	    <listitem>
	      <para>Соответствует TCP пакетам</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>udp</term>

	    <listitem>
	      <para>Соответствует UDP пакетам</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Поле <emphasis>адреса</emphasis> формируется так:</para>

	<cmdsynopsis>
	  <arg choice="plain">источник</arg>
	  <arg choice="plain"><replaceable>адрес/маска</replaceable></arg><arg><replaceable>порт</replaceable></arg>
	  <arg choice="plain">цель</arg>
	  <arg choice="plain"><replaceable>адрес/маска</replaceable></arg><arg><replaceable>порт</replaceable></arg>
	  <arg>via <replaceable>интерфейс</replaceable></arg>
	</cmdsynopsis>

	<para>Вы можете указать <replaceable>port</replaceable> только
	  вместе с <emphasis>протоколами</emphasis>, поддерживающими
	  порты (UDP и TCP).</para>

	<para>Параметр <option>via</option> опционален и может содержать IP
	  адрес или имя домена локального IP интерфейса, или имя интерфейса
	  (например <devicename>ed0</devicename>), он настраивает правило
	  на соответствие только тем пакетам, которые проходят через этот
	  интерфейс.  Номера интерфейсов могут быть заменены на опциональную
	  маску.  Например, <literal>ppp*</literal> будет соответствовать
	  PPP интерфейсам ядра.</para>

	<para>Синтаксис, используемый для указания
	  <replaceable>адреса/маски</replaceable>:

	  <screen><replaceable>адрес</replaceable></screen>

	  или

	  <screen><replaceable>адрес</replaceable>/<replaceable>маска-биты</replaceable></screen>

	  или

	  <screen><replaceable>адрес</replaceable>:<replaceable>маска-шаблон</replaceable></screen>
	</para>

	<para>Вместо IP адреса возможно указание существующего имени хоста.
	  <option><replaceable>маска-биты</replaceable></option> это
	  десятичный номер, указывающий количество бит, которые должны быть
	  установлены в маске адреса.  Например,
	  <hostid role="netmask">192.216.222.1/24</hostid> создаст маску,
	  соответствующую всем адресам подсети класса C (в
	  данном случае, <hostid role="ipaddr">192.216.222</hostid>).
A valid hostname may be specified in place of the IP address.
	  <option><replaceable>маска-шаблон</replaceable></option> это
	  IP, который будет логически перемножен с заданным адресом.
	  Ключевое слово <literal>any</literal> может использоваться для
	  обозначения <quote>любого IP адреса</quote>.</para>

	<para>Номера портов указываются в следующем формате:

	  <cmdsynopsis>
	    <arg choice="plain"><replaceable>порт</replaceable><arg>,<replaceable>порт</replaceable><arg>,<replaceable>порт</replaceable><arg>&hellip;</arg></arg></arg></arg>
	  </cmdsynopsis>

	  для указания одного порта или списка портов, или

	  <cmdsynopsis>
	    <arg choice="plain"><replaceable>порт</replaceable>-<replaceable>порт</replaceable></arg>
	  </cmdsynopsis>

	  для указания диапазона портов.  Вы можете также комбинировать
	  указание одного диапазона со списком портов, но диапазон всегда
	  должен указываться первым.</para>

	<para>Доступные <emphasis>параметры</emphasis>:</para>

	<variablelist>
	  <varlistentry>
	    <term>frag</term>

	    <listitem>
	      <para>Срабатывает, если пакет не является первым пакетом
		дейтаграммы.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>in</term>

	    <listitem>
	      <para>Соответствует входящим пакетам.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>out</term>

	    <listitem>
	      <para>Соответствует исходящим пакетам.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>ipoptions <replaceable>spec</replaceable></term>

	    <listitem>
	      <para>Срабатывает, если заголовок IP содержит перечисленный
		через запятую список параметров, указанных в
		<replaceable>spec</replaceable>.  Поддерживаемые параметры IP:
		<literal>ssrr</literal> (strict source route),
		<literal>lsrr</literal> (loose source route),
		<literal>rr</literal> (record packet route), и
		<literal>ts</literal> (time stamp).  Действие отдельных
		параметров может быть изменено путем указания префикса
		<literal>!</literal>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>established</term>

	    <listitem>
	      <para>Срабатывает, если пакет является частью уже установленного
		TCP соединения (т.е. если установлены биты RST или ACK).
		Вы можете поднять производительность межсетевого экрана,
		поместив правило с <emphasis>established</emphasis> близко
		к началу цепочки.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>setup</term>

	    <listitem>
	      <para>Соответствует, если пакет является попыткой установки
		TCP соединения (установлен бит SYN, а бит ACK не
		установлен).</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>tcpflags <replaceable>флаги</replaceable></term>

	    <listitem>
	      <para>Срабатывает, если заголовок TCP содержит список
		перечисленных через запятую <replaceable>флагов</replaceable>.
		Поддерживаемые флаги:
		<literal>fin</literal>, <literal>syn</literal>,
		<literal>rst</literal>, <literal>psh</literal>,
		<literal>ack</literal>, и <literal>urg</literal>.  Действие
		правил по отдельным флагам может быть изменено указанием
		префикса <literal>!</literal>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>icmptypes <replaceable>типы</replaceable></term>

	    <listitem>
	      <para>Срабатывает, если тип пакета ICMP находится в списке
		<replaceable>типы</replaceable>.  Список может быть указан
		в виде любой комбинации диапазонов и/или отдельных типов,
		разделенных запятыми.  Обычно используемые типы ICMP:
		<literal>0</literal>
		echo reply (ping reply), <literal>3</literal> destination
		unreachable, <literal>5</literal> redirect,
		<literal>8</literal> echo request (ping request), и
		<literal>11</literal> time exceeded (используется для
		обозначения истечения TTL, как с &man.traceroute.8;).</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>Просмотр правил IPFW</title>

	<para>Синтаксис этой формы команды такой:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg>-a</arg>
	    <arg>-c</arg>
	    <arg>-d</arg>
	    <arg>-e</arg>
	    <arg>-t</arg>
	    <arg>-N</arg>
	    <arg>-S</arg>
	    <arg choice="plain">list</arg>
	  </cmdsynopsis></para>

	<para>Для этой формы команды существует семь флагов:</para>

	<variablelist>
	  <varlistentry>
	    <term>-a</term>

	    <listitem>
	      <para>Показывать значения счетчиков.  Этот параметр &mdash;  
		единственный путь для просмотра значений счетчиков.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-c</term>

	    <listitem>
	      <para>Просмотр правил в компактной форме.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-d</term>

	    <listitem>
	      <para>Показывать динамические правила в дополнение к
		статическим.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-e</term>

	    <listitem>
	      <para>Если определен параметр <option>-d</option>, показывать
		также динамические правила с истекшим сроком действия.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-t</term>

	    <listitem>
	      <para>Отображать последнее время срабатывание для каждого
		правила в цепочке.  Этот список несовместим с синтаксисом,
		принимаемым &man.ipfw.8;.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-N</term>

	    <listitem>
	      <para>Попытаться разрешить заданные адреса и имена
		сервисов.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-S</term>

	    <listitem>
	      <para>Отображать набор, к которому принадлежит каждое правило.
		Если этот флаг не указан, заблокированные правила не будут
		отображены.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>Сброс правил IPFW</title>

	<para>Синтаксис для сброса правил:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg choice="plain">flush</arg>
	  </cmdsynopsis></para>

	<para>Все правила в цепочке будут удалены, за исключением правила
	  по умолчанию, устанавливаемого ядром (номер 65535).  Будьте
	  осторожны при сбросе правил; правило, отбрасывающее пакеты по
	  по умолчанию отключит систему от сети, пока разрешающие правила
	  не будут добавлены в цепочку.</para>
      </sect3>

      <sect3>
	<title>Очистка счетчиков пакетов IPFW</title>

	<para>Синтаксис для очистки одного или нескольких счетчиков
	  пакетов:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg choice="plain">zero</arg>
	    <arg choice="opt"><replaceable>index</replaceable></arg>
	  </cmdsynopsis></para>

	<para>При использовании без аргумента <replaceable>номер</replaceable>
	  будут очищены все счетчики пакетов.  Если
	  <replaceable>index</replaceable> указан, операция очистки
	  применяется только к указанному правилу цепочки.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Примеры команд для <application>ipfw</application></title>

      <para>Следующая команда запретит все пакеты с хоста <hostid
	role="fqdn">evil.crackers.org</hostid> на telnet порт хоста
	<hostid role="fqdn">nice.people.org</hostid>:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from evil.crackers.org to nice.people.org 23</userinput></screen>

      <para>Следующий пример запрещает и протоколирует весь TCP трафик из
	сети <hostid role="domainname">crackers.org</hostid> (класса C)
	к компьютеру <hostid role="fqdn">nice.people.org</hostid>
	(на любой порт).</para>

      <screen>&prompt.root; <userinput>ipfw add deny log tcp from evil.crackers.org/24 to nice.people.org</userinput></screen>

      <para>Если вы хотите запретить организацию X сессий в вашу сеть
	(часть сети класса C), следующая команда осуществит необходимую
	фильтрацию:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from any to my.org/28 6000 setup</userinput></screen>

      <para>Для просмотра записей учета:

	<screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

	или в краткой форме

	<screen>&prompt.root; <userinput>ipfw -a l</userinput></screen>
      </para>

      <para>Вы можете также просмотреть время последнего срабатывания правил
	с помощью команды:</para>

      <screen>&prompt.root; <userinput>ipfw -at l</userinput></screen>
    </sect2>

    <sect2>
      <title>Создание межсетевого экрана с фильтрацией пакетов</title>

      <note>
	<para>Следующие рекомендации означают только одно: рекомендации.
	  Требования к каждому межсетевому экрану различаются, и мы не
	  можем рассказать вам, как создать межсетевой экран, отвечающий
	  вашим потребностям.</para>
      </note>

      <para>При первоначальной настройке межсетевого экрана, до тестирования
	производительности и введения сервера в строй, настоятельно
	рекомендуется использовать версии команд с протоколированием и
	включить протоколирование в ядре.  Это позволит вам быстро выявить
	проблемные области и исправить настройку без больших усилий.
	Даже после завершения первоначальной настройки рекомендуется
	использовать протоколирование для `deny', поскольку это позволяет
	отслеживать возможные атаки и изменять правила межсетевого экрана,
	если требования к нему изменятся.</para>
	
      <note>
	<para>Если вы используете версию команды <command>accept</command>
	  с протоколированием, будьте осторожны, поскольку она может
	  создать <emphasis>большой</emphasis> объем протокольных данных.
	  Будет произведено протоколирование каждого пакета, проходящего
	  через межсетевой экран, поэтому большие объемы FTP/http и другого
	  трафика существенно замедлят систему.  Это также увеличит задержку
	  таких пакетов, поскольку ядру требуется выполнить дополнительную
	  работу перед тем, как пропустить пакет.
	  <application>syslogd</application> также будет использовать гораздо
	  больше времени процессора, поскольку он отправит все дополнительные
	  данные на диск, и раздел <filename>/var/log</filename> может быть
	  быстро заполнен.</para>
      </note>

      <para>Вам потребуется включить межсетевой экран в
	<filename>/etc/rc.conf.local</filename> или
	<filename>/etc/rc.conf</filename>.  Соответствующая страница
	справочника разъясняет что именно необходимо сделать и содержит
	примеры готовых настроек.  Если вы не используете предустановленную
	настройку, команда <command>ipfw list</command> может поместить
	текущий набор правил в файл, откуда он может быть помещен в
	стартовые файлы системы.  Если вы не используете
	<filename>/etc/rc.conf.local</filename> или
	<filename>/etc/rc.conf</filename> для включения межсетевого экрана,
	важно убедиться в том, что он включается после настройки
	интерфейсов.</para>

      <para>Далее необходимо определить, <emphasis>что именно</emphasis>
	делает ваш межсетевой экран!  Это в основном зависит от того,
	насколько широкий доступ вы хотите открыть снаружи к вашей сети.
	Вот несколько общих правил:</para>

      <itemizedlist>
	<listitem>
	  <para>Заблокируйте доступ снаружи к портам TCP с номерами ниже 1024.
	    Здесь расположена большая часть критичных для безопасности
	    сервисов, таких как finger, SMTP (почта) и telnet.</para>
	</listitem>

	<listitem>
	  <para>Заблокируйте <emphasis>весь</emphasis> входящий трафик UDP.
	    Есть очень немного полезных сервисов, работающих через UDP,
	    но они обычно представляют угрозу безопасности (например,
	    Sun RPC и NFS протоколы).  У этого способа есть и недостатки,
	    поскольку протокол UDP не поддерживает соединения, и запрещение
	    входящих пактов заблокирует также ответы на исходящий UDP трафик.
	    <!-- в последующих двух предложениях пример с archie обобщен -->
	    Это может стать проблемой для тех, кто использует внешние серверы,
	    работающие с UDP.  Если вы хотите открыть доступ к этим сервисам,
	    потребуется разрешить входящие пакеты с соответствующих портов.
	    К примеру, для <application>ntp</application> вам может
	    потребоваться разрешить пакеты, приходящие с порта 123.</para>
	</listitem>

	<listitem>
	  <para>Заблокировать весь трафик снаружи к порту 6000.  Порт 6000
	    используется для доступа к серверам X11, и может быть угрозой
	    безопасности (особенно если у пользователей есть привычка
	    выполнять на своих рабочих станциях команду <command>xhost
	    +</command>).  X11 может использовать диапазон портов,
	    начинающийся с 6000, верхний предел определяется количеством
	    X дисплеев, которые могут быть запущены на машине.  Верхний
	    предел, определенный RFC 1700 (Assigned Numbers), равен
	    6063.</para>
	</listitem>

	<listitem>
	  <para>Проверьте порты, используемые внутренними сервисами
	    (например, SQL серверами и т.п.).  Возможно хорошей идеей является
	    блокирование и этих портов, поскольку они обычно не попадают в
	    диапазон 1-1024, указанный выше.</para>
	</listitem>
      </itemizedlist>

      <para>Еще один список для проверки настроек межсетевого экрана доступен
	на CERT по адресу <ulink
	  url="http://www.cert.org/tech_tips/packet_filtering.html"></ulink></para>

      <para>Как сказано выше, все эти правила всего лишь
	<emphasis>руководство</emphasis>.  Вы сами сможете решить, какие
	правила фильтрации будут использованы в межсетевом экране.  Мы не
	можем нести НИКАКОЙ ответственности в случае взлома вашей сети,
	даже если вы следовали советам, представленным выше.</para>
    </sect2>

    <sect2 id="ipfw-overhead">
      <title>Накладные расходы и оптимизация IPFW</title>

      <para>Многие пользователи хотят знать, как сильно IPFW нагружает
	систему.  Ответ в основном зависит от набора правил и скорости
	процессора.  При небольшом наборе правил для большинства приложений,
	работающих в Ethernet ответ <quote>незначительно</quote>.
	Для тех, кому нужен более точный ответ, и предназначен этот
	раздел.</para>

      <para>Последующие измерения были выполнены с 2.2.5-STABLE на
	486-66.  (Хотя IPFW немного изменился в последующих релизах
	FreeBSD, скорость осталась приблизительно той же.) IPFW был
	модифицирован для измерения времени, затраченного
	<literal>ip_fw_chk</literal>, с выводом на консоль результата
	после каждого 1000&ndash;го пакета.</para>

      <para>Были протестированы два набора из 1000 правил.  Первый
	был составлен для демонстрации плохого набора правил путем повторения
	правила:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from any to any 55555</userinput></screen>

      <para>Этот набор правил плох, поскольку большая часть правил IPFW
	не соответствует проверяемым пакетам (из-за номера порта).
	После 999&ndash;й итерации этого правила следует
	правило <literal>allow ip from any to any</literal>.</para>

      <para>Второй набор правил был разработан для быстрейшей проверки
	каждого правила:</para>

      <screen>&prompt.root; <userinput>ipfw add deny ip from 1.2.3.4 to 1.2.3.4</userinput></screen>

      <para>Не совпадающий IP адрес источника в правиле выше приведет к
	очень быстрой проверке этих правил.  Как и прежде, 1000&ndash;е
	правило <literal>allow ip from any to any</literal>.</para>

      <para>Затраты на проверку пакета в первом случае приблизительно
	2.703&nbsp;мс/пакет, или приблизительно 2.7&nbsp;микросекунд на
	правило.  Теоретический предел скорости проверки около
	370&nbsp;пакетов в секунду.  Предполагая подключение через
	10&nbsp;Mbps Ethernet и размер пакета приблизительно 1500&nbsp;байт,
	получаем только 55.5% использования пропускной способности.</para>

      <para>Во втором случае каждый пакет был проверен приблизительно за
	1.172&nbsp;мс, или приблизительно 1.2&nbsp;микросекунд на правило.
	Теоретический предел скорости проверки около 853&nbsp;пакетов в
	секунду, что делает возможным полное использование пропускной
	способности 10&nbsp;Mbps Ethernet.</para>

      <para>Чрезмерное количество проверяемых правил и их вид не позволяет
	составить картину близкую к обычным условиям &mdash; эти правила
	были использованы только для получения информации о времени проверки.
	Вот несколько рекомендаций, которые необходимо учесть для создания
	эффективного набора правил:</para>

      <itemizedlist>
	<listitem>
	  <para>Поместите правило <literal>established</literal> как можно
	    раньше для обработки большей части TCP трафика.  Не помещайте
	    перед ним правила <literal>allow tcp</literal>.</para>
	</listitem>

	<listitem>
	  <para>Помещайте часто используемые правила ближе к началу набора
	    чем редко используемые (конечно же, <emphasis>без изменения
	    действия всего набора</emphasis>).  Вы можете определить
	    наиболее часто используемые правила путем проверки счетчиков
	    пакетов командой <command>ipfw -a l</command>.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="openssl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Написал: </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>OpenSSL</title>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>

    <para>Одной из программ, требующих особого внимания пользователей,
      является набор программ <application>OpenSSL</application>,
      включенный в &os;.  <application>OpenSSL</application> предоставляет
      уровень шифрования поверх обычных уровней соединения; следовательно,
      он может быть использован многими сетевыми приложениями и
      сервисами.</para>

    <para><application>OpenSSL</application> может использоваться для
      шифрования соединений почтовых клиентов, транзакций через интернет,
      например для кредитных карт, и многого другого.  Многие порты,
      такие как <filename role="package">www/apache13-ssl</filename> и
      <filename role="package">mail/sylpheed-claws</filename> собираются
      с <application>OpenSSL</application>.</para>

    <note>
      <para>В большинстве случаев в коллекции портов собирается
	порт <filename role="package">security/openssl</filename>,
	если только переменная <makevar>WITH_OPENSSL_BASE</makevar>
	не установлена явно в <quote>yes</quote>.</para>
    </note>

    <para>Версия <application>OpenSSL</application>, включаемая
      в &os;, поддерживает сетевые протоколы безопасности
      Secure Sockets Layer v2/v3 (SSLv2/SSLv3),
      Transport Layer Security v1 (TLSv1) и может быть использована
      в качестве основной криптографической библиотеки для
      приложений.</para>

    <note>
      <para>Хотя <application>OpenSSL</application> поддерживает алгоритм
	<acronym>IDEA</acronym>, по умолчанию он отключен из-за патентных
	ограничений Соединенных Штатов.  Для его использования необходимо
	ознакомиться с лицензией, и, если ограничения приемлемы,
	установить в <filename>make.conf</filename> переменную
	<makevar>MAKE_IDEA</makevar>.</para>
    </note>

    <para>Возможно наиболее часто <application>OpenSSL</application>
      используется для предоставления сертификатов программным
      пакетам.  Эти сертификаты подтверждают, что данные компании
      или частного лица верны и не подделаны.  Если рассматриваемый
      сертификат не был проверен одним из нескольких Certificate
      Authorities (<acronym>CA</acronym>), обычно выводится
      предупреждение.  Certificate Authority это компания, такая как
      VeriSign, которая подписывает сертификаты для подтверждения
      данных частных лиц или компаний.  Эта процедура не бесплатна
      и не является абсолютно необходимой для использования сертификатов;
      однако может успокоить некоторых особо осторожных
      пользователей.</para>

    <sect2>
      <title>Генерирование сертификатов</title>

      <indexterm>
	<primary>OpenSSL</primary>
	<secondary>генерирование сертификатов</secondary>
      </indexterm>

      <para>Для генерирования сертификатов доступна следующая
	команда:</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.pem</userinput>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (eg, YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:<userinput><replaceable>SOME PASSWORD</replaceable></userinput>
An optional company name []:<userinput><replaceable>Another Name</replaceable></userinput></screen>

      <para>Ввод после приглашения <quote>Common Name</quote>
	содержит имя домена.  Здесь вводится имя сервера для
	верификации; помещение в это поле чего-либо кроме
	этого имени приведет к созданию бесполезного сертификата.
	Доступны и другие параметры, например срок действия,
	альтернативные алгоритмы шифрования и т.д.  Полный список
	находится на странице справочного руководства
	&man.openssl.1;.</para>

      <para>Файл <filename>cert.pem</filename> должен находиться в
	каталоге, из которого была выполнена вышеупомянутая команда.
	Этот сертификат может быть отправлен одному из многих
	<acronym>CA</acronym> для подписи.</para>

      <para>Когда подпись <acronym>CA</acronym> не требуется, может
	быть создан самоподписанный сертификат.  Сначала создайте ключ
	<acronym>CA</acronym>:</para>

      <screen>&prompt.root; <userinput>openssl gendsa -des3 -out \
<filename>myca.key</filename> 1024</userinput></screen>

      <para>Используйте этот ключ при создании сертификата:</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key \
<filename>myca.key</filename> -out <filename>new.crt</filename></userinput></screen>

      <para>В каталоге должно появиться два новых файла: подпись сертификата,
	<filename>myca.key</filename> и сам сертификат,
	<filename>new.crt</filename>.  Они должны быть помещены в каталог,
	доступный для чтения только <username>root</username>,
	желательно внутри <filename role="directory">/etc</filename>.
	Права на каталог можно изменить <command>chmod</command> с параметрами
	0600.</para>
    </sect2>

    <sect2>
      <title>Использование сертификатов, пример</title>

      <para>Итак, что могут сделать эти файлы?  Хорошим применением
	может стать шифрование соединений для
	<application>Sendmail</application> <acronym>MTA</acronym>.
	Это сделает ненужным использование простой текстовой
	аутентификации для тех, кто отправляет почту через
	локальный <acronym>MTA</acronym>.</para>

      <note>
	<para>Это не лучшее из возможных использований, поскольку
	  некоторые <acronym>MUA</acronym> выдадут ошибку, если
	  сертификат не установлен локально.  Обратитесь к
	  поставляемой с программой документации за информацией по
	  установке сертификата.</para>
      </note>

      <para>Следующие строки должны быть помещены в локальный файл
	<filename>.mc</filename>:</para>

      <programlisting>dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl</programlisting>

      <para>Где <filename role="directory">/etc/certs/</filename>
	это каталог для локального хранения сертификата и
	ключей.  После настройки необходимо собрать локальный
	файл <filename>.cf</filename>.  Это легко сделать,
	набрав <command>make</command> <parameter>install</parameter>
	в каталоге <filename role="directory">/etc/mail</filename>.
	Затем выполните команду <command>make</command>
	<parameter>restart</parameter>, которая должна запустить
	даемон <application>Sendmail</application>.</para>

      <para>Если все пройдет нормально, в файле
	<filename>/var/log/maillog</filename> не появятся сообщения
	об ошибках и запустится процесс
	<application>Sendmail</application>.</para>

      <para>Для проведения простого теста подключитесь к почтовому серверу
	программой &man.telnet.1;:</para>

      <screen>&prompt.root; <userinput>telnet <replaceable>example.com</replaceable> 25</userinput>
Trying 192.0.34.166...
Connected to <hostid role="fqdn">example.com</hostid>.
Escape character is '^]'.
220 <hostid role="fqdn">example.com</hostid> ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
<userinput>ehlo <replaceable>example.com</replaceable></userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 <hostid role="fqdn">example.com</hostid> closing connection
Connection closed by foreign host.</screen>

      <para>Если в выводе появилась строка <quote>STARTTLS</quote>,
	все работает правильно.</para>
    </sect2>
  </sect1>

  <sect1 id="ipsec">
    <sect1info>
      <authorgroup>
	<author>
  	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	  <affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
	  </affiliation>
	  <contrib>Написал </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>VPN через IPsec</title>
    <para>Создание VPN между двумя сетями, соединенными через интернет,
      с использованием шлюзов FreeBSD.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Hiten M.</firstname>
	    <surname>Pandya</surname>
	    <affiliation>
	      <address><email>hmp@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>Написал </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Принципы работы IPsec</title>

      <para>Этот раздел послужит вам руководством по настройке IPsec и его
	использованию в среде FreeBSD и <application>&microsoft.windows;
	2000/XP</application>, соединяемых безопасным способом.
	Для настройки IPsec необходимо ознакомиться с процессом
	сборки ядра (<xref linkend="kernelconfig">).</para>

      <para><emphasis>IPsec</emphasis> это протокол, расположенный поверх
	слоя Internet Protocol (IP).  Он позволяет двум или более хостам
	связываться защищенным способом (отсюда и название протокола).
	<quote>Сетевой стек</quote> FreeBSD IPsec основан на
	реализации <ulink url="http://www.kame.net/">KAME</ulink>,
	поддерживающей оба семейства протоколов, IPv4 и IPv6.</para>

      <note>
	<para>FreeBSD 5.X содержит <quote>аппаратно
	поддерживаемый</quote> стек IPsec, известный как <quote>Fast
	IPsec</quote>, заимствованный из OpenBSD.  Для оптимизации
	производительности IPsec он задействует криптографическое
	оборудование (когда оно доступно) через подсистему &man.crypto.4;.
	Это новая подсистема и она не поддерживает всех возможностей,
	доступных в KAME версии IPsec.  Для включения IPsec с аппаратной
	поддержкой необходимо добавить в файл настройки ядра следующий
	параметр:</para>

	<screen>
options	  FAST_IPSEC  # new IPsec (cannot define w/ IPSEC)
	</screen>

	<para>Обратите внимание, что на данный момент невозможно
	  использовать подсистему <quote>Fast IPsec</quote> вместе
	  с KAME реализацией IPsec.  Обратитесь к странице справочника
	  &man.fast.ipsec.4; за дальнейшей информацией.</para>

      </note>

      <para>IPsec состоит из двух субпротоколов:</para>

      <itemizedlist>
	<listitem>
	  <para><emphasis>Encapsulated Security Payload
	    (ESP)</emphasis>, защищающей данные IP пакета от вмешательства
	    третьей стороны путем шифрования содержимого с помощью
	    симметричных криптографических алгоритмов (таких как
	    Blowfish,3DES).</para>
	</listitem>
	<listitem>
	  <para><emphasis>Authentication Header (AH)</emphasis>,
	    защищающий заголовок IP пакета от вмешательства третьей стороны
	    и подделки путем вычисления криптографической контрольной суммы
	    и хеширования полей заголовка IP пакета защищенной функцией
	    хеширования.  К пакету добавляется дополнительный заголовок
	    с хешем, позволяющий аутентификацию информации пакета.</para>
	</listitem>
      </itemizedlist>

      <para><acronym>ESP</acronym> и <acronym>AH</acronym> могут быть
	использованы вместе или по отдельности, в зависимости от
	обстоятельств.</para>

      <para>IPsec может быть использован или для непосредственного шифрования
	трафика между двумя хостами (<emphasis>транспортный
	режим</emphasis>); или для построения <quote>виртуальных
	туннелей</quote> между двумя подсетями, которые могут быть
	использованы для защиты соединений между двумя корпоративными
	сетями (<emphasis>туннельный режим</emphasis>).  Последний обычно
	называют <emphasis>виртуальной частной сетью</emphasis>
	(Virtual Private Network, VPN).  За детальной информацией о
	подсистеме IPsec в FreeBSD обратитесь к странице справочника
	&man.ipsec.4;.</para>

      <para>Для включения поддержки IPsec в ядре, добавьте следующие
	параметры к файлу настройки ядра:</para>

      <screen>
options   IPSEC        #IP security
options   IPSEC_ESP    #IP security (crypto; define w/ IPSEC)
      </screen>

      <para>Если желательна поддержка отладки IPsec, должна быть также
	добавлена следующая строка:</para>

      <screen>
options   IPSEC_DEBUG  #debug for IP security
      </screen>
    </sect2>

    <sect2>
      <title>Проблема</title>

      <para>Не существует стандарта VPN.  Они могут быть реализованы
	множеством различных технологий, каждая из которых имеет свои
	сильные и слабые стороны.  Этот раздел представляет
	сценарий и стратегию реализации VPN для этого сценария.</para>
    </sect2>

    <sect2>
      <title>Сценарий: Две сети, подключенных к интернет, работающие как
	одна</title>

      <para>Исходные условия таковы:</para>

      <itemizedlist>
	<listitem>
	  <para>Существует как минимум две сети</para>
	</listitem>
	<listitem>
	  <para>Внутри обеих сетей используется IP</para>
	</listitem>
	<listitem>
	  <para>Обе сети соединены через интернет через шлюз,
	    работающий на FreeBSD.</para>
	</listitem>
	<listitem>
	  <para>У шлюза каждой из сетей есть как минимум один публичный
	    IP адрес.</para>
	</listitem>
	<listitem>
	  <para>Внутренние IP адреса двух сетей могут быть публичными или
	    приватными, не имеет значения.  На шлюзе может работать
	    NAT, если это необходимо.</para>
	</listitem>
	<listitem>
	  <para>Внутренние IP адреса двух сетей <emphasis>не должны
	    пересекаться</emphasis>.  Хотя вероятно теоретически возможно
	    использование комбинации VPN технологии и NAT для настройки
	    такой конфигурации, эта конфигурация будет кошмарна.</para>
	</listitem>
      </itemizedlist>

      <para>Если две сети, которые вы пытаетесь соединить, используют один
	и тот же диапазон приватных адресов (например, обе используют
	<hostid role="ipaddr">192.168.1.x</hostid>), номера в одной из
	сетей необходимо изменить.</para>

      <para>Топология сети может выглядеть примерно так:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="security/ipsec-network" align="center">
	</imageobject>

	<textobject>
<literallayout class="monospaced">Сеть #1               [ Внутренние хосты ]    Приватная сеть, 192.168.1.2-254
                      [    Win9x/NT/2K   ]
                      [       UNIX       ]
                               |
                               |
                        .---[fxp1]---.        Приватный IP, 192.168.1.1
                        |   FreeBSD  |
                        `---[fxp0]---'        Публичный IP, A.B.C.D
                               |
                               |
                      -=-=- Интернет -=-=-
                               |
                               |
                        .---[fxp0]---.        Публичный IP, W.X.Y.Z
                        |   FreeBSD  |
                        `---[fxp1]---'        Приватный IP, 192.168.2.1
                               |
                               |
Сеть #2               [ Внутренние хосты ]
                      [    Win9x/NT/2K   ]    Приватная сеть, 192.168.2.2-254
                      [       UNIX       ]</literallayout>
	</textobject>
      </mediaobject>

      <para>Здесь два публичных IP адреса.  Для упоминания их в дальнейшем
	будут использоваться буквы.  Если вы увидите эти буквы, замените
	их на свои публичные IP адреса.  Также обратите внимание, что
	у обеих шлюзов внутренний адрес заканчивается на .1 и диапазоны
	приватных адресов двух сетей различны (<hostid
	role="ipaddr">192.168.1.x</hostid> и <hostid
	role="ipaddr">192.168.2.x</hostid> соответственно).  Все компьютеры
	локальных сетей настроены на использование в качестве шлюза по
	умолчанию компьютера с адресом, оканчивающимся на
	<hostid role="ipaddr">.1</hostid>.</para>

      <para>С сетевой точки зрения замысел в том, чтобы каждая сеть
	видела компьютеры из другой сети так, как если бы они были
	непосредственно подключены к тому же самому маршрутизатору &mdash;
	хотя и немного медленному маршрутизатору, иногда теряющему
	пакеты.</para>

      <para>Это означает, что (например) компьютер <hostid
	role="ipaddr">192.168.1.20</hostid> может запустить</para>

      <programlisting>ping 192.168.2.34</programlisting>

      <para>и это будет прозрачно работать.  Компьютеры с &windows;
	должны видеть компьютеры в другой сети, просматривать сетевые
	ресурсы, и так далее, точно так же, как и для компьютеров в
	локальной сети.</para>

      <para>И все это безопасным способом.  Это означает, что трафик
	между сетями зашифрован.</para>

      <para>Создание VPN между этими двумя сетями это многошаговый
	процесс.  Этапы создания VPN таковы:</para>

      <orderedlist>
	<listitem>
	  <para>Создание <quote>виртуального</quote> сетевого подключения
	    между двумя сетями через интернет.  Тестирование подключения с
	    помощью таких инструментов как &man.ping.8;, чтобы убедиться, что
	    оно работает.</para>
	</listitem>

	<listitem>
	  <para>Применение политики безопасности чтобы убедиться, что трафик
	    между двумя сетями прозрачно шифруется и расшифровывается если
	    необходимо.  Тестирование с помощью таких инструментов как
	    &man.tcpdump.1;, чтобы убедиться, что трафик шифруется.</para>
	</listitem>

	<listitem>
	  <para>Настройка дополнительных программ на шлюзах FreeBSD,
	    чтобы компьютеры &windows; из одной сети видели компьютеры
	    в другой через VPN.</para>
	</listitem>
      </orderedlist>

    <sect3>
      <title>Шаг 1: Создание и тестирование <quote>виртуального</quote>
	сетевого подключения</title>

      <para>Предположим, что вы работаете на шлюзе сети #1 (с публичным
	адресом <hostid role="ipaddr">A.B.C.D</hostid>, приватным
	адресом <hostid role="ipaddr">192.168.1.1</hostid>) и запускаете
	<command>ping 192.168.2.1</command>, т.е. на приватный адрес
	машины с IP адресом <hostid role="ipaddr">W.X.Y.Z</hostid>.
	Что должно произойти, чтобы это сработало?</para>

      <orderedlist>
	<listitem>
	  <para>Шлюз должен знать, как достичь <hostid
	    role="ipaddr">192.168.2.1</hostid>.  Другими словами, у него
	    должен быть маршрут к <hostid
	    role="ipaddr">192.168.2.1</hostid>.</para>
	</listitem>
	<listitem>
	  <para>Приватные IP адреса, такие как диапазон <hostid
	    role="ipaddr">192.168.x</hostid> не адресуются в
	    интернет.  Каждый пакет, отправляемый на
	    <hostid role="ipaddr">192.168.2.1</hostid> должен быть
	    <quote>завернут</quote> в другой пакет.  Исходным адресом пакета
	    должен быть <hostid role="ipaddr">A.B.C.D</hostid>,
	    а адресом назначения <hostid role="ipaddr">W.X.Y.Z</hostid>.
	    Этот процесс называется
	    <firstterm>инкапсуляцией</firstterm>.</para>
	</listitem>
	<listitem>
	  <para>Как только этот пакет достигнет <hostid
	    role="ipaddr">W.X.Y.Z</hostid>, необходимо будет
	    <quote>разинкапсулировать</quote> его и доставить к <hostid
	    role="ipaddr">192.168.2.1</hostid>.</para>
	</listitem>
      </orderedlist>

      <para>Как вы можете увидеть, это требует <quote>туннеля</quote>
	между двумя сетями.  Два конца <quote>туннеля</quote>
	это IP адреса <hostid role="ipaddr">A.B.C.D</hostid> и
	<hostid role="ipaddr">W.X.Y.Z</hostid>.  Туннель используется для
	передачи трафика с приватными IP адресами через интернет.</para>

      <para>В FreeBSD этот туннель создается с помощью устройства generic
	interface, или <devicename>gif</devicename>.  Как вы можете
	догадаться, интерфейс <devicename>gif</devicename> на каждом хосте
	должен быть настроен с четырьмя IP адресами; два для публичных
	IP адресов и два для приватных IP адресов.</para>

      <para>В ядро обеих компьютеров FreeBSD должна быть встроена
	поддержка устройства gif.  Вы можете сделать это, добавив
	строку:</para>

      <programlisting>pseudo-device gif</programlisting>

      <para>к файлу настройки ядра на обеих компьютерах, с последующей
	компиляцией, установкой и перезагрузкой.</para>

      <para>Настройка туннеля это двухшаговый процесс.  Во-первых,
	необходимо задать сведения о внешнем (или публичном) IP адресе
	с помощью &man.gifconfig.8;.  Затем о приватном IP адресе
	с помощью &man.ifconfig.8;.</para>

      <note>
	<para>В &os;&nbsp;5.X функциональность, предоставляемая утилитой
	  &man.gifconfig.8;, была внесена в &man.ifconfig.8;.</para>
      </note>

      <para>На шлюзе сети #1 для настройки туннеля вам потребуется запустить
	следующие две команды.</para>

      <programlisting>gifconfig gif0 A.B.C.D W.X.Y.Z
ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff
      </programlisting>

      <para>На другом шлюзе подобные команды, но с IP адресами в обратном
	порядке.</para>

      <programlisting>gifconfig gif0 W.X.Y.Z A.B.C.D
ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff
      </programlisting>

      <para>Затем вы можете запустить:</para>

      <programlisting>gifconfig gif0</programlisting>

      <para>для просмотра настройки.  Например, на шлюзе сети #1
	вы увидите:</para>

      <screen>&prompt.root; <userinput>gifconfig gif0</userinput>
gif0: flags=8011&lt;UP,POINTTOPOINT,MULTICAST&gt; mtu 1280
inet 192.168.1.1 --&gt; 192.168.2.1 netmask 0xffffffff
physical address inet A.B.C.D --&gt; W.X.Y.Z
      </screen>

      <para>Как вы можете видеть, был создан туннель между физическими
	адресами <hostid role="ipaddr">A.B.C.D</hostid> и
	<hostid role="ipaddr">W.X.Y.Z</hostid>, для тунеллирования разрешен
	трафик между <hostid
	role="ipaddr">192.168.1.1</hostid> и <hostid
	role="ipaddr">192.168.2.1</hostid>.</para>

      <para>Это также добавляет запись к таблице маршрутизации на обеих
	машинах, вы можете проверить запись командой <command>netstat
	-rn</command>.  Вот вывод этой команды на шлюзе сети #1.</para>

      <screen>&prompt.root; <userinput>netstat -rn</userinput>
Routing tables

Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...
      </screen>

      <para>Как показывает значение поля <quote>Flags</quote>, это маршрут
	к хосту, что означает, что каждый шлюз знает, как достичь другого
	шлюза, но не знает как достичь остальной части соответствующей сети.
	Эта проблема будет быстро решена.</para>

      <para>Вероятно, на обеих машинах запущен межсетевой экран.  VPN
	должен обходить его.  Вы можете разрешить весь трафик между
	двумя сетями, или включить правила, защищающие каждый конец
	соединения от другого.</para>

      <para>Это сильно упрощает тестирование настройки межсетевого экрана,
	если вы разрешаете весь трафик через VPN.  Вы всегда можете
	Вы всегда можете усилить защиту позже.  Если вы используете
	на шлюзах &man.ipfw.8;, команда вроде этой</para>

      <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>

      <para>разрешит весь трафик между двумя концами VPN без влияния на
	другие правила межсетевого экрана.  Очевидно, вам потребуется
	запустить эту команду на обеих шлюзах.</para>

      <para>Этого достаточно для включения ping с одного шлюза на другой.
	На <hostid role="ipaddr">192.168.1.1</hostid>, вы сможете
	запустить</para>

      <programlisting>ping 192.168.2.1</programlisting>

      <para>и получить ответ, и аналогично на другом шлюзе.</para>

      <para>Однако, машины в другой сети пока недоступны.  Это из-за
	маршрутизации &mdash; хотя шлюзы знают, как связаться друг с
	другом, они не знают, как связаться с сетью за другим шлюзом.</para>

      <para>Для решения этой проблемы вы должны добавить статический маршрут
	на каждом шлюзе.  Команда на первом шлюзе будет выглядеть так:</para>

      <programlisting>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00
      </programlisting>

      <para>Она говорит <quote>Для достижения хостов в сети
	<hostid role="ipaddr">192.168.2.0</hostid>, отправляйте пакеты
	хосту <hostid role="ipaddr">192.168.2.1</hostid></quote>.  Вам
	потребуется запустить похожую команду на другом шлюзе, но с
	адресами <hostid role="ipaddr">192.168.1.x</hostid>.</para>

      <para>IP трафик с хостов в одной сети теперь может достичь хосты в
	другой сети.</para>

      <para>Теперь создано две трети VPN между двумя сетями, поскольку
	это <quote>виртуальная (virtual)</quote> <quote>сеть (network)</quote>.
	Она еще не приватная (private).  Вы можете протестировать ее
	с помощью &man.ping.8; и &man.tcpdump.1;.  Войдите на шлюз и
	запустите</para>

      <programlisting>tcpdump dst host 192.168.2.1</programlisting>

      <para>В другой сессии на этом же хосте запустите</para>

      <programlisting>ping 192.168.2.1</programlisting>

      <para>Вы увидите примерно такие строки:</para>

      <programlisting>
16:10:24.018080 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
      </programlisting>

      <para>Как вы видите, ICMP сообщения пересылаются вперед и назад
	незашифрованными.  Если вы использовали с &man.tcpdump.1; параметр
	<option>-s</option> для получения большего объема данных пакета,
	то увидите больше информации.</para>

      <para>Конечно же это неприемлемо.  В следующем разделе мы обсудим
	защиту соединения между двумя сетями, так что весь трафик будет
	автоматически шифроваться.</para>

      <itemizedlist>
	<title>Резюме:</title>
	<listitem>
	  <para>Настройте оба ядра с <quote>pseudo-device
	  gif</quote>.</para>
	</listitem>
	<listitem>
	  <para>Отредактируйте <filename>/etc/rc.conf</filename> на шлюзе
	    #1 и добавьте следующие строки (подставляя IP адреса где
	    необходимо).</para>
	  <programlisting>gifconfig_gif0="A.B.C.D W.X.Y.Z"
ifconfig_gif0="inet 192.168.1.1 192.168.2.1 netmask 0xffffffff"
static_routes="vpn"
route_vpn="192.168.2.0 192.168.2.1 netmask 0xffffff00"
	  </programlisting>
	</listitem>

	<listitem>
	  <para>Отредактируйте скрипт межсетевого экрана
	  (<filename>/etc/rc.firewall</filename>, или подобный) на обеих
	  хостах и добавьте</para>

	  <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>
	</listitem>
	<listitem>
	  <para>Выполните соответствующие изменения в
	    <filename>/etc/rc.conf</filename> на шлюзе #2,
	    меняя порядок IP адресов.</para>
	</listitem>
      </itemizedlist>
    </sect3>

    <sect3>
      <title>Шаг 2: Защита соединения</title>

      <para>Для защиты соединения мы будем использовать IPsec.  IPsec
	предоставляет хостам механизм определения ключа для шифрования
	и для последующего использования этого ключа для шифрования
	данных между двумя хостами.</para>

      <para>Здесь будут рассмотрены два аспекта настройки.</para>

      <orderedlist>
	<listitem>
	  <para>У хостов должен быть способ согласования используемого
	    алгоритма шифрования.  Как только хосты договорятся об этом,
	    можно говорить об установленном между ними
	    <quote>безопасном соединении</quote>.</para>
	</listitem>
	<listitem>
	  <para>Должен быть механизм определения, какой трафик необходимо
	    шифровать.  Конечно, вам не требуется шифровать весь исходящий
	    трафик &mdash; достаточно шифровать только трафик, идущий
	    через VPN.  Правила, определяющие то, какой трафик необходимо
	    шифровать, называются <quote>политикой безопасности</quote>.</para>
	</listitem>
      </orderedlist>

      <para>Безопасное соединение и политика безопасности поддерживаются
	ядром, и могут быть изменены программами пользователя.  Однако
	перед тем, как вы сможете сделать это, необходимо настроить
	поддержку протоколов IPsec и Encapsulated Security Payload (ESP) в
	ядре.  Это делается добавлением в настройку ядра параметров:</para>

       <programlisting>options IPSEC
options IPSEC_ESP
       </programlisting>

      <para>с последующим перекомпилированием, переустановкой и
	перезагрузкой.  Как и прежде вам потребуется сделать это с ядрами на
	обеих шлюзах.</para>

      <para>При настройке параметров безопасности (security associations)
	у вас есть два варианта.  Вы можете настроить их вручную для обеих
	хостов, задав алгоритм шифрования, ключи для шифрования и так далее,
	или использовать даемоны, реализующие Internet Key Exchange protocol
	(IKE), который сделает это за вас.</para>

      <para>Рекомендуется последнее.  Помимо прочего, этот способ более
	прост.</para>

      <para>Редактирование и отображение политики безопасности выполняется
	с помощью &man.setkey.8;.  По аналогии, <command>setkey</command>
	используется для настройки таблиц политики безопасности ядра так же,
	как &man.route.8; используется для настройки таблиц маршрутизации
	ядра.  <command>setkey</command> также может отображать текущие
	параметры безопасности, и продолжая аналогию дальше, это
	соответствует <command>netstat -r</command>.</para>

      <para>Существует множество даемонов для управления параметрами
	безопасности в FreeBSD.  Здесь будет описано использование одного из
	них, racoon.  racoon находится в категории security/ коллекции портов
	FreeBSD и устанавливается обычным способом.</para>

      <para>racoon должен работать на обеих шлюзах.  На каждом из хостов
	он настраивается с IP адресом другого конца VPN, и секретным
	ключом (по вашему выбору, должен быть одним и тем же на обеих
	шлюзах).</para>

      <para>Эти два даемона подключаются друг к другу, подтверждают, что они
	именно те, за кого себя выдают (используя секретный ключ, заданный
	вами).  Затем даемоны генерируют новый секретный ключ и используют
	его для шифрования трафика через VPN.  Они периодически изменяют
	этот ключ, так что даже если атакующий сломает один из ключей
	(что теоретически почти невозможно) это не даст ему слишком много
	&mdash; он сломал ключ, который два даемона уже сменили на
	другой.</para>

      <para>Настройки racoon сохраняются в
	<filename>${PREFIX}/etc/racoon</filename>.  Этот файл не требует
	слишком больших изменений.  Другим компонентом настройки
	racoon, который потребуется изменить, является <quote>предварительный
	ключ</quote>.</para>

      <para>В настройке по умолчанию racoon ищет его в файле
	<filename>${PREFIX}/etc/racoon/psk.txt</filename>.  Необходимо
	отметить, что предварительный ключ <emphasis>не</emphasis>
	используется для шифрования трафика через VPN соединение
	это просто маркер, позволяющий управляющим ключами даемонам
	доверять друг другу.</para>

      <para><filename>psk.txt</filename> содержит строку для каждого
	удаленного сервера, с которым происходит соединение.  В этом примере
	два сервера, каждый файл <filename>psk.txt</filename> будет
	содержать одну строку (каждый конец VPN общается только с другим
	концом.</para>

       <para>На шлюзе #1 эта строка будет выглядеть примерно так:</para>

       <programlisting>W.X.Y.Z            secret</programlisting>

      <para>То есть <emphasis>публичный</emphasis> IP адрес удаленной
	стороны, пробел и текстовая строка, секретная фраза.
	<!-- какой ключ?: Конечно, вы
	не должны использовать ту же секретную фразу, что и ключ &mdash;
	применяются обычные правила выбора паролей. --></para>

      <para>На шлюзе #2 строка будет выглядеть примерно так:</para>

      <programlisting>A.B.C.D            secret</programlisting>

      <para>То есть публичный IP адрес удаленной стороны и та же
	секретная фраза.  Перед запуском racoon режим доступа к файлу
	<filename>psk.txt</filename> должен быть установлен в
	<literal>0600</literal> (т.е. запись и чтение только для
	<username>root</username>).</para>

      <para>Вы должны запустить racoon на обеих шлюзах.  Вам также
	потребуется добавить правила для включения IKE трафика,
	передающегося по UDP через порт ISAKMP (Internet Security Association
	Key Management Protocol).  Опять же, они должны быть
	расположены насколько возможно ближе к началу набора правил.</para>

      <programlisting>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
      </programlisting>

      <para>Как только racoon будет запущен, вы можете попробовать
	выполнить ping с одного шлюза на другой.  Соединение все еще не
	зашифровано, но racoon установит параметры безопасности между
	двумя хостами &mdash; это может занять время и вы можете заметить
	небольшую задержку перед началом ответа команды ping.</para>

      <para>Как только параметры безопасности установлены, вы можете
	просмотреть их используя &man.setkey.8;.  Запустите</para>

      <programlisting>setkey -D</programlisting>

      <para>на любом из хостов для просмотра информации о параметрах
	безопасности.</para>

      <para>Это одна сторона проблемы.  Другая сторона это настройка
	политики безопасности.</para>

      <para>Для создания разумной политики безопасности давайте вспомним,
	что уже было настроено.  Это рассмотрение относится к обеим
	концам соединения.</para>

      <para>Каждый отправляемый IP пакет имеет заголовок, содержащий информацию
	о пакете.  Заголовок включает IP адреса источника и назначения.
	Как мы уже знаем, приватные IP адреса, такие как <hostid
	role="ipaddr">192.168.x.y</hostid>, не могут появиться в
	интернет.  Они должны быть сначала включены внутрь другого
	пакета.  В этом пакете приватные IP адреса источника и назначения
	заменяются публичными IP адресами.</para>

      <para>То есть исходящий пакет, который выглядит примерно так:</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-out-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .----------------------------.
  | Src: 192.168.1.1           |
  | Dst: 192.168.2.1           |
  | &lt;другие данные заголовка&gt;  |
  +----------------------------+
  | &lt;данные пакета&gt;            |
  `----------------------------'</literallayout>
	  </textobject>
	</mediaobject>

      <para>будет инкапсулирован в другой пакет, выглядящий примерно
	так:</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-encap-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .--------------------------------.
  | Src: A.B.C.D                   |
  | Dst: W.X.Y.Z                   |
  | &lt;другие данные заголовка&gt;      |
  +--------------------------------+
  | .----------------------------. |
  | | Src: 192.168.1.1           | |
  | | Dst: 192.168.2.1           | |
  | | &lt;другие данные заголовка&gt;  | |
  | +----------------------------+ |
  | | &lt;данные пакета&gt;            | |
  | `----------------------------' |
  `--------------------------------'</literallayout>
	  </textobject>
	</mediaobject>

      <para>Этой инкапсуляцией занимается устройство
	<devicename>gif</devicename>.  Как вы можете видеть, теперь
	у пакета есть реальный IP адрес, исходный пакет был включен
	в этот пакет в виде данных, которые передаются через
	интернет.</para>

      <para>Конечно, мы хотим зашифровать весь трафик между VPN.
	Вы можете сформулировать это на словах так:</para>

      <para><quote>Если пакет отправляется с <hostid
	role="ipaddr">A.B.C.D</hostid>, и предназначен для <hostid
	role="ipaddr">W.X.Y.Z</hostid>, расшифровать его, используя
	необходимые параметры безопасности.</quote></para>

      <para><quote>Если пакет отправляется с <hostid
	role="ipaddr">W.X.Y.Z</hostid>, и предназначен для <hostid
	role="ipaddr">A.B.C.D</hostid>, расшифровать его, используя
	необходимые параметры безопасности.</quote></para>

       <para>Это похоже на желаемое, но не совсем то.  Если вы сделаете
	это, весь трафик от и к <hostid role="ipaddr">W.X.Y.Z</hostid>,
	даже если он не является частью VPN, будет зашифрован.  Правильная
	политика такова:</para>

      <para><quote>Если пакет отправляется с <hostid
	role="ipaddr">A.B.C.D</hostid>, в нем инкапсулирован другой пакет
	и адрес назначения <hostid role="ipaddr">W.X.Y.Z</hostid>,
	зашифровать его, используя необходимые параметры
	безопасности.</quote></para>

      <para><quote>Если пакет отправляется с <hostid
	role="ipaddr">W.X.Y.Z</hostid>, в нем инкапсулирован другой пакет
	и адрес назначения <hostid role="ipaddr">A.B.C.D</hostid>,
	зашифровать его, используя необходимые параметры
	безопасности.</quote></para>

      <para>Тонкое, но необходимое различие.</para>

      <para>Политика безопасности также устанавливается с использованием
	&man.setkey.8;.  В &man.setkey.8; предусмотрен язык определения
	политики &man.setkey.8;.  Вы можете или ввести инструкции
	по настройке со стандартного ввода, или использовать параметр
	<option>-f</option> для задания файла, содержащего эти
	инструкции.</para>

      <para>Настройка на шлюзе #1 (где есть публичный IP адрес
	<hostid role="ipaddr">A.B.C.D</hostid>) для включения шифрования
	всего предназначенного <hostid role="ipaddr">W.X.Y.Z</hostid>
	трафика:</para>

      <programlisting>
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;
      </programlisting>

      <para>Поместите эти команды в файл (например,
	<filename>/etc/ipsec.conf</filename>) и запустите</para>

      <screen>&prompt.root; <userinput>setkey -f /etc/ipsec.conf</userinput></screen>

      <para><option>spdadd</option> указывает &man.setkey.8; добавить
	правило к базе данных политики безопасности.  Остальная часть
	строки указывает какие пакеты будут соответствовать политике.
	<hostid role="ipaddr">A.B.C.D/32</hostid> и <hostid
	role="ipaddr">W.X.Y.Z/32</hostid> это IP адреса и сетевые маски,
	определяющие сети или хосты, к которым будет применяться данная
	политика.  В данном случае мы хотим применить их к трафику между
	этими двумя хостами.  Параметр <option>ipencap</option> сообщает
	ядру, что эта политика должна применяться только к пакетам,
	инкапсулирующим другие пакеты.  Параметр <option>-P out</option>
	сообщает, что эта политика применяется к исходящим пакетам, и
	<option>ipsec</option> &mdash; то, что пакеты будут
	зашифрованы.</para>

      <para>Оставшаяся часть строки определяет, как эти пакеты будут
	зашифрованы.  Будет использоваться протокол <option>esp</option>,
	а параметр <option>tunnel</option> показывает, что пакет в дальнейшем
	будет инкапсулирован в IPsec пакет.  Повторное использование
	<hostid role="ipaddr">A.B.C.D</hostid> и <hostid
	role="ipaddr">W.X.Y.Z</hostid> предназначено для выбора
	используемых параметров безопасности, и наконец параметр
	<option>require</option> разрешает шифрование пакетов, попадающих
	под это правило.</para>

      <para>Это правило соответствует только исходящим пакетам.  Вам
	потребуется похожее правило, соответствующее входящим пакетам.</para>

      <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</programlisting>

      <para>Обратите внимание, что вместо <option>in</option> используется
	 <option>out</option> и IP адреса переставлены.</para>

      <para>Другому шлюзу (с публичным IP адресом
	<hostid role="ipaddr">W.X.Y.Z</hostid>) потребуются похожие
	правила.</para>

      <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</programlisting>

      <para>Наконец, вам потребуется добавить правила к межсетевому экрану
	для включения прохождения пакетов ESP и IPENCAP в обе стороны.
	На обеих хостах потребуется добавить следующие правила:</para>

      <programlisting>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
      </programlisting>

      <para>Поскольку правила симметричны, можно использовать их без
	изменения на обеих хостах

      <para>Исходящие пакеты теперь будут выглядеть примерно так:</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-crypt-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .------------------------------.  --------------------------.
  | Src: A.B.C.D                 |                            |
  | Dst: W.X.Y.Z                 |                            |
  | &lt;other header info&gt;          |                            |  Encrypted
  +------------------------------+                            |  packet.
  | .--------------------------. |  -------------.            |  contents
  | | Src: A.B.C.D             | |               |            |  are
  | | Dst: W.X.Y.Z             | |               |            |  completely
  | | &lt;other header info&gt;      | |               |            |- secure
  | +--------------------------+ |               |  Encap'd   |  from third
  | | .----------------------. | |  -.           |  packet    |  party
  | | | Src: 192.168.1.1     | | |   |  Original |- with real |  snooping
  | | | Dst: 192.168.2.1     | | |   |  packet,  |  IP addr   |
  | | | &lt;other header info&gt;  | | |   |- private  |            |
  | | +----------------------+ | |   |  IP addr  |            |
  | | | &lt;packet data&gt;        | | |   |           |            |
  | | `----------------------' | |  -'           |            |
  | `--------------------------' |  -------------'            |
  `------------------------------'  --------------------------'
	    </literallayout>
	  </textobject>
	</mediaobject>

      <para>Когда эти пакеты будут получены на удаленном конце VPN
	соединения, они будут расшифрованы (используя параметры
	безопасности, о которых договорился racoon).  Затем они будут
	переданы интерфейсу <devicename>gif</devicename>, который
	<quote>развернет</quote> второй слой, оставив пакет с внутренними
	адресами, который сможет попасть во внутреннюю сеть.</para>

      <para>Вы можете проверить безопасность тем же &man.ping.8;, который
	использовался ранее.  Сначала войдите на шлюз <hostid
	role="ipaddr">A.B.C.D</hostid> и запустите:</para>

      <programlisting>tcpdump dst host 192.168.2.1</programlisting>

      <para>В другой сессии на том же хосте запустите</para>

      <programlisting>ping 192.168.2.1</programlisting>

      <para>В этот момент вы должны увидеть примерно это:</para>

      <programlisting>XXX tcpdump output</programlisting>

      <para>Теперь, как видите, &man.tcpdump.1; показывает ESP пакеты.  Если
	вы попытаетесь просмотреть их с параметром <option>-s</option>,
	то вероятно увидите  нечто непонятное, поскольку применяется
	шифрование.</para>

      <para>Поздравляем. Вы только что настроили VPN между двумя удаленными
	сетями.</para>

      <itemizedlist>
	<title>Резюме</title>
	<listitem>
	  <para>Настройте оба ядра с:</para>

	  <programlisting>options IPSEC
options IPSEC_ESP
	  </programlisting>
	</listitem>
	<listitem>
	  <para>Установите <filename
	    role="package">security/racoon</filename>.  Отредактируйте
	    <filename>${PREFIX}/etc/racoon/psk.txt</filename> на обеих
	    шлюзах, добавив запись для каждого IP адреса удаленного хоста
	    и секретный ключ, который будет известен им обеим.  Убедитесь,
	    что режим доступа к файлу 0600.</para>
	</listitem>
	<listitem>
	  <para>Добавьте к
	    <filename>/etc/rc.conf</filename> на каждом хосте следующие
	    строки:</para>

	  <programlisting>ipsec_enable="YES"
ipsec_file="/etc/ipsec.conf"
	  </programlisting>
	</listitem>
	<listitem>
	  <para>Создайте <filename>/etc/ipsec.conf</filename> на каждом
	    хосте с необходимыми строками spdadd.  На шлюзе #1 он будет
	    таким:</para>

	  <programlisting>
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
</programlisting>

	  <para>А на шлюзе #2 таким:</para>

<programlisting>
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
</programlisting>
	</listitem>
	<listitem>
	  <para>Добавьте правила к межсетевым экранам обеих хостов для
	    включения IKE, ESP и IPENCAP трафика:</para>

	  <programlisting>
ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
	  </programlisting>
	</listitem>
      </itemizedlist>

      <para>Двух приведенных шагов должно быть достаточно для настройки
	и включения VPN.  Машины в каждой сети смогут обращаться друг к
	другу по IP адресам, и весь трафик через соединение будет
	автоматически надежно зашифрован.</para>
    </sect3>
    </sect2>
  </sect1>

  <sect1 id="openssh">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Предоставил </contrib>
	</author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </sect1info>

    <title>OpenSSH</title>
    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> это набор сетевых инструментов,
      используемых для защищенного доступа к удаленным компьютерам.
      Он может быть использован в качестве непосредственной замены
      <command>rlogin</command>, <command>rsh</command>,
      <command>rcp</command> и <command>telnet</command>.
      Кроме того, любые другие TCP/IP соединения могут быть безопасно
      тунеллированы/перенаправлены через SSH.
      <application>OpenSSH</application> шифрует весь трафик, эффективно
      предотвращая кражу данных, перехват соединения и другие сетевые
      атаки.</para>

    <para><application>OpenSSH</application> поддерживается проектом
      OpenBSD, он основан на SSH v1.2.12 со всеми последними исправлениями
      и обновлениями, совместим с протоколами SSH версий 1 и 2.
      <application>OpenSSH</application> включен в базовую систему
      начиная с FreeBSD&nbsp;4.0.</para>

    <sect2>
      <title>Преимущества использования OpenSSH</title>

      <para>Обычно при использовании &man.telnet.1; или &man.rlogin.1;
	данные пересылаются по сети в незашифрованной форме.  Перехватчик
	пакетов в любой точке сети между клиентом и сервером может
	похитить информацию о пользователе/пароле или данные, передаваемые
	через соединение.  Для предотвращения этого
	<application>OpenSSH</application> предлагает различные методы
	шифрования.</para>
    </sect2>

    <sect2>
      <title>Включение sshd</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>включение</secondary>
      </indexterm>

      <para>Убедитесь, что добавили в файл <filename>rc.conf</filename>
	 следующую строку:</para>

      <screen>sshd_enable="YES"</screen>

      <para>При следующей загрузке системы запущен &man.sshd.8;, даемон для
	<application>OpenSSH</application>.  Вы можете также запустить
	<application>sshd</application> непосредственно, набрав в
	командной строке <command>sshd</command>.</para>

    <sect2>
      <title>SSH клиент</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>клиент</secondary>
      </indexterm>

      <para>Утилита &man.ssh.1; работает подобно &man.rlogin.1;.</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para>Вход продолжится так же, как если бы сессия была инициирована
	с использованием <command>rlogin</command> или
	<command>telnet</command>.  SSH использует систему опознавательных
	ключей для проверки подлинности сервера при подключении клиента.
	Пользователю предлагается <literal>yes</literal> только при первом
	подключении.  Дальнейшие попытки входа предваряются проверкой
	сохраненного ключа сервера.  SSH клиент сообщит вам, если сохраненный
	ключ будет отличаться от только что полученного.  Ключи серверов
	сохраняются в <filename>~/.ssh/known_hosts</filename>, или в
	<filename>~/.ssh/known_hosts2</filename> для SSH v2.</para>

      <para>По умолчанию, сервер <application>OpenSSH</application> настроен
	для приема соединений SSH v1 и SSH v2.  Клиент может выбирать между
	этими двумя протоколами.  Версия 2 безопаснее своего
	предшественника.</para>

      <para>Команде &man.ssh.1; можно указать использование определенной
	версии протокола, запустив ее с параметром <option>-1</option>
	или <option>-2</option> для версии 1 или 2 соответственно.</para>
    </sect2>

    <sect2>
      <title>Безопасное копирование</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>безопасное копирование</secondary>
      </indexterm>
      <indexterm><primary><command>scp</command></primary></indexterm>

      <para>Команда &man.scp.1; работает подобно &man.rcp.1;; она копирует
	файл с удаленного компьютера, но делает это безопасным
	способом.</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@example.com's password: <userinput>*******</userinput>
COPYRIGHT            100% |*****************************|  4735       
00:00    
&prompt.root;</screen>

      <para>Поскольку в предыдущем примере ключ сервера уже был сохранен,
	в этом примере он проверяется при использовании &man.scp.1;.</para>

      <para>Параметры, передаваемые &man.scp.1;, похожи на параметры
	&man.cp.1;, с файлом или файлами в качестве первого аргумента и
	приемником копирования во втором.  Поскольку файлы файлы передаются
	по сети через SSH, один или более аргументов принимают форму
	<option>user@host:&lt;path_to_remote_file&gt;</option>.</para>

    </sect2>

    <sect2>
      <title>Настройка</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>настройка</secondary>
      </indexterm>

      <para>Системные файлы настройки для даемона и клиента
	<application>OpenSSH</application> расположены в каталоге
	<filename>/etc/ssh</filename>.</para>

      <para>Файл <filename>ssh_config</filename> используется для настройки
	клиента, а <filename>sshd_config</filename> для даемона.</para>

      <para>Кроме того, параметры <option>sshd_program</option>
	(по умолчанию <filename>/usr/sbin/sshd</filename>), и
	<option>sshd_flags</option> <filename>rc.conf</filename>
	дают дополнительные возможности настройки.</para>
    </sect2>

    <sect2>
      <title>ssh-keygen</title>

      <para>Вместо использования паролей, с помощью &man.ssh-keygen.1;
	пользователи могут аутентифицироваться ключами RSA:</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t <replaceable>rsa1</replaceable></userinput>
Initializing random number generator...
Generating p:  .++ (distance 66)
Generating q:  ..............................++ (distance 498)
Computing the keys...
Key generation complete.
Enter file in which to save the key (/home/user/.ssh/identity):
Enter passphrase:
Enter the same passphrase again:
Your identification has been saved in /home/user/.ssh/identity.
...</screen>

      <para>&man.ssh-keygen.1; создаст пару публичного и приватного
	ключей, используемых для аутентификации.  Приватный ключ сохраняется
	в <filename>~/.ssh/identity</filename>, а публичный в
	<filename>~/.ssh/identity.pub</filename>.  Для включения
	аутентификации по ключам публичный ключ должен
	быть помещен в <filename>~/.ssh/authorized_keys</filename>
	на удаленном компьютере.</para>

      <para>Это позволяет соединяться с удаленным компьютером с помощью
	RSA аутентификации вместо паролей.</para>

      <note><para>Параметр <option>-t rsa1</option> приведет к созданию RSA
	ключей, используемых SSH протоколом версии 1.  Если вы хотите
	использовать RSA ключи с SSH протоколом версии 2, используйте
	команду <command>ssh-keygen -t rsa</command>.</para></note>

      <para>Если при генерации ключей был использован пароль, каждый раз
	для при использовании приватного ключа он будет запрашиваться
	у пользователя.</para>

      <para>DSA ключ для SSH протокола версии 2 может быть создан в тех же
	целях командой <command>ssh-keygen -t dsa</command>.  Эта команда
	создаст публичный/приватный ключи DSA для использования только
	с SSH протоколом версии 2.  Публичный ключ сохраняется в
	<filename>~/.ssh/id_dsa.pub</filename>, а приватный ключ в
	<filename>~/.ssh/id_dsa</filename>.</para>

      <para>Публичный ключ DSA также должен быть помещен в каталог
	<filename>~/.ssh/authorized_keys</filename> на удаленном
	компьютере.</para>

      <para>Утилиты &man.ssh-agent.1; и &man.ssh-add.1; используются
	для управления множеством защищенных паролем приватных
	ключей.</para>

      <warning><para>Параметры и имена файлов могут различаться для разных
	версий <application>OpenSSH</application>, установленных в системе,
	для решения проблем обратитесь к странице справочника
	&man.ssh-keygen.1;.</para></warning>
    </sect2>

    <sect2 id="security-ssh-tunneling">
      <title>SSH тунеллирование</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>тунеллирование</secondary>
      </indexterm>

      <para><application>OpenSSH</application> поддерживает возможность
	создания туннеля для пропуска соединения по другому протоколу
	через защищенную сессию.</para>

      <para>Следующая команда указывает &man.ssh.1; создать туннель для
	<application>telnet</application>:</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

      <para>Команда <command>ssh</command> используется со следующими
	параметрами:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>

	  <listitem>
	    <para>Указывает <command>ssh</command> использовать версию
	      2 протокола (не используйте этот параметр, если работаете
	      со старыми SSH серверами).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>Означает использование в не-командном режиме, только для
	      тунеллирования.  Если этот параметр опущен,
	      <command>ssh</command> запустит обычную сессию.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Указывает <command>ssh</command> запускаться в фоновом
	      режиме.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Означает локальный туннель в стиле
	      <replaceable>localport:remotehost:remoteport</replaceable>.</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>Удаленный сервер SSH.</para>
	  </listitem>
	</varlistentry>
      </variablelist>


      <para>Туннель SSH создается путем создания прослушивающего сокета
	на определенном порту <hostid>localhost</hostid>.  Затем все
	принятые на локальном хосту/порту соединения переправляются на
	через SSH на определенный удаленный хост и порт.</para>

      <para>В этом примере, порт <replaceable>5023</replaceable> на
	<hostid>localhost</hostid> перенаправляется на порт
	<replaceable>23</replaceable> на <hostid>localhost</hostid>
	удаленного компьютера.  Поскольку <replaceable>23</replaceable>
	это порт <application>telnet</application>, будет создано защищенное
	соединение <application>telnet</application> через туннель
	SSH.</para>

      <para>Этот метод можно использовать для любого числа небезопасных
	протоколов, таких как SMTP, POP3, FTP, и так далее.</para>

      <example>
	<title>Использование SSH для создания защищенного туннеля на
	  SMTP</title>

	<screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>

	<para>Этот метод можно использовать вместе с &man.ssh-keygen.1;
	  и дополнительными пользовательскими учетными записями для
	  создания более удобного автоматического SSH тунеллирования.
	  Ключи могут быть использованы вместо паролей, и туннели
	  могут запускаться от отдельных пользователей.</para>
      </example>

      <sect3>
	<title>Практические примеры SSH тунеллирования</title>

	<sect4>
	  <title>Защищенный доступ к серверу POP3</title>

	  <para>На работе находится SSH сервер, принимающий соединения
	    снаружи.  В этой же офисной сети находится почтовый сервер,
	    поддерживающий протокол POP3.  Сеть или сетевое соединение
	    между вашим домом и офисом могут быть или не быть полностью
	    доверяемыми.  По этой причине вам потребуется проверять
	    почту через защищенное соединение.  Решение состоит в создании
	    SSH соединения к офисному серверу SSH и тунеллирование
	    через него к почтовому серверу.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Когда туннель включен и работает, вы можете настроить
	    почтовый клиент для отправки запросов POP3 на
	    <hostid>localhost</hostid>, порт 2110.  Соединение будет
	    безопасно переправлено через туннель на
	    <hostid>mail.example.com</hostid>.</para>
	</sect4>

	<sect4>
	  <title>Прохождение через Драконовский Брандмауэр</title>

	  <para>Некоторые сетевые администраторы устанавливают
	    на межсетевых экранах (брандмауэрах) драконовские правила,
	    фильтруя не только входящие соединения, но и исходящие.
	    Вам может быть разрешен доступ к удаленным компьютерам только
	    по портам 22 и 80, для SSH и просмотра сайтов.</para>

	  <para>Вам может потребоваться доступ к другому (возможно, не
	    относящемуся к работе) сервису, такому как Ogg Vorbis
	    для прослушивания музыки.  Если этот сервер Ogg Vorbis
	    выдает поток не с портов 22 или 80, вы не сможете получить
	    к нему доступ.</para>

	  <para>Решение состоит в создании SSH соединения с компьютером
	    вне межсетевого экрана и использование его для тунеллирования
	    сервера Ogg Vorbis.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>Клиентскую программу теперь можно настроить на
	    <hostid>localhost</hostid> порт 8888, который будет перенаправлен
	    на <hostid>music.example.com</hostid> порт 8000, успешно
	    обойдя межсетевой экран.</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Для дальнейшего чтения</title>

      <para><ulink url="http://www.openssh.com/">OpenSSH</ulink></para>
      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1;
	&man.ssh-agent.1; &man.ssh-add.1;</para>
      <para>&man.sshd.8; &man.sftp-server.8;</para>
    </sect2>
  </sect1>

  <sect1 id="fs-acl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>ACL</primary>
    </indexterm>
    <title>Списки контроля доступа файловой системы (ACL)</title>

    <para>В дополнение к другим расширениям файловой системы, таким как
      снимки (snapshots), FreeBSD 5.0 и более поздние версии системы
      предлагают защиту с помощью списков контроля доступа файловой системы
      (File System Access Control Lists, <acronym>ACLs</acronym>).</para>

    <para>Списки контроля доступа расширяют стандартную модель прав &unix;
      высоко совместимым (&posix;.1e) способом.  Эта возможность позволяет
      администратору получить преимущество от использования более
      интеллектуальной модели безопасности.</para>

    <para>Для включения поддержки <acronym>ACL</acronym> в файловой
      системе <acronym>UFS</acronym>, следующая строка:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>должна быть добавлена в файл настройки ядра.  Если параметр не
      добавлен, при попытке монтирования систем, поддерживающих
      <acronym>ACL</acronym>, появится предупреждающее сообщение.
      Этот параметр включен в ядро <filename>GENERIC</filename>.
      <acronym>ACL</acronym> основывается на дополнительных атрибутах,
      встроенных в файловую систему.  Дополнительные атрибуты
      поддерживаются по умолчанию следующим поколением файловых систем
      &unix;, <acronym>UFS2</acronym>.</para>

    <note><para>Для включения дополнительных атрибутов в
      <acronym>UFS1</acronym> требуется больше усилий по сравнению с
      <acronym>UFS2</acronym>.  Производительность дополнительных
      атрибутов в <acronym>UFS2</acronym> также существенно выше.
      По этим причинам для работы с списками контроля доступа
      предпочтительно использование <acronym>UFS2</acronym></para></note>

    <para><acronym>ACL</acronym> включаются во время монтирования флагом
      <option>acls</option>, который добавляется к
      <filename>/etc/fstab</filename>.  Этот флаг также можно сделать
      постоянным с помощью &man.tunefs.8;, изменив флаг
      <acronym>ACL</acronym> в заголовке файловой системы.  Вообще говоря,
      использование флага в суперблоке предпочтительно по нескольким
      причинам:</para>

    <itemizedlist>
      <listitem>
	<para>Постоянный <acronym>ACL</acronym> флаг не может быть изменен
	  путем перемонтирования системы (&man.mount.8; <option>-u</option>),
	  а только через &man.umount.8; и &man.mount.8;.  Это означает,
	  что <acronym>ACL</acronym> нельзя включить на корневой файловой
	  системе после загрузки.  Это также означает, что вы не можете
	  изменить флаг на используемой файловой системе.</para>
      </listitem>

      <listitem>
	<para>Установка флага в суперблоке приводит к постоянному монтированию
	  файловой системы с включенным <acronym>ACL</acronym>, даже если
	  нет записи в <filename>fstab</filename> или при смене порядка
	  устройств.  Это предотвращает случайное монтирование файловой
	  системы без <acronym>ACL</acronym>, которое может повлечь за
	  собой проблемы с безопасностью.</para>
      </listitem>
    </itemizedlist>

    <note><para>Мы можем изменить поведение <acronym>ACL</acronym> для
	включения флага без полного перемонтирования, но считаем, что
	желательно исключить случайное монтирование без
	<acronym>ACL</acronym>, поскольку вы можете попасть в неприятную
	ситуацию, если включите <acronym>ACL</acronym>, затем выключите
	их, затем опять включите без сброса расширенных атрибутов.
	Обычно, как только вы включили <acronym>ACL</acronym> в файловой
	системе, они не должны быть выключены, поскольку получающаяся
	защита файлов может быть не совместима с той, что применяется
	пользователями системы, и повторное включение <acronym>ACL</acronym>
	может подключить предыдущие списки контроля доступа к файлам,
	права на которые изменены, что приведет к непредсказуемому
	поведению.</para></note>

    <para>Файловые системы с включенными <acronym>ACLs</acronym> показывают
      знак <literal>+</literal> при просмотре прав на файлы.
      Например:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>Здесь мы видим, что каталоги <filename>directory1</filename>,
      <filename>directory2</filename>, и <filename>directory3</filename>
      используют преимущества <acronym>ACL</acronym>.  Каталог
      <filename>public_html</filename> их не использует.</para>

    <sect2>
      <title>Использование <acronym>ACL</acronym></title>

      <para><acronym>ACL</acronym> файловой системы можно просмотреть
	с помощью утилиты &man.getfacl.1;.  Например, для просмотра
	настроек <acronym>ACL</acronym> файла
	<filename>test</filename>, может использоваться команда:</para>

      <screen>&prompt.user; <userinput>getfacl <filename>test</filename></userinput>
	#file:test
	#owner:1001
	#group:1001
	user::rw-
	group::r--
	other::r--</screen>

      <para>Для изменения <acronym>ACL</acronym> этого файла,
	вызовите утилиту &man.setfacl.1;.  Выполните:</para>

      <screen>&prompt.user; <userinput>setfacl -k <filename>test</filename></userinput></screen>

      <para>Параметр <option>-k</option> удалит все установленные
	на данный момент <acronym>ACL</acronym> из файла или файловой
	системы.  Более предпочтительный метод это использование
	параметра <option>-b</option>, который оставит необходимые
	для работы <acronym>ACL</acronym> поля.</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,group:web:r--,o::--- <filename>test</filename></userinput></screen>

      <para>В вышеприведенной команде параметр <option>-m</option>
	использован для изменения записей <acronym>ACL</acronym>
	по умолчанию.  Поскольку предустановленных записей не было (они были
	удалены предыдущей командой), эта команда восстановит параметры
	по умолчанию и задаст приведенные параметры.  Имейте ввиду,
	при добавлении пользователя или группы, которых нет в системе,
	на <devicename>stdout</devicename> будет выведена ошибка
	<errorname>Invalid argument</errorname>.</para>
    </sect2>
  </sect1>

  <sect1 id="security-advisories">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>Сообщения безопасности FreeBSD</primary>
    </indexterm>
    <title>Сообщения безопасности &os;</title>

    <para>Как многие и высококачественные операционные системы, &os;
      публикует <quote>Сообщения безопасности</quote> (<quote>Security
      Advisories</quote>).  Эти сообщения обычно отправляются по почте
      в списки рассылки, посвященные безопасности и публикуются
      в списке проблем только после выхода исправлений к соответствующим
      релизам.  В этом разделе разъясняется, что такое сообщения безопасности,
      как их читать и какие меры принимать для исправления системы.</para>

    <sect2>
      <title>Как выглядит сообщение?</title>

      <para>Сообщение безопасности &os; выглядит подобно сообщению ниже,
	взятому из списка рассылки &a.security-notifications.name;.</para>

      <programlisting>=============================================================================
&os;-SA-XX:XX.UTIL                                     Security Advisory
                                                          The &os; Project

Topic:          denial of service due to some problem<co id="co-topic">

Category:       core<co id="co-category">
Module:         sys<co id="co-module">
Announced:      2003-09-23<co id="co-announce">
Credits:        Person@EMAIL-ADDRESS<co id="co-credit">
Affects:        All releases of &os;<co id="co-affects">
                &os; 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<co id="co-corrected">
&os; only:   NO<co id="co-only">

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background<co id="co-backround">


II.  Problem Description<co id="co-descript">


III. Impact<co id="co-impact">


IV.  Workaround<co id="co-workaround">


V.   Solution<co id="co-solution">


VI.  Correction details<co id="co-details">


VII. References<co id="co-ref"></programlisting>


      <calloutlist>
	<callout arearefs="co-topic">
	  <para>Поле <literal>Topic</literal> показывает в чем именно
	    заключается проблема.  Это обычно введение в сообщение
	    безопасности, упоминающее утилиту, в которой возникла
	    ошибка.</para>
	</callout>

	<callout arearefs="co-category">
	  <para>Поле <literal>Category</literal> относится к затронутой части
	    системы и может быть выбрана из <literal>core</literal>,
	    <literal>contrib</literal>, или <literal>ports</literal>.
	    Категория <literal>core</literal> означает, что
	    уязвимость затрагивает основной компонент операционной системы
	    &os;.  Категория <literal>contrib</literal> означает, что
	    уязвимость затрагивает программы, предоставленные проекту
	    &os;, например <application>sendmail</application>.  Наконец,
	    категория <literal>ports</literal> означает, что уязвимость
	    затрагивает программное обеспечение, доступное из коллекции
	    портов.</para>
	</callout>

	<callout arearefs="co-module">
	  <para>Поле <literal>Module</literal> указывает на местоположение
	    компонента, например <literal>sys</literal>.  В этом примере
	    мы видим, что затронут модуль <literal>sys</literal>,
	    следовательно, эта уязвимость относится к компоненту,
	    используемому в ядре.</para>
	</callout>

	<callout arearefs="co-announce">
	  <para>Поле <literal>Announced</literal> отражает дату публикации
	    сообщения безопасности, или его анонсирования.  Это означает,
	    что команда обеспечения безопасности убедилась, что проблема
	    существует и что патч помещен в репозиторий исходных текстов
	    &os;.</para>
	</callout>

	<callout arearefs="co-credit">
	  <para>Поле <literal>Credits</literal> упоминает частное лицо или
	    организацию, обнаружившую уязвимость и сообщившую о ней.</para>
	</callout>

	<callout arearefs="co-affects">
	  <para>Поле <literal>Affects</literal> дает информацию о релизах
	    &os;, к которым относится данная уязвимость.  Для базовой
	    системы, просмотр вывода команды <command>ident</command>
	    для файлов, затронутых уязвимостью, поможет определить
	    ревизию.  Номер версии портов приведен после имени порта
	    в каталоге <filename>/var/db/pkg</filename>.  Если система
	    не синхронизируется с <acronym>CVS</acronym> репозиторием
	    &os; и не пересобирается ежедневно, высок шанс, что
	    она затронута уязвимостью.</para>
	</callout>

	<callout arearefs="co-corrected">
	  <para>Поле <literal>Corrected</literal> показывает дату, время,
	    смещение во времени и релиз, в котором исправлена ошибка.</para>
	</callout>

	<callout arearefs="co-only">
	  <para>Поле <literal>&os; only</literal> показывает, существует
	    ли эта уязвимость только в &os;, или затрагивает и другие
	    системы.</para>
	</callout>

	<callout arearefs="co-backround">
	  <para>Поле <literal>Background</literal> дает информацию именно
	    о той утилите, для которой выпущено сообщение.  Как правило
	    информация о том, зачем утилита присутствует в &os;, для
	    чего она используется, и немного информации о том, как
	    появилась эта утилита.</para>
	</callout>

	<callout arearefs="co-descript">
	  <para>Поле <literal>Problem Description</literal> дает более
	    глубокие разъяснения возникшей проблемы.  Оно может включать
	    информацию об ошибочном коде, или даже о том, как утилита
	    может быть использована для создания бреши в системе
	    безопасности.</para>
	</callout>

	<callout arearefs="co-impact">
	  <para>Поле <literal>Impact</literal> описывает тип воздействия,
	    который проблема может оказать на систему.  Это может быть
	    все, что угодно, от атаки на отказ в обслуживании до
	    получения пользователями дополнительных привилегий, или
	    даже получения атакующим прав суперпользователя.</para>
	</callout>

	<callout arearefs="co-workaround">
	  <para>Поле <literal>Workaround</literal> предлагает тем,
	    системным администраторам, которые не могут обновить систему,
	    обходной путь решения проблемы.  Он может пригодиться при
	    недостатке времени, отсутствии подключения к сети или по
	    массе других причин.  В любом случае, к безопасности нельзя
	    относиться несерьезно, и необходимо либо применить указанный
	    обходной путь, либо исправить систему.</para>
	</callout>

	<callout arearefs="co-solution">
	  <para>Поле <literal>Solution</literal> предлагает инструкции по
	    исправлению затронутой системы.  Это пошаговое руководство,
	    протестированный метод восстановления безопасности системы.</para>
	</callout>

	<callout arearefs="co-details">
	  <para>Поле <literal>Correction Details</literal> показывает
	    ветвь <acronym>CVS</acronym> (имя релиза с точками, замененными
	    на символы подчеркивания).  Здесь также показан номер ревизии
	    каждого файла из каждой ветви.</para>
	</callout>

	<callout arearefs="co-ref">
	  <para>Поле <literal>References</literal> обычно упоминает
	    другие источники информации.  Это могут быть веб страницы,
	    книги, списки рассылки и группы новостей.</para>
	</callout>
      </calloutlist>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

