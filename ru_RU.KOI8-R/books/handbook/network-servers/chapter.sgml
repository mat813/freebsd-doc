<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/network-servers/chapter.sgml,v 1.14 2004/10/28 09:04:33 marck Exp $

     Original revision: 1.33
-->

<chapter id="network-servers">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Murray</firstname>
	<surname>Stokely</surname>
	<contrib>Реорганизовал  </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Андрей</firstname>
	<surname>Захватов</surname>
	<contrib>Перевод на русский язык: </contrib>
      </author>
    </authorgroup>
    <!-- 23 July 2004 -->
  </chapterinfo>

  <title>Сетевые серверы</title>

  <sect1 id="network-servers-synopsis">
    <title>Краткий обзор</title>

    <para>Эта глава посвящена некоторым наиболее часто используемым сетевым
      службам систем &unix;.  Мы опишем, как установить, настроить,
      протестировать и поддерживать многие различные типы сетевых сервисов.
      Для облегчения вашей работы в главу включены
      примеры конфигурационных файлов.</para>

    <para>После чтения этой главы вы будете знать:</para>

    <itemizedlist>
      <listitem>
	<para>Как управлять даемоном <application>inetd</application>.</para>
      </listitem>

      <listitem>
	<para>Как настроить сетевую файловую систему.</para>
      </listitem>

      <listitem>
	<para>Как настроить сетевой сервер информации для совместного
	  использования учётных записей пользователей.</para>
      </listitem>

      <listitem>
	<para>Как настроить автоматическое конфигурирование сетевых параметров
	  при помощи DHCP.</para>
      </listitem>

      <listitem>
	<para>Как настроить сервер имён.</para>
      </listitem>

      <listitem>
	<para>Как настроить <application>Apache</application> HTTP
	  сервер.</para>
      </listitem>

      <listitem>
	<para>Как настроить файловый и принт сервер для &windows;
	  клиентов с использованием <application>Samba</application>.</para>
      </listitem>

      <listitem>
	<para>Как синхронизировать дату и время, а также настроить сервер
	  времени с протоколом NTP.</para>
      </listitem>
    </itemizedlist>

    <para>Перед чтением этой главы вы должны:</para>

    <itemizedlist>
      <listitem>
	<para>Понимать основы работы скриптов
	  <filename>/etc/rc</filename>.</para>
      </listitem>

      <listitem>
	<para>Свободно владеть основными сетевыми терминами.</para>
      </listitem>

      <listitem>
      <para>Знать как устанавливать дополнительные программы сторонних
	разработчиков (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="network-inetd">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Текст предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><quote>Супер-сервер</quote> <application>inetd</application></title>

    <sect2 id="network-inetd-overview">
      <title>Обзор</title>

      <para>&man.inetd.8; называют также <quote>супер-сервером
	Интернет</quote>, потому что он управляет соединениями к многим
	сервисам.  Когда
	<application>inetd</application> принимает соединение, он определяет,
	для какой программы предназначено соединение, запускает соответствующий
	процесс и предоставляет ему сокет, ссылка на который передается
	процессу в качестве стандартных уствойств ввода, вывода и сообщения об
	ошибках.  Запуск одного экземпляра
	<application>inetd</application> уменьшает общую нагрузку на систему по
	сравнению с запуском каждого даемона индивидуально в выделенном
	режиме.</para>

      <para>В первую очередь <application>inetd</application> используется для
	вызова других даемонов, но несколько простых протоколов, таких, как
	<application>chargen</application>, <application>auth</application> и
	<application>daytime</application>, обслуживаются
	непосредственно.</para>

      <para>Этот раздел посвящен основам настройки
	<application>inetd</application> посредством его параметров командной
	строки и его конфигурационного файла,
	<filename>/etc/inetd.conf</filename>.</para>
    </sect2>

    <sect2 id="network-inetd-settings">
      <title>Настройки</title>

      <para><application>inetd</application> инициализируется посредством
	системы <filename>/etc/rc.conf</filename>.  Параметр
	<literal>inetd_enable</literal> по умолчанию установлен в
	<literal>NO</literal>, однако часто включается утилитой
	<application>sysinstall</application> при выборе профиля среднего
	уровня безопасности.  Указание
	<programlisting>inetd_enable="YES"</programlisting> или
	<programlisting>inetd_enable="NO"</programlisting> в файле
	<filename>/etc/rc.conf</filename> может задать или запретить запуск
	<application>inetd</application> во время загрузки.</para>

      <para>Кроме того, через <literal>inetd_flags</literal> даемону
	<application>inetd</application> могут быть переданы различные
	параметры командной строки.</para>
    </sect2>

    <sect2 id="network-inetd-cmdline">
      <title>Параметры командной строки</title>

      <para>Формат вызова <application>inetd</application>:</para>

      <para><option>     inetd [-d] [-l] [-w] [-W] [-c maximum] [-C rate] [-a address | hostname]
	   [-p filename] [-R rate] [configuration file]</option></para>

      <variablelist>
	<varlistentry>
	  <term>-d</term>

	  <listitem>
	    <para>Включение отладочной информации.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-l</term>

	  <listitem>
	    <para>Включение регистрации успешных соединений.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-w</term>

	  <listitem>
	    <para>Включение механизма TCP Wrapping для внешних служб (по
	      умолчанию включено).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-W</term>

	  <listitem>
	    <para>Включение механизма TCP Wrapping для внутренних служб,
	      которые встроены в <application>inetd</application> (по
	      умолчанию включено).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-c maximum</term>

	  <listitem>
	    <para>Определение максимального числа одновременных запусков каждой
	      службы; по умолчание не ограничено.  Может быть переопределено
	      индивидуально для каждой службы при помощи параметра
	      <option>max-child</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-C rate</term>

	  <listitem>
	    <para>Определение по умолчанию максимального количества раз,
	      которое служба может быть вызвана с одного IP-адреса в минуту; по
	      умолчанию не ограничено.  Может быть переопределено для каждой
	      службы параметром
	      <option>max-connections-per-ip-per-minute</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-R rate</term>

	  <listitem>
	    <para>Определяет максимальное количество раз, которое служба может
	      быть вызвана в минуту; по умолчанию 256.  Частота, равная 0,
	      не ограничивает число вызовов.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-a</term>

	  <listitem>
	    <para>Задает один IP-адрес, к которому делается привязка.
	      Альтернативно может быть указано имя хоста, и в этом случае
	      используется соответствующий этому имени хоста адрес IPv4 или
	      IPv6.  Обычно имя хоста задается, когда
	      <application>inetd</application> запускается в окружении
	      &man.jail.8;, и в этом случае имя хоста соответствует этому
	      &man.jail.8;-окружению.</para>

	    <para>Если используется формат с именем хоста и требуется привязка
	      как для IPv4, так и для IPv6, то для каждой привязки требуется
	      запись с соответствующим типом протокола для каждой службы в
	      файле <filename>/etc/inetd.conf</filename>.  К примеру, службе
	      на основе TCP потребуется две записи, в одной для протокола
	      используется <literal>tcp4</literal>, а в другой
	      используется <literal>tcp6</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-p</term>

	  <listitem>
	    <para>Задает альтернативный файл для хранения ID процесса.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Эти параметры могут быть переданы в
	<application>inetd</application> при помощи
	<literal>inetd_flags</literal> в файле
    	<filename>/etc/rc.conf</filename>.  По умолчанию значение
	<literal>inetd_flags</literal> установлено в <literal>-wW</literal>,
	что включает механизм TCP wrapping для внутренних и внешних служб
	<application>inetd</application>.  Новичкам эти параметры изменять и
	даже задавать их в файле <filename>/etc/rc.conf</filename> не
	нужно.</para>

      <note>
	<para>Внешняя служба является даемоном вне
	  <application>inetd</application>, который запускается при получении
	  соединения к нему.  С другой стороны, внутренней службой является
	  услуга, которую <application>inetd</application> предоставляет
	  сам.</para>
      </note>
    </sect2>

    <sect2 id="network-inetd-conf">
      <title><filename>inetd.conf</filename></title>

      <para>Настройка <application>inetd</application> управляется через файл
	<filename>/etc/inetd.conf</filename>.</para>

      <para>Если в файле <filename>/etc/inetd.conf</filename> делались
	изменения, то <application>inetd</application> можно заставить считать
	его конфигурационный файл повторно, послав сигнал HangUP процессу
	<application>inetd</application>, как показано здесь:</para>

      <example id="network-inetd-hangup">
	<title>Посылка сигнала HangUP процессу
	  <application>inetd</application></title>

	<screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
      </example>

      <para>В каждой строке конфигурационного файла описывается отдельный
	даемон.  Комментариям в файле предшествует знак	<quote>#</quote>.  Файл
	<filename>/etc/inetd.conf</filename> имеет такой формат:</para>

      <programlisting>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]
user[:group][/login-class]
server-program
server-program-arguments</programlisting>

      <para>Пример записи для даемона <application>ftpd</application>,
	использующего IPv4:</para>

      <programlisting>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</programlisting>

      <variablelist>
	<varlistentry>
	  <term>service-name</term>

	  <listitem>
	    <para>Это имя сервиса, предоставляемого конкретным даемоном.  Оно
	      должно соответствовать сервису, указанному в файле
	      <filename>/etc/services</filename>.  Здесь определяется, какой
	      порт должен обслуживать <application>inetd</application>.  При
	      создании нового сервиса он должен помещаться сначала в файл
	      <filename>/etc/services</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>socket-type</term>

	  <listitem>
	    <para><literal>stream</literal>, <literal>dgram</literal>,
	      <literal>raw</literal> либо <literal>seqpacket</literal>.
	      <literal>stream</literal> должен использоваться для
	      ориентированных на соединение даемонов TCP, когда как
	      <literal>dgram</literal> используется для даемонов, использующих
	      транспортный протокол <acronym>UDP</acronym>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>protocol</term>

	  <listitem>
	    <para>Одно из следующих:</para>

	    <informaltable frame="none">
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry>Протокол</entry>
		    <entry>Описание</entry>
		  </row>
		</thead>
		<tbody>
		  <row>
		    <entry>tcp, tcp4</entry>
		    <entry>TCP IPv4</entry>
		  </row>

		  <row>
		    <entry>udp, udp4</entry>
		    <entry>UDP IPv4</entry>
		  </row>

		  <row>
		    <entry>tcp6</entry>
		    <entry>TCP IPv6</entry>
		  </row>

		  <row>
		    <entry>udp6</entry>
		    <entry>UDP IPv6</entry>
		  </row>

		  <row>
		    <entry>tcp46</entry>
		    <entry>TCP как для IPv4, так и для v6</entry>
		  </row>

		  <row>
		    <entry>udp46</entry>
		    <entry>UDP как для IPv4, так и для v6</entry>
		  </row>
		</tbody>
	      </tgroup>
	    </informaltable>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]</term>

	  <listitem>
	    <para><option>wait|nowait</option> определяет, может ли даемон,
	      вызванный из <application>inetd</application>, работать с
	      собственным сокетом, или нет.  Сокеты типа <option>dgram</option>
	      должны использовать параметр <option>wait</option>, когда как
	      даемоны с потоковыми
	      сокетами, которые обычно многопоточны, должны использовать
	      <option>nowait</option>.  <option>wait</option> обычно передает
	      много сокетов одному даемону, когда как <option>nowait</option>
	      порождает даемон для каждого нового сокета.</para>

	    <para>Максимальное число порожденных даемонов, которых может
	      создать <application>inetd</application>, может быть задано
	      параметром <option>max-child</option>.  Если нужно ограничение в
	      десять экземпляров некоторого даемона, то после параметра
	      <option>nowait</option> нужно задать
	      <literal>/10</literal>.</para>

	    <para>Кроме <option>max-child</option>, может быть задействован
	      другой параметр, ограничивающий максимальное число соединений от
	      одного источника.
	      <option>max-connections-per-ip-per-minute</option> служит именно
	      для этого.  Здесь значение, равное десяти, будет ограничивать
	      любой заданный IP-адрес на выполнение десяти попыток подключения
	      к некоторому сервису в минуту.  Это полезно для предотвращения
	      намеренного или ненамеренного расходования ресурсов и атак типа
	      Denial of Service (DoS) на машину.</para>

	    <para>В этом поле <option>wait</option> или <option>nowait</option>
	      обязательны.  <option>max-child</option> и
	      <option>max-connections-per-ip-per-minute</option>
	      опциональны.</para>

	    <para>Многопоточный даемон типа stream без ограничений
	      <option>max-child</option> или
	      <option>max-connections-per-ip-per-minute</option> будет
	      определен просто вот так: <literal>nowait</literal>.</para>

	    <para>Тот же самый даемон с ограничением в максимум десять даемонов
	      будет определен так: <literal>nowait/10</literal>.</para>

	    <para>Наконец, та же конфигурация с ограничением в двадцать
	      соединений на IP-адрес в минуту и общим ограничением в максимум
	      десять порожденных даемонов выглядит так:
	      <literal>nowait/10/20</literal>.</para>

	    <para>Эти параметры, используемые все со значениями по умолчанию
	      даемоном <application>fingerd</application>, имеют такой
	      вид:</para>

	    <programlisting>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</programlisting>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>user</term>

	  <listitem>
	    <para>Это имя пользователя, под которым должен
	      работать соответствующий даемон.  Чаще всего даемоны работают
	      как пользователь <username>root</username>.  Для обеспечения
	      безопасности некоторые серверы запускаются как пользователь
	      <username>daemon</username> или как пользователь с минимальными
	      правами <username>nobody</username>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program</term>

	  <listitem>
	    <para>Полный маршрут к даемону, который будет выполняться при
	      установлении соединения.  Если даемон является сервисом,
	      предоставляемым самим <application>inetd</application>, то нужно
	      задать ключевое слово <option>internal</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program-arguments</term>

	  <listitem>
	    <para>Этот параметр работает вместе с параметром
	      <option>server-program</option>, задавая параметры, начиная с
	      <literal>argv[0]</literal>, передаваемые даемону при запуске.
	      Если в командной
	      строке задано <command>mydaemon -d</command>, то
	      <literal>mydaemon -d</literal> будет являться значением для
	      <option>server-program-arguments</option>.  И снова, если даемон
	      является внутренней службой, то здесь нужно использовать
	      <option>internal</option>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="network-inetd-security">
      <title>Безопасность</title>

      <para>В зависимости от схемы безопасности, выбранной при установке,
	многие из даемонов <application>inetd</application> могут оказаться по
	умолчанию включенными.  Если нет особой нужды в некотором даемоне, то
	выключите его!  Поместите знак <quote>#</quote> перед ненужным даемоном
	в <filename>/etc/inetd.conf</filename>
	и <link linkend="network-inetd-hangup">пошлите сигнал для inetd</link>.
	Некоторые даемоны, такие, как <application>fingerd</application>,
	вообще нежелательны, потому что они дают атакующему слишком много
	информации.</para>

      <para>Некоторые даемоны не заботятся о безопасности и имеют большие
	таймауты для соединений или вообще их не имеют.  Это позволяет
	атакующему неспешно устанавливать соединения к конкретному даемону,
	истощая имеющиеся ресурсы.  Может оказаться полезным задать для
	некоторых даемонов ограничения
	<option>max-connections-per-ip-per-minute</option> и
	<option>max-child</option>.</para>

      <para>По умолчанию механизм TCP wrapping включен.  Обратитесь к
	справочной странице по &man.hosts.access.5; для получения более
	подробной информации о задании ограничений TCP для различных даемонов,
	запускаемых посредством <application>inetd</application>.</para>
    </sect2>

    <sect2 id="network-inetd-misc">
      <title>Разное</title>

      <para><application>daytime</application>,
	<application>time</application>,
	<application>echo</application>,
	<application>discard</application>,
	<application>chargen</application> и
	<application>auth</application> все являются услугами, предоставляемыми
	самим <application>inetd</application>.</para>

      <para>Сервис <application>auth</application> предоставляет
	идентификационные сетевые услуги
	(<application>ident</application>, <application>identd</application>)
	и поддается настройке.</para>

      <para>Обратитесь к справочной странице по &man.inetd.8; для получения
	более подробной информации.</para>
    </sect2>
  </sect1>

  <sect1 id="network-nfs">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Реорганизация и улучшения </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Swingle</surname>
	  <contrib>Текст создал </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Network File System (NFS)</title>

    <indexterm><primary>NFS</primary></indexterm>
    <para>Кроме поддержки многих прочих типов файловых систем, во FreeBSD
      встроена поддержка сетевой файловой системы (Network File System),
      известной как <acronym role="Network
      File System">NFS</acronym>.  <acronym role="Network File
      System">NFS</acronym> позволяет
      системе использовать каталоги и файлы совместно с другими машинами,
      посредством сети.  Посредством <acronym role="Network File
      System">NFS</acronym> пользователи и
      программы могут получать доступ к файлам на удалённых системах точно так
      же, как если бы это были файлы на собственных дисках.</para>

    <para>Вот некоторые из наиболее заметных преимуществ, которые даёт
      использование <acronym>NFS</acronym>:</para>

    <itemizedlist>
      <listitem>
	<para>Отдельно взятые рабочие станции используют меньше собственного
	  дискового пространства, так как совместно используемые данные могут
	  храниться на одной отдельной машине и быть доступными для других
	  машин в сети.</para>
      </listitem>

      <listitem>
	<para>Пользователям не нужно иметь домашние каталоги, отдельные
	  для каждой машины в вашей сети.  Домашние каталоги могут
	  располагаться на сервере <acronym>NFS</acronym> и их можно сделать
	  доступными отовсюду в сети.</para>
      </listitem>

      <listitem>
	<para>Устройства хранения информации, такие, как дискеты, приводы
	  CD-ROM и устройства &iomegazip;, могут использоваться другими машинами в
	  сети.  Это может привести к уменьшению переносимых устройств хранения
	  информации в сети.</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Как работает <acronym>NFS</acronym></title>

      <para><acronym>NFS</acronym> строится по крайней мере из двух основных
	частей: сервера и одного или большего количества клиентов.  Клиент
	обращается к данным, находящимся на сервере, в режиме удалённого
	доступа.  Для того, чтобы это нормально функционировало, нужно
	настроить и запустить несколько процессов.</para>

      <note>
	<para>В &os; 5.X, утилита <application>portmap</application> была
	  заменена на утилиту <application>rpcbind</application>.
	  Таким образом, при
	  использовании &os; 5.X пользователю необходимо заменить в
	  последующих примерах все команды <application>portmap</application>
	  на <application>rpcbind</application>.</para>
      </note>

      <para>На сервере работают следующие даемоны:</para>

      <indexterm>
	<primary>NFS</primary>
	<secondary>сервер</secondary>
      </indexterm>
      <indexterm>
	<primary>файл сервер</primary>
	<secondary>unix клиенты</secondary>
      </indexterm>

      <indexterm>
	<primary><application>portmap</application></primary>
      </indexterm>

      <indexterm>
	<primary><application>mountd</application></primary>
      </indexterm>

      <indexterm>
	<primary><application>nfsd</application></primary>
      </indexterm>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="3*">
	  <thead>
	    <row>
	      <entry>Даемон</entry>
	      <entry>Описание</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><application>nfsd</application></entry>
	      <entry>Даемон <acronym>NFS</acronym>, обслуживающий запросы от
		клиентов <acronym>NFS</acronym>.</entry>
	    </row>

	    <row>
	      <entry><application>mountd</application></entry>
	      <entry>Даемон монтирования <acronym>NFS</acronym>, который
		выполняет запросы, передаваемые ему от &man.nfsd.8;.</entry>
	    </row>

	    <row>
	      <entry><application>portmap</application></entry>
	      <entry>Даемон отображения портов позволяет клиентам
		<acronym>NFS</acronym> определить порт, используемый сервером
		<acronym>NFS</acronym>.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Клиент может запустить также даемон, называемый
	<application>nfsiod</application>.  <application>nfsiod</application>
	обслуживает запросы, поступающие от сервера от сервера
	<acronym>NFS</acronym>.  Он необязателен, увеличивает
	производительность, однако для нормальной и правильной работы не
	требуется.  Для получения дополнительной информации обратитесь к
	разделу справочной системы о &man.nfsiod.8;.</para>
    </sect2>

    <sect2 id="network-configuring-nfs">
      <title>Настройка <acronym>NFS</acronym></title>

      <indexterm>
	<primary>NFS</primary>
	<secondary>настройка</secondary>
      </indexterm>

      <para>Настройка <acronym>NFS</acronym> является достаточно незамысловатым
	процессом.  Все процессы, которые должны быть запущены, могут быть
	запущены во время загрузки посредством нескольких модификаций в
	вашем файле <filename>/etc/rc.conf</filename>.</para>

      <para>Проверьте, что на <acronym>NFS</acronym>-сервере в файле
	<filename>/etc/rc.conf</filename> имеются такие строки:</para>

      <programlisting>portmap_enable="YES"
nfs_server_enable="YES"
nfs_server_flags="-u -t -n 4"
mountd_flags="-r"</programlisting>

      <para><application>mountd</application> запускается автоматически, если включена
	функция сервера <acronym>NFS</acronym>.</para>

      <para>На клиенте убедитесь, что в файле <filename>/etc/rc.conf</filename>
	присутствует такой параметр:</para>

      <programlisting>nfs_client_enable="YES"</programlisting>

      <para>Файл <filename>/etc/exports</filename> определяет, какие
	файловые системы на вашем сервере <acronym>NFS</acronym> будут
	экспортироваться (иногда их называют <quote>совместно
	используемыми</quote>).  Каждая строка в
	<filename>/etc/exports</filename> задаёт файловую систему, которая
	будет экспортироваться и какие машины будут иметь к ней доступ.  Кроме
	машин, имеющих доступ, могут задаваться другие параметры, влияющие на
	характеристики доступа.  Имеется полный набор параметров,
	которые можно использовать, но здесь пойдёт речь лишь о некоторых из
	них.  Описания остальных параметров можно найти на страницах справочной
	системы по &man.exports.5;.</para>

      <para>Вот несколько примерных строк из файла
	<filename>/etc/exports</filename>:</para>

      <indexterm>
	<primary>NFS</primary>
	<secondary>примеры экспортирования</secondary>
      </indexterm>

      <para>В следующих примерах даётся общая идея того, как экспортировать
	файловые системы, хотя конкретные параметры могут отличаться в
	зависимости от ваших условий и конфигурации сети.  К примеру, чтобы
	экспортировать каталог <filename>/cdrom</filename> для трёх машин,
	находящихся в том же самом домене, что и сервер (поэтому отсутствует
	доменное имя для каждой машины) или для которых имеются записи в
	файле <filename>/etc/hosts</filename>.  Флаг <option>-ro</option>
	указывает на использование экспортируемой файловой
	системы в режиме только чтения.  С этим флагом удалённая система не
	сможет никоим образом изменить экспортируемую файловую систему.</para>

      <programlisting>/cdrom -ro host1 host2 host3</programlisting>

      <para>В следующей строке экспортируется файловая система
	<filename>/home</filename>, которая становится доступной трем хостам,
	указанным по их IP-адресам.  Это полезно, если у вас есть собственная
	сеть без настроенного сервера <acronym>DNS</acronym>.  Как вариант,
	файл <filename>/etc/hosts</filename> может содержать внутренние имена
	хостов; пожалуйста, обратитесь к справочную систему по &man.hosts.5;
	для получения дополнительной информации.  Флаг
	<option>-alldirs</option> позволяет рассматривать подкаталоги в
	качестве точек монтирования.  Другими словами, это не монтирование
	подкаталогов, но разрешение клиентам монтировать только каталоги,
	которые им требуются или нужны.</para>

      <programlisting>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

      <para>В строке, приведённой ниже, файловая система
	<filename>/a</filename> экспортируется таким образом, что она доступна
	двум клиентам из других доменов.  Параметр
	<option>-maproot=root</option> позволяет пользователю
	<username>root</username> удалённой системы осуществлять запись на
	экспортируемую файловую систему как пользователь
	<username>root</username>.  Если параметр
	<literal>-maproot=root</literal> не задан,
	то даже если пользователь имеет права доступа <username>root</username>
	на удалённой системе, он не сможет модифицировать
	файлы на экспортированной файловой системе.</para>

      <programlisting>/a  -maproot=root  host.example.com box.example.org</programlisting>

      <para>Для того, чтобы клиент смог обратиться к экспортированной файловой
	системе, он должен иметь права сделать это.  Проверьте, что клиент
	указан в вашем файле <filename>/etc/exports</filename>.</para>

      <para>В файле <filename>/etc/exports</filename> каждая строка содержит
	информацию об экспортировании для отдельной файловой системы для
	отдельно взятого хоста.  Удалённый хост может быть задан только
	один раз для каждой файловой системы, и может иметь
	только одну запись, используемую по умолчанию, для каждой локальной
	файловой системы.  К примеру, предположим, что
	<filename>/usr</filename> является отдельной файловой системой.
	Следующий <filename>/etc/exports</filename> будет некорректен:</para>

      <programlisting>/usr/src   client
/usr/ports client</programlisting>

      <para>Одна файловая система, <filename>/usr</filename>, имеет две
	строки, задающие экспортирование для одного и того же хоста,
	<hostid>client</hostid>.  Правильный формат в этом случае таков:</para>

      <programlisting>/usr/src /usr/ports  client</programlisting>

      <para>Свойства отдельной файловой системы, экспортируемой некоторому
	хосту, должны задаваться в одной строке.  Строки без указания клиента
	воспринимаются как отдельный хост.  Это ограничивает то, как вы можете
	экспортировать файловые системы, но для большинства это не
	проблема.</para>

      <para>Ниже приведён пример правильного списка экспортирования, где
	<filename>/usr</filename> и <filename>/exports</filename> являются
	локальными файловыми системами:</para>

      <programlisting># Экспортируем src и ports для client01 и client02, но
# только client01 имеет права пользователя root на них
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports	       client02
# Клиентские машины имеют пользователя root и могут монтировать всё в
# каталоге /exports.  Кто угодно может монтировать /exports/obj в режиме чтения
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</programlisting>

      <para>Вы должны перезапустить <application>mountd</application> после того, как
	изменили <filename>/etc/exports</filename>, чтобы изменения вступили в
	силу.  Это может быть достигнуто посылкой сигнала HUP процессу
	<command>mountd</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>

      <para>Как вариант, при перезагрузке FreeBSD всё настроится правильно.
	Хотя выполнять перезагрузку вовсе не обязательно.  Выполнение следующих
	команд пользователем <username>root</username> запустит всё, что
	нужно.</para>

      <para>На сервере <acronym>NFS</acronym>:</para>

      <screen>&prompt.root; <userinput>portmap</userinput>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput></screen>

      <para>На клиенте <acronym>NFS</acronym>:</para>

      <screen>&prompt.root; <userinput>nfsiod -n 4</userinput></screen>

      <para>Теперь всё должно быть готово к реальному монтированию удалённой
	файловой системы.  В приводимых примерах сервер будет носить имя
	<hostid>server</hostid>, а клиент будет носить имя
	<hostid>client</hostid>.  Если вы только хотите
	временно смонтировать удалённую файловую систему, или всего лишь
	протестировать ваши настройки, то просто запустите команды, подобные
	приводимым здесь, работая как пользователь <username>root</username> на
	клиентской машине:</para>

      <indexterm>
	<primary>NFS</primary>
	<secondary>монтирование</secondary>
      </indexterm>

      <screen>&prompt.root; <userinput>mount server:/home /mnt</userinput></screen>

      <para>По этой команде файловая система <filename>/home</filename> на
	сервере будет смонтирована в каталог <filename>/mnt</filename> на
	клиенте.  Если всё настроено правильно, вы сможете войти в каталог
	<filename>/mnt</filename> на клиенте и увидеть файлы, находящиеся на
	сервере.</para>

      <para>Если вы хотите автоматически монтировать удалённую файловую
	систему при каждой загрузке компьютера, добавьте файловую систему в
	<filename>/etc/fstab</filename>.  Вот пример:</para>

      <programlisting>server:/home	  /mnt	  nfs	  rw	  0	  0</programlisting>

      <para>На страницах справочной системы по &man.fstab.5; перечислены все
	доступные параметры.</para>
    </sect2>

    <sect2>
      <title>Практическое использование</title>

      <para>У <acronym>NFS</acronym> есть много вариантов практического
	применения.  Ниже приводится несколько наиболее широко распространённых
	способов её использования:</para>

      <indexterm>
	<primary>NFS</primary>
	<secondary>использование</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>Настройка несколько машин для совместного использования CDROM
	    или других носителей.  Это более дешёвый и зачастую более удобный
	    способ установки программного обеспечения на несколько машин.</para>
	</listitem>

	<listitem>
	  <para>В больших сетях может оказаться более удобным настроить
	    центральный сервер <acronym>NFS</acronym>, на котором размещаются
	    все домашние каталоги пользователей.  Эти домашние каталоги могут
	    затем экспортироваться в сеть так, что пользователи всегда будут
	    иметь один и тот же домашний каталог вне зависимости от того, на
	    какой рабочей станции они работают.</para>
	</listitem>

	<listitem>
	  <para>Несколько машин могут иметь общий каталог
	    <filename>/usr/ports/distfiles</filename>.  Таким образом, когда
	    вам нужно будет установить порт на несколько машин, вы сможете быстро
	    получить доступ к исходным текстам без их загрузки на каждой
	    машине.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="network-amd">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Wylie</firstname>
	    <surname>Stilwell</surname>
	    <contrib>Текст предоставил </contrib>
	  </author>
	</authorgroup>

	<authorgroup>
	  <author>
	    <firstname>Chern</firstname>
	    <surname>Lee</surname>
	    <contrib>Текст переписал </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Автоматическое монтирование с
	<application>amd</application></title>

      <indexterm>
	<primary>amd</primary>
      </indexterm>

      <indexterm>
	<primary>даемон автоматического монтирования</primary>
      </indexterm>

      <para>&man.amd.8; (даемон автоматического монтирования) автоматически
	монтирует удалённую файловую систему,
	как только происходит обращение к файлу или каталогу в этой файловой
	системе.  Кроме того, файловые системы, которые были неактивны
	некоторое время, будут автоматически размонтированы даемоном
  	<application>amd</application>.  Использование
	<application>amd</application> является простой альтернативой
	статическому монтированию, так как в последнем случае обычно всё должно
	быть описано в файле <filename>/etc/fstab</filename>.</para>

      <para><application>amd</application> работает, сам выступая как сервер
	NFS для каталогов <filename>/host</filename> и
	<filename>/net</filename>.  Когда происходит обращение к файлу в одном
	из этих каталогов, <application>amd</application> ищет соответствующий
	удаленный ресурс для монтирования и автоматически его монтирует.
	<filename>/net</filename> используется для монтирования экспортируемой
	файловой системы по адресу IP, когда как каталог
	<filename>/host</filename> используется для монтирования ресурса по
	удаленному имени хоста.</para>

      <para>Обращение к файлу в каталоге
	<filename>/host/foobar/usr</filename> укажет
	<application>amd</application> на выполнение попытки монтирования
	ресурса	<filename>/usr</filename>, который находится на хосте
	<hostid>foobar</hostid>.</para>

      <example>
	<title>Монтирование ресурса при помощи
	  <application>amd</application></title>

	<para>Вы можете посмотреть доступные для монтирования ресурсы
	  отдалённого хоста командой <command>showmount</command>.  К примеру,
	  чтобы посмотреть ресурсы хоста с именем <hostid>foobar</hostid>, вы
	  можете использовать:</para>

	<screen>&prompt.user; <userinput>showmount -e foobar</userinput>
Exports list on foobar:
/usr			       10.10.10.0
/a				 10.10.10.0
&prompt.user; <userinput>cd /host/foobar/usr</userinput></screen>
      </example>

      <para>Как видно из примера, <command>showmount</command> показывает
	<filename>/usr</filename> как экспортируемый ресурс.  При переходе в
	каталог	<filename>/host/foobar/usr</filename> даемон
	<application>amd</application> пытается разрешить имя хоста
	<hostid>foobar</hostid> и автоматически смонтировать требуемый
	ресурс.</para>

      <para><application>amd</application> может быть запущен из скриптов
	начальной загрузки, если поместить такую строку в файл
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>amd_enable="YES"</programlisting>

      <para>Кроме того, даемону <application>amd</application> могут быть
	переданы настроечные флаги через параметр
	<varname>amd_flags</varname>.  По умолчанию
	<varname>amd_flags</varname> настроен следующим образом:</para>

      <programlisting>amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"</programlisting>

      <para>Файл <filename>/etc/amd.map</filename> задает опции, используемые
	по умолчанию при монтировании экспортируемых ресурсов.  В файле
	<filename>/etc/amd.conf</filename> заданы настройки некоторых более
	сложных возможностей <application>amd</application>.</para>

      <para>Обратитесь к справочным страницам по &man.amd.8; и &man.amd.conf.5;
	для получения более полной информации.</para>
    </sect2>

    <sect2 id="network-nfs-integration">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>John</firstname>
	    <surname>Lind</surname>
	    <contrib>Текст предоставил </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Проблемы взаимодействия с другими системами</title>

      <para>Некоторые сетевые адаптеры для систем PC с шиной ISA имеют
	ограничения, которые могут привести к серьезным проблемам в сети, в
	частности, с NFS.  Эти проблемы не специфичны для FreeBSD, однако
	эту систему они затрагивают.</para>

      <para>Проблема, которая возникает практически всегда при работе по сети
	систем PC (FreeBSD) с высокопроизводительными рабочими станциями,
	выпущенными такими производителями, как Silicon Graphics, Inc. и Sun
	Microsystems, Inc.  Монтирование по протоколу NFS будет работать
	нормально, и некоторые операции также будут выполняться успешно, но
	неожиданно сервер окажется недоступным для клиент, хотя запросы к и
	от других систем будут продолжаться обрабатываться.  Такое встречается
	с клиентскими системами, не зависимо от того, является ли клиент
	машиной с FreeBSD или рабочей станцией.  Во многих системах при
	возникновении этой проблемы нет способа корректно завершить работу
	клиента.  Единственным выходом зачастую является холодная перезагрузка
	клиента, потому что ситуация с NFS не может быть разрешена.</para>

      <para>Хотя <quote>правильным</quote> решением является установка более
	производительного и скоростного сетевого адаптера на систему FreeBSD,
	имеется простое решение, приводящее к удовлетворительным результатам.
	Если система FreeBSD является <emphasis>сервером</emphasis>, укажите
	параметр <option>-w=1024</option> на клиенте при монтировании.  Если
	система FreeBSD является <emphasis>клиентом</emphasis>, то смонтируйте
	файловую систему NFS с параметром <option>-r=1024</option>.  Эти
	параметры могут быть заданы в четвертом поле записи в файле
	<filename>fstab</filename> клиента при автоматическом монтировании,
	или при помощи параметра <option>-o</option> в команде &man.mount.8; при
	монтировании вручную.</para>

      <para>Нужно отметить, что имеется также другая проблема, ошибочно
	принимаемая за приведенную выше, когда серверы и клиенты NFS находятся
	в разных сетях.  Если это тот самый случай,
	<emphasis>проверьте</emphasis>, что ваши маршрутизаторы пропускают
	нужную информацию <acronym>UDP</acronym>, в противном случае вы
	ничего не получите, что бы вы ни предпринимали.</para>

      <para>В следующих примерах <hostid>fastws</hostid> является именем хоста
	(интерфейса) высокопроизводительной рабочей станции, а
	<hostid>freebox</hostid> является именем хоста (интерфейса) системы
	FreeBSD со слабым сетевым адаптером.  Кроме того,
	<filename>/sharedfs</filename> будет являться экспортируемой через NFS
	файловой системой (обратитесь к страницам справочной системы по команде
	&man.exports.5;), а <filename>/project</filename> будет точкой
	монтирования экспортируемой файловой системы на клиенте.  В любом
	случае, отметьте, что для вашего приложения могут понадобиться
	дополнительные параметры, такие, как <option>hard</option>,
	<option>soft</option> или <option>bg</option>.</para>

      <para>Пример системы FreeBSD (<hostid>freebox</hostid>) как клиента
	в файле <filename>/etc/fstab</filename> на машине
	<hostid>freebox</hostid>:</para>

      <programlisting>fastws:/sharedfs /project nfs rw,-r=1024 0 0</programlisting>

      <para>Команда, выдаваемая вручную на машине
	<hostid>freebox</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sharedfs /project</userinput></screen>

      <para>Пример системы FreeBSD в качестве сервера в файле
	<filename>/etc/fstab</filename> на машине
	<hostid>fastws</hostid>:</para>

      <programlisting>freebox:/sharedfs /project nfs rw,-w=1024 0 0</programlisting>

      <para>Команда, выдаваемая вручную на машине
	<hostid>fastws</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sharedfs /project</userinput></screen>

      <para>Практически все 16-разрядные сетевые адаптеры позволят работать
	без указанных выше ограничений на размер блоков при чтении и
	записи.</para>

      <para>Для тех, кто интересуется, ниже описывается, что же происходит в
	при появлении этой ошибки, и объясняется, почему ее невозможно
	устранить.  Как правило, NFS работает с <quote>блоками</quote> размером
	8&nbsp;килобайт (хотя отдельные фрагменты могут иметь меньшие
	размеры).  Так, пакет Ethernet имеет максимальный размер около
	1500&nbsp;байт, то
	<quote>блок</quote> NFS разбивается на несколько пакетов Ethernet, хотя
	на более высоком уровне это все тот же единый блок, который должен быть
	принят, собран и <emphasis>подтвержден</emphasis> как один блок.
	Высокопроизводительные рабочие станции могут посылать пакеты, которые
	соответствуют одному блоку NFS, сразу друг за другом, насколько это
	позволяет делать стандарт.  На слабых, низкопроизводительных адаптерах
	пакеты, пришедшие позже, накладываются поверх ранее пришедших пакетов
	того же самого блока до того, как они могут быть переданы хосту и
	блок как единое целое не может быть собран или подтвержден.  В
	результате рабочая станция входит в ситуацию таймаута и пытается
	повторить передачу, но уже с полным блоком в 8&nbsp;КБ, и процесс будет
	повторяться снова, до бесконечности.</para>

      <para>Задав размер блока меньше размера пакета Ethernet, мы достигаем
	того, что любой полностью полученный пакет Ethernet может быть
	подтвержден индивидуально, и избежим тупиковую ситуацию.</para>

      <para>Наложение пакетов может все еще проявляться, когда
	высокопроизводительные рабочие станции сбрасывают данные на PC-систему,
	однако повторение этой ситуации не обязательно с более скоростными
	адаптерами с <quote>блоками</quote> NFS.  Когда происходит наложение,
	затронутые блоки будут переданы снова, и скорее всего, они будут
	получены, собраны и подтверждены.</para>
    </sect2>
  </sect1>

  <sect1 id="network-nis">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Swingle</surname>
	  <contrib>Текст создал </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Ogren</surname>
	  <contrib>Внёс добавления </contrib>
	</author>
	<author>
	  <firstname>Udo</firstname>
	  <surname>Erdelhoff</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>Network Information System (NIS/YP)</title>

    <sect2>
      <title>Что это такое?</title>

      <indexterm><primary>NIS</primary></indexterm>
      <indexterm><primary>Solaris</primary></indexterm>
      <indexterm><primary>HP-UX</primary></indexterm>
      <indexterm><primary>AIX</primary></indexterm>
      <indexterm><primary>Linux</primary></indexterm>
      <indexterm><primary>NetBSD</primary></indexterm>
      <indexterm><primary>OpenBSD</primary></indexterm>

      <para><acronym role="Network Information System">NIS</acronym>,
	что является сокращением от Network Information Services
	(Сетевые Информационные Службы), которые были разработаны компанией
	Sun Microsystems для централизованного администрирования систем &unix;
	(изначально &sunos;).  В настоящее время эти службы практически стали
	промышленным стандартом; все основные &unix;-подобные системы
	(&solaris;, HP-UX, &aix;, Linux, NetBSD, OpenBSD, FreeBSD и так далее)
	поддерживают <acronym role="Network Information
	System">NIS</acronym>.</para>

      <indexterm>
	<primary>yellow pages</primary>
	<see>NIS</see>
      </indexterm>

      <para><acronym role="Network Information System">NIS</acronym>
	первоначально назывались Yellow Pages (или yp), но из-за
	проблем с торговым знаком Sun изменила это название.  Старое название
	(и yp) всё ещё часто употребляется.</para>

      <indexterm>
	<primary>NIS</primary>
	<secondary>домены</secondary>
      </indexterm>

      <para>Это система клиент/сервер на основе вызовов RPC, которая позволяет
	группе машин в одном домене NIS совместно использовать общий набор
	конфигурационных файлов.  Системный администратор может настроить
	клиентскую систему NIS только с минимальной настроечной информацией, а
	затем добавлять, удалять и модифицировать настроечную информацию из
	одного места.</para>

      <indexterm><primary>Windows NT</primary></indexterm>

      <para>Это похоже на систему доменов &windowsnt;; хотя их внутренние
	реализации не так уж и похожи, основные функции сравнимы.</para>
    </sect2>

    <sect2>
      <title>Термины/программы, о которых вы должны знать</title>

      <para>Существует несколько терминов и некоторое количество
	пользовательских программ, которые будут нужны, когда вы будете
	пытаться сделать NIS во FreeBSD, и в случае создания сервера, и
	в случае работы в качестве клиента NIS:</para>

      <indexterm>
	<primary><application>portmap</application></primary>
      </indexterm>

      <informaltable frame="none" pgwide="1">
 	<tgroup cols="2">
	<colspec colwidth="1*">
	<colspec colwidth="3*">
	  <thead>
	    <row>
	      <entry>Термин</entry>
	      <entry>Описание</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Имя домена NIS</entry>

	      <entry>Главный сервер NIS и все его клиенты (включая вторичные
		серверы), имеют доменное имя NIS.  Как и в случае с именем
		домена &windowsnt;, имя домена NIS не имеет ничего общего с
		DNS.</entry>
	    </row>

	    <row>
	      <entry><application>portmap</application></entry>

	      <entry>Для обеспечения работы RPC (Remote Procedure Call,
		Удалённого Вызова Процедур, сетевого протокола, используемого
		NIS), должен быть запущен даемон <application>portmap</application>.
		Если даемон <application>portmap</application> не запущен, невозможно
		будет запустить сервер NIS, или работать как
		NIS-клиент.</entry>
	    </row>

	    <row>
	      <entry><application>ypbind</application></entry>

	      <entry><quote>Связывает</quote>
		NIS-клиента с его NIS-сервером.  Он определяет имя NIS-домена
		системы, и при помощи RPC подключается к серверу.
		<application>ypbind</application> является основой клиент-серверного
		взаимодействия в среде NIS; если на клиентской машине
		программа <application>ypbind</application> перестанет работать, то
		эта машина не сможет получить доступ к серверу NIS.</entry>
	    </row>

	    <row>
	      <entry><application>ypserv</application></entry>

	      <entry>Программа <command>ypserv</command>, которая должна
		запускаться только на серверах NIS: это и есть
		сервер NIS.  Если &man.ypserv.8; перестанет работать, то
		сервер не сможет отвечать на запросы NIS (к счастью, на этот
		случай предусмотрен вторичный сервер).  Есть несколько
		реализаций NIS (к FreeBSD это не относится), в которых не
		производится попыток подключиться к другому серверу, если ранее
		используемый сервер перестал работать.  Зачастую единственным
		средством, помогающим в этой ситуации, является перезапуск
		серверного процесса (или сервера полностью) или процесса
		<application>ypbind</application> на клиентской машине.</entry>
	    </row>

	    <row>
	      <entry><application>rpc.yppasswdd</application></entry>

	      <entry>Программа <command>rpc.yppasswdd</command>, другой
		процесс, который запускается только на главных NIS-серверах:
		это даемон, позволяющий клиентам NIS изменять свои
		пароли NIS.  Если этот даемон не запущен, то пользователи
		должны будут входить на основной сервер NIS и там менять свои
		пароли.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <!-- XXX Отсутствует: rpc.ypxfrd (хотя это не очень важно) Может
	   работать только на основном сервере -->
    </sect2>

  <sect2>
    <title>Как это работает?</title>

    <para>В системе NIS существует три типа хостов: основные (master)
      серверы, вторичные (slave) серверы и клиентские машины.  Серверы
      выполняют роль централизованного хранилища информации о конфигурации
      хостов.  Основные серверы хранят оригиналы этой информации, когда как
      вторичные серверы хранят ее копию для обеспечения избыточности.
      Клиенты связываются с серверами, чтобы предоставить им эту
      информацию.</para>

    <para>Информация во многих файлах может совместно использоваться
      следующим образом.  Файлы <filename>master.passwd</filename>,
      <filename>group</filename> и <filename>hosts</filename> используются
      совместно через NIS.  Когда процессу, работающему на клиентской машине,
      требуется информация, как правило, находящаяся в этих файлах локально,
      то он делает запрос к серверу NIS, с которым связан.</para>

    <sect3>
      <title>Типы машин</title>

      <itemizedlist>
	<indexterm>
	  <primary>NIS</primary>
	  <secondary>главный сервер</secondary>
	</indexterm>

	<listitem>
	  <para><emphasis>Основной сервер NIS</emphasis>.
	    Такой сервер, по аналогии с первичным контроллером домена
	    &windowsnt;, хранит файлы, используемые всеми клиентами NIS.  Файлы
	    <filename>passwd</filename>, <filename>group</filename> и
	    различные другие файлы, используемые клиентами NIS, находятся
	    на основном сервере.</para>

	  <note>
	    <para>Возможно использование одной машины в качестве сервера для
	      более чем одного домена NIS.  Однако, в этом введении такая
	      ситуация не рассматривается, и предполагается менее масштабное
	      использование NIS.</para>
	  </note>
	</listitem>

	<indexterm>
	  <primary>NIS</primary>
	  <secondary>вторичный сервер</secondary>
	</indexterm>
	<listitem>
	  <para><emphasis>Вторичные серверы NIS</emphasis>.  Похожие на
	    вторичные контроллеры доменов &windowsnt;, вторичные серверы
	    NIS содержат копии оригинальных файлов данных NIS.	Вторичные
	    серверы NIS обеспечивают избыточность, что нужно в критичных
	    приложениях.  Они также помогают распределять нагрузку на
	    основной сервер: клиенты NIS всегда подключаются к тому серверу
	    NIS, который ответил первым, в том числе и к вторичным
	    серверам.</para>
	</listitem>

	<indexterm>
	  <primary>NIS</primary>
	  <secondary>клиент</secondary>
	</indexterm>
	<listitem>
	  <para><emphasis>Клиенты NIS</emphasis>.
	    Клиенты NIS, как и большинство рабочих станций &windowsnt;,
	    аутентифицируются на сервере NIS (или на контроллере домена
	    &windowsnt; для рабочих станций &windowsnt;) во время
	    входа в систему.</para>
	</listitem>
      </itemizedlist>
    </sect3>
  </sect2>

  <sect2>
    <title>Использование NIS/YP</title>

    <para>В этом разделе приводится пример настройки NIS.</para>

    <note>
      <para>В этом разделе предполагается, что вы работаете с FreeBSD&nbsp;3.3
	или выше.  Указания, приводимые здесь, скорее всего,
	<emphasis>будут</emphasis> работать с любой версией FreeBSD, выше,
	чем 3.0, однако нет гарантий, что это на самом деле так.</para>
    </note>

    <sect3>
      <title>Планирование</title>

      <para>Давайте предположим, что вы являетесь администратором в маленькой
	университетской лаборатории.  В настоящий момент в этой лаборатории
	с 15 машинами отсутствует единая точка администрирования; на каждой
	машине имеются собственные файлы <filename>/etc/passwd</filename> и
	<filename>/etc/master.passwd</filename>.  Эти файлы синхронизируются
	друг с другом только вручную; сейчас, когда вы добавляете
	пользователя в лаборатории, вы должны выполнить команду
	<command>adduser</command> на всех 15 машинах.	Понятно, что такое
	положение вещей нужно исправлять, так что вы решили перевести
	сеть на использование NIS, используя две машины в качестве
	серверов.</para>

      <para>Итак, конфигурация лаборатории сейчас выглядит примерно
	так:</para>

      <informaltable frame="none">
      <tgroup cols="3">
      <thead>
	<row>
	  <entry>Имя машины</entry>
	  <entry>IP-адрес</entry>
	  <entry>Роль машины</entry>
	</row>
      </thead>

      <tbody>
	<row>
	  <entry><hostid>ellington</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.2</hostid></entry>
	  <entry>Основной сервер NIS</entry>
	</row>

	<row>
	  <entry><hostid>coltrane</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.3</hostid></entry>
	  <entry>Вторичный сервер NIS</entry>
	</row>

	<row>
	  <entry><hostid>basie</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.4</hostid></entry>
	  <entry>Факультетская рабочая станция</entry>
	</row>

	<row>
	  <entry><hostid>bird</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.5</hostid></entry>
	  <entry>Клиентская машина</entry>
	</row>

	<row>
	  <entry><hostid>cli[1-11]</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.[6-17]</hostid></entry>
	  <entry>Другие клиентские машины</entry>
	</row>
      </tbody>
      </tgroup>
      </informaltable>

      <para>Если вы определяете схему NIS первый раз, ее нужно хорошо
	обдумать.  Вне зависимости от размеров вашей сети, есть несколько
	ключевых моментов, которые требуют принятия решений.</para>

      <sect4>
	<title>Выбор имени домена NIS</title>

	<indexterm>
	  <primary>NIS</primary>
	  <secondary>имя домена</secondary>
	</indexterm>
	<para>Это имя не должно быть <quote>именем домена</quote>, которое
	  вы использовали.  Более точно это имя называется <quote>именем
	  домена NIS</quote>.  Когда клиент рассылает запросы на получение
	  информации, он включает в них имя домена NIS, частью которого
	  является.  Таким способом многие сервера в сети могут указать,
	  какой сервер на какой запрос должен отвечать.  Думайте о домене
	  NIS как об имени группы хостов, которые каким-то образом
	  связаны.</para>

	<para>Некоторые организации в качестве имени домена NIS используют
	  свой домен Интернет.	Это не рекомендуется, так как может вызвать
	  проблемы в процессе решения сетевых проблем.	Имя домена NIS должно
	  быть уникальным в пределах вашей сети и хорошо, если оно будет
	  описывать группу машин, которые представляет.  Например,
	  художественный отдел в компании Acme Inc. может находиться в
	  домене NIS с именем <quote>acme-art</quote>.  В нашем примере
	  положим, что мы выбрали имя <literal>test-domain</literal>.</para>

	<indexterm><primary>SunOS</primary></indexterm>
	<para>Несмотря на это, некоторые операционные системы (в частности,
	  &sunos;) используют свое имя домена NIS в качестве имени домена
	  Интернет.  Если одна или более машин в вашей сети имеют такие
	  ограничения, вы <emphasis>обязаны</emphasis> использовать имя
	  домена Интернет в качестве имени домена NIS.</para>
      </sect4>

      <sect4>
	<title>Требования к серверу</title>

	<para>Есть несколько вещей, которые нужно иметь в виду при выборе
	  машины для использования в качестве сервера NIS.  Одной из
	  обескураживающей вещью, касающейся NIS, является уровень
	  зависимости клиентов от серверов.  Если клиент не может
	  подключиться к серверу своего домена NIS, зачастую машину просто
	  становится нельзя использовать.  Отсутствие информации о
	  пользователях и группах приводит к временной остановке работы
	  большинства систем.  Зная это, вы должны выбрать машину, которая
	  не должна подвергаться частым перезагрузкам и не используется
	  для разработки.  Сервер NIS в идеале должен быть отдельно стоящей
	  машиной, единственным целью в жизни которой является быть сервером
	  NIS.  Если вы работаете в сети, которая не так уж сильно загружена,
	  то можно поместить сервер NIS на машине, на которой запущены и
	  другие сервисы, просто имейте в виду, что если сервер NIS
	  становится недоступным, то это негативно отражается на
	  <emphasis>всех</emphasis> клиентах NIS.</para>
      </sect4>
    </sect3>

    <sect3>
      <title>Серверы NIS</title>

      <para>Оригинальные копии всей информации NIS хранится на единственной
	машине, которая называется главным сервером NIS.  Базы данных,
	которые используются для хранения информации, называются картами NIS.
	Во FreeBSD эти карты хранятся в
	<filename>/var/yp/[domainname]</filename>, где
	<filename>[domainname]</filename> является именем обслуживаемого
	домена NIS.  Один сервер NIS может поддерживать одновременно
	несколько доменов, так что есть возможность иметь несколько таких
	каталогов, по одному на каждый обслуживаемый домен.  Каждый домен
	будет иметь свой собственный независимый от других набор карт.</para>

      <para>Основной и вторичный серверы обслуживают все запросы NIS с
	помощью даемона <command>ypserv</command>.  <command>ypserv</command>
	отвечает за получение входящих запросов от клиентов NIS,
	распознавание запрашиваемого домена и отображение имени в путь к
	соответствующему файлы базы данных, а также передаче информации из
	базы данных обратно клиенту.</para>

      <sect4>
	<title>Настройка основного сервера NIS</title>

	<indexterm>
	  <primary>NIS</primary>
	  <secondary>настройка сервера</secondary>
	</indexterm>
	<para>Настройка основного сервера NIS может оказаться сравнительно
	  простой, в зависимости от ваших потребностей.  В поставку FreeBSD
	  сразу включена поддержка NIS.  Все, что вам нужно, это добавить
	  следующие строки в файл <filename>/etc/rc.conf</filename>, а
	  FreeBSD сделает за вас всё остальное..</para>

	<procedure>
	  <step>
	    <para><programlisting>nisdomainname="test-domain"</programlisting>
	      В этой строке задается имя домена NIS, которое будет
	      <literal>test-domain</literal>, еще до настройки сети
	      (например, после перезагрузки).</para>
	  </step>

	  <step>
	    <para><programlisting>nis_server_enable="YES"</programlisting>
	      Здесь указывается FreeBSD на запуск процессов серверов NIS,
	      когда дело доходит до сетевых настроек.</para>
	  </step>

	  <step>
	    <para><programlisting>nis_yppasswdd_enable="YES"</programlisting>
	      Здесь указывается на запуск даемона
	      <command>rpc.yppasswdd</command>, который, как это отмечено
	      выше, позволит пользователям менять свой пароль NIS с
	      клиентской машины.</para>
	  </step>
	</procedure>

	<note>
	  <para>В зависимости от ваших настроек NIS, вам могут понадобиться
	    дополнительные строки.  Обратитесь к <link
	    linkend="network-nis-server-is-client">разделу о серверах NIS,
	    которые являются и клиентами NIS</link> ниже для получения
	    подробной информации.</para>
	</note>

	<para>А теперь всё, что вам нужно сделать, это запустить команду
	  <command>/etc/netstart</command>, работая как администратор.	По
	  ней произойдет настройка всего, при этом будут использоваться
	  значения, заданные в файле <filename>/etc/rc.conf</filename>.</para>
      </sect4>

      <sect4>
	<title>Инициализация карт NIS</title>

	<indexterm>
	  <primary>NIS</primary>
	  <secondary>карты</secondary>
	</indexterm>
	<para><emphasis>Карты NIS</emphasis> являются файлами баз данных,
	  которые хранятся в каталоге <filename>/var/yp</filename>.
	  Они генерируются из конфигурационных файлов, находящихся в каталоге
	  <filename>/etc</filename> основного сервера NIS, за одним
	  исключением: файл <filename>/etc/master.passwd</filename>.
	  На это есть весомая причина, вам не нужно распространять пароли
	  пользователя <username>root</username> и других административных
	  пользователей на все серверы в домене NIS.  По этой причине, прежде
	  чем инициализировать карты NIS, вы должны сделать вот что:</para>

	<screen>&prompt.root; <userinput>cp /etc/master.passwd /var/yp/master.passwd</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>vi master.passwd</userinput></screen>

	<para>Вы должны удалить все записи, касающиеся системных
	  пользователей (<username>bin</username>, <username>tty</username>,
	  <username>kmem</username>, <username>games</username> и так далее), а
	  также записи, которые вы не хотите распространять клиентам NIS
	  (например, <username>root</username> и другие пользователи с UID,
	  равным 0 (администраторы)).</para>

	<note>
	  <para>Проверьте, чтобы файл
	    <filename>/var/yp/master.passwd</filename> был недоступен для
	    записи ни для группы, ни для остальных пользователей (режим
	    доступа 600)!  Воспользуйтесь командой <command>chmod</command>,
	    если это нужно.</para>
	</note>

	<indexterm><primary>Tru64 UNIX</primary></indexterm>
	<para>Когда с этим будет покончено, самое время инициализировать
	  карты NIS!  В поставку FreeBSD включен скрипт с именем
	  <command>ypinit</command>, который делает это (обратитесь к его
	  справочной странице за дополнительной информацией).  Отметьте, что
	  этот скрипт имеется в большинстве операционных систем &unix;, но не
	  во всех.  В системе Digital Unix/Compaq Tru64 UNIX он называется
	  <command>ypsetup</command>.  Так как мы генерируем карты для
	  главного сервера NIS, то при вызове программы
	  <command>ypinit</command> мы передаем ей параметр
	  <option>-m</option>.	Для генерации карт NIS в предположении, что
	  вы уже сделали шаги, описанные выше, выполните следующее:</para>

	<screen>ellington&prompt.root; <userinput>ypinit -m test-domain</userinput>
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] <userinput>n</userinput>
Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server	:  ellington
next host to add:  <userinput>coltrane</userinput>
next host to add:  <userinput>^D</userinput>
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] <userinput>y</userinput>

[..вывод при генерации карт..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</screen>

	<para>Программа <command>ypinit</command> должна была создать файл
	  <filename>/var/yp/Makefile</filename> из
	  <filename>/var/yp/Makefile.dist</filename>.  При создании этого
	  файла предполагается, что вы работаете в окружении с единственным
	  сервером NIS и только с машинами FreeBSD.  Так как в домене
	  <literal>test-domain</literal> имеется также и вторичный сервер,
	  то вы должны отредактировать файл
	  <filename>/var/yp/Makefile</filename>:</para>

	<screen>ellington&prompt.root; <userinput>vi /var/yp/Makefile</userinput></screen>

	<para>Вы должны закомментировать строку, в которой указано</para>

	<programlisting>NOPUSH = "True"</programlisting>

	<para>(она уже не раскомментирована).</para>
      </sect4>

      <sect4>
	<title>Настройка вторичного сервера NIS</title>

	<indexterm>
	  <primary>NIS</primary>
	  <secondary>вторичный сервер</secondary>
	</indexterm>

	<para>Настройка вторичного сервера NIS осуществляется ещё проще,
	  чем настройка главного сервера.  Войдите на вторичный сервер и
	  отредактируйте файл <filename>/etc/rc.conf</filename> точно также,
	  как вы делали это ранее.  Единственным отличием является то, что
	  при запуске программы <command>ypinit</command> мы теперь должны
	  использовать опцию <option>-s</option>.  Применение опции
	  <option>-s</option> требует также указание имени главного сервера
	  NIS, так что наша команда должна выглядеть так:</para>

	<screen>coltrane&prompt.root; <userinput>ypinit -s ellington test-domain</userinput>

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  <userinput>n</userinput>

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don't forget to update map ypservers on ellington.</screen>

	<para>Теперь у вас должен быть каталог с именем
	  <filename>/var/yp/test-domain</filename>.  Копии карт главного
	  сервера NIS должны быть в этом каталоге.  Вы должны удостовериться,
	  что этот каталог обновляется.  Следующие строки в
	  <filename>/etc/crontab</filename> вашего вторичного сервера должны
	  это делать:</para>

	<programlisting>20	*	*	*	*	root   /usr/libexec/ypxfr passwd.byname
21	*	*	*	*	root   /usr/libexec/ypxfr passwd.byuid</programlisting>

	<para>Эти две строки заставляют вторичный сервер синхронизировать
	  свои карты с картами главного сервера.  Хотя эти строчки не
	  обязательны, так как главный сервер делает попытки передать все
	  изменения в своих картах NIS на свои вторичные серверы, но из-за
	  того, что информация для входа в систему настолько жизненно важна для
	  систем, зависящих от сервера, что выполнение регулярных обновлений
	  является совсем не плохой идеей.  Это ещё более важно в загруженных
	  сетях, в которых обновления карт могут не всегда завершаться
	  успешно.</para>

	<para>А теперь точно также запустите команду
	  <command>/etc/netstart</command> на вторичном сервере, по которой
	  снова выполнится запуск сервера NIS.</para>
      </sect4>
    </sect3>

    <sect3>
      <title>Клиенты NIS</title>

      <para>Клиент NIS выполняет так называемую привязку к конкретному
	серверу NIS при помощи даемона <command>ypbind</command>.
	<command>ypbind</command> определяет домен, используемый в системе
	по умолчанию (тот, который устанавливается по команде
	<command>domainname</command>), и начинает широковещательную рассылку
	запросов RPC в локальной сети.	В этих запросах указано имя домена,
	к серверу которого <command>ypbind</command> пытается осуществить
	привязку.  Если сервер, который был настроен для обслуживания
	запрашиваемого домена, получит широковещательный запрос, он ответит
	<command>ypbind</command>, который, в свою очередь запомнит адрес
	сервера.  Если имеется несколько серверов (например, главный и
	несколько вторичных), то <command>ypbind</command> будет использовать
	адрес первого ответившего.  С этого момента клиентская система будет
	направлять все свои запросы NIS на этот сервер.  Время от времени
	<command>ypbind</command> будет <quote>пинать</quote> сервер для
	проверки его работоспособности.
	Если на один из тестовых пакетов не удастся получить ответа за
	разумное время, то <command>ypbind</command> пометит этот домен как
	домен, с которым связка разорвана, и снова начнет процесс посылки
	широковещательных запросов в надежде найти другой сервер.</para>

      <sect4>
	<title>Настройка клиента NIS</title>

	<indexterm>
	  <primary>NIS</primary>
	  <secondary>настройка клиента</secondary>
	</indexterm>
	<para>Настройка машины с FreeBSD в качестве клиента NIS достаточно
	  проста.</para>

	<procedure>
	  <step>
	    <para>Отредактируйте файл <filename>/etc/rc.conf</filename>,
	      добавив туда следующие строки для того, чтобы задать имя домена
	      NIS и запустить <command>ypbind</command> во время запуска
	      сетевых служб:</para>

	    <programlisting>nisdomainname="test-domain"
nis_client_enable="YES"</programlisting>
	  </step>

	  <step>
	    <para>Для импортирования всех возможных учётных записей от сервера
	      NIS, удалите все записи пользователей из вашего файла
	      <filename>/etc/master.passwd</filename> и воспользуйтесь
	      командой <command>vipw</command> для добавления следующей строки
	      в конец файла:</para>

	    <programlisting>+:::::::::</programlisting>

	    <note>
	      <para>Эта строчка даст всем пользователям с корректной учетной
		записью в картах учетных баз пользователей доступ к этой
		системе.  Есть множество способов настроить ваш клиент NIS,
		изменив эту строку.  Посмотрите ниже текст, касающийся <link
		linkend="network-netgroups">сетевых групп</link>, чтобы
		получить более подробную информацию.  Дополнительная информация
		для изучения находится в книге издательства O'Reilly под
		названием <literal>Managing NFS and NIS</literal>.</para>
	    </note>

	    <note>
	      <para>Вы должны оставить хотя бы одну локальную запись (то есть
		не импортировать ее через NIS) в вашем
		<filename>/etc/master.passwd</filename> и эта запись должна
		быть также членом группы <groupname>wheel</groupname>.  Если
		с NIS что-то случится, эта запись может использоваться для
		удаленного входа в систему, перехода в режим администратора и
		исправления неисправностей.</para>
	      </note>
	    </step>

	    <step>
	      <para>Для импортирования всех возможных записей о группах с
		сервера NIS, добавьте в ваш файл
		<filename>/etc/group</filename> такую строчку:</para>

	      <programlisting>+:*::</programlisting>
	    </step>
	  </procedure>

	  <para>После завершения выполнения этих шагов у вас должно получиться
	    запустить команду <command>ypcat passwd</command> и увидеть
	    карту учетных записей сервера NIS.</para>
	</sect4>
      </sect3>
    </sect2>

  <sect2>
    <title>Безопасность NIS</title>

    <para>В общем-то любой пользователь, зная имя вашего домена, может
      выполнить запрос RPC к &man.ypserv.8; и получить содержимое ваших карт
      NIS.  Для предотвращения такого неавторизованного обмена &man.ypserv.8;
      поддерживает так называемую систему <quote>securenets</quote>, которая может
      использоваться для ограничения доступа к некоторой группе хостов.  При
      запуске &man.ypserv.8; будет пытаться загрузить информацию, касающуюся
      securenets, из файла <filename>/var/yp/securenets</filename>.</para>

    <note>
      <para>Имя каталога зависит от параметра, указанного вместе с опцией
	<option>-p</option>.  Этот файл содержит записи, состоящие из
	указания сети и сетевой маски, разделенных пробелом.  Строчки,
	начинающиеся со знака <quote>#</quote>, считаются комментариями.
	Примерный файл securenets может иметь примерно такой вид:</para>
    </note>

    <programlisting># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0</programlisting>

    <para>Если &man.ypserv.8; получает запрос от адреса, который соответствует
      одному из этих правил, он будет отрабатывать запрос обычным образом.
      Если же адрес не подпадает ни под одно правило, запрос будет
      проигнорирован и в журнал будет записано предупреждающее сообщение.  Если
      файл <filename>/var/yp/securenets</filename> не существует,
      <command>ypserv</command> будет обслуживать соединения от любого
      хоста.</para>

    <para>Программа <command>ypserv</command> также поддерживает пакет программ
      <application>tcpwrapper</application> от Wietse Venema.  Это позволяет
      администратору для ограничения доступа вместо
      <filename>/var/yp/securenets</filename> использовать конфигурационные
      файлы <application>tcpwrapper</application>.</para>

    <note>
      <para>Хотя оба этих метода управления доступом обеспечивают некоторую
	безопасность, они, как основанные на проверке привилегированного
	порта, оба подвержены атакам типа <quote>IP spoofing</quote>.  Весь
	сетевой трафик, связанный с работой NIS, должен блокироваться вашим
	межсетевым экраном.</para>

      <para>Серверы, использующие файл <filename>/var/yp/securenets</filename>,
	могут быть не в состоянии обслуживать старых клиентов NIS с древней
	реализацией протокола TCP/IP.  Некоторые из этих реализаций при
	рассылке широковещательных запросов устанавливают все биты машинной
	части адреса в ноль и/или не в состоянии определить маску подсети при
	вычислении адреса широковещательной рассылки.  Хотя некоторые из этих
	проблем могут быть решены изменением конфигурации клиента, другие
	могут привести к отказу от использования
	<filename>/var/yp/securenets</filename>.</para>

      <para>Использование <filename>/var/yp/securenets</filename> на сервере
	с такой архаичной реализацией TCP/IP является весьма плохой идеей, и
	приведёт к потере работоспособности NIS в большой части вашей
	сети.</para>

      <indexterm><primary>tcpwrapper</primary></indexterm>
      <para>Использование пакета <application>tcpwrapper</application> увеличит
	время отклика вашего сервера NIS.  Дополнительной задержки может
	оказаться достаточно для возникновения таймаутов в клиентских
	программах, особенно в загруженных сетях или с медленными серверами
	NIS.  Если одна или более ваших клиентских систем страдают от таких
	проблем, вы должны преобразовать такие клиентские системы во вторичные
	серверы NIS и сделать принудительную их привязку к самим себе.</para>
    </note>
  </sect2>

  <sect2>
    <title>Запрет входа некоторых пользователей</title>

    <para>В нашей лаборатории есть машина <hostid>basie</hostid>, о которой
      предполагается, что она является исключительно факультетской рабочей
      станцией.  Мы не хотим исключать эту машину из домена NIS, однако
      файл <filename>passwd</filename> на главном сервере NIS содержит
      учетные записи как для работников факультета, так и студентов.  Что мы
      можем сделать?</para>

    <para>Есть способ ограничить вход некоторых пользователей на этой машине,
      даже если они присутствуют в базе данных NIS.  Чтобы это сделать, вам
      достаточно добавить
      <literal>-<replaceable>username</replaceable></literal> в конец файла
      <filename>/etc/master.passwd</filename> на клиентской машине, где
      <replaceable>username</replaceable> является именем пользователя,
      которому вы хотите запретить вход.  Рекомендуется сделать это с помощью
      утилиты <command>vipw</command>, так как <command>vipw</command>
      проверит ваши изменения в <filename>/etc/master.passwd</filename>, а
      также автоматически перестроит базу данных паролей по окончании
      редактирования.  Например, если мы хотим запретить пользователю
      <username>bill</username> осуществлять вход на машине
      <hostid>basie</hostid>, то мы сделаем следующее:</para>

    <screen>basie&prompt.root; <userinput>vipw</userinput>
<userinput>[add -bill to the end, exit]</userinput>
vipw: rebuilding the database...
vipw: done

basie&prompt.root; <userinput>cat /etc/master.passwd</userinput>

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/share/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
-bill

basie&prompt.root;</screen>
  </sect2>

    <sect2 id="network-netgroups">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Udo</firstname>
	    <surname>Erdelhoff</surname>
	    <contrib>Текст предоставил </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Использование сетевых групп</title>
      <indexterm><primary>сетевые группы</primary></indexterm>

      <para>Способ, описанный в предыдущем разделе, работает достаточно хорошо,
	если вам нужны особые правила для очень малой группы пользователей или
	машин.	В более крупных сетях вы <emphasis>забудете</emphasis> о
	запрете входа определенных пользователей на важные машины или даже
	будете настраивать каждую машину по отдельности, теряя таким образом
	главное преимущество использования NIS:
	<emphasis>централизованное</emphasis> администрирование.</para>

      <para>Ответом разработчиков NIS на эту проблему являются
	<emphasis>сетевые группы</emphasis>.  Их назначение и смысл можно
	сравнить с обычными группами, используемыми в файловых системах &unix;.
	Главное отличие заключается в отсутствии числового идентификатора и
	возможности задать сетевую группу включением как пользователей, так и
	других сетевых групп.</para>

      <para>Сетевые группы были разработаны для работы с большими, сложными
	сетями с сотнями пользователей и машин.  С одной стороны, хорошо, если
	вам приходится с такой ситуацией.  С другой стороны, эта сложность
	делает невозможным описание сетевых групп с помощью простых примеров.
	Пример, используемый в дальнейшем, демонстрирует эту проблему.</para>

      <para>Давайте предположим, что успешное внедрение системы NIS в вашей
	лаборатории заинтересовало ваше руководство.  Вашим следующим заданием
	стало расширение домена NIS для включения в него некоторых других
	машин студенческого городка.  В двух таблицах перечислены имена
	новых машин и пользователей, а также их краткое описание.</para>

      <informaltable frame="none">
      <tgroup cols="2">
      <thead>
	<row>
	  <entry>Имена пользователей</entry>
	  <entry>Описание</entry>
	</row>
      </thead>

      <tbody>
	<row>
	  <entry><username>alpha</username>, <username>beta</username></entry>
	  <entry>Обычные служащие IT-департамента</entry>
	</row>

	<row>
	  <entry><username>charlie</username>, <username>delta</username></entry>
	  <entry>Практиканты IT-департамента</entry>
	</row>

	<row>
	  <entry><username>echo</username>, <username>foxtrott</username>, <username>golf</username>, ...</entry>
	  <entry>Обычные сотрудники</entry>
	</row>

	<row>
	  <entry><username>able</username>, <username>baker</username>, ...</entry>
	  <entry>Проходящие интернатуру</entry>
	</row>
      </tbody>
      </tgroup>
      </informaltable>

      <informaltable frame="none">
      <tgroup cols="2">
      <thead>
	<row>
	  <entry>Имена машин</entry>
	  <entry>Описание</entry>
	</row>
      </thead>

      <tbody>
	<row>
	  <!--	Имена взяты из книги "Good Omens" (авторы Neil Gaiman и
		Terry Pratchett.  Большое спасибо за прекрасную книгу.	-->
	  <entry><hostid>war</hostid>, <hostid>death</hostid>, <hostid>famine</hostid>, <hostid>pollution</hostid></entry>
	  <entry>Ваши самые важные серверы.  Только служащим IT позволяется
	    входить на эти машины.</entry>
	</row>

	<row>
	  <!-- gluttony был пропущен, потому что он был слишком толст -->
	  <entry><hostid>pride</hostid>, <hostid>greed</hostid>, <hostid>envy</hostid>, <hostid>wrath</hostid>, <hostid>lust</hostid>, <hostid>sloth</hostid></entry>
	  <entry>Менее важные серверы.	Все сотрудники департамента IT могут
	    входить на эти машины.</entry>
	</row>

	<row>
	  <entry><hostid>one</hostid>, <hostid>two</hostid>, <hostid>three</hostid>, <hostid>four</hostid>, ...</entry>
	  <entry>Обычные рабочие станции.  Только
	    <emphasis>реально нанятым</emphasis> служащим позволяется
	    использовать эти машины.</entry>
	</row>

	<row>
	  <entry><hostid>trashcan</hostid></entry>
	  <entry>Очень старая машина без каких-либо критичных данных.  Даже
	    проходящим интернатуру разрешено ее использовать.</entry>
	</row>
      </tbody>
      </tgroup>
      </informaltable>

      <para>Если вы попытаетесь реализовать эти требования, ограничивая
	каждого пользователя по отдельности, то вам придется добавить на каждой
	машине в файл <filename>passwd</filename> по одной строчке
	<literal>-<replaceable>user</replaceable></literal> для каждого пользователя, которому
	запрещено входить на эту систему.  Если вы забудете даже одну строчку,
	у вас могут начаться проблемы.	Гораздо проще делать это правильно во
	время начальной установки, однако вы постепенно <emphasis>будете
	забывать</emphasis> добавлять строчки для новых пользователей во время
	повседневной работы.  В конце концов, Мерфи был оптимистом.</para>

      <para>Использование в этой ситуации сетевых групп дает несколько
	преимуществ.  Нет необходимости описывать по отдельности каждого
	пользователя; вы ставите в соответствие пользователю одну или
	несколько сетевых групп и разрешаете или запрещаете вход всем членам
	сетевой группы.  Если вы добавляете новую машину, вам достаточно
	определить ограничения на вход для сетевых групп.  Если добавляется
	новый пользователь, вам достаточно добавить его к одной или большему
	числу сетевых групп.  Эти изменения независимы друг от друга: нет
	больше комбинаций <quote>для каждого пользователя и машины</quote>.
	Если настройка вашей системы NIS тщательно спланирована, то для
	разрешения или запрещения доступа к машинам вам нужно будет
	модифицировать единственный конфигурационный файл.</para>

      <para>Первым шагом является инициализация карты NIS по имени netgroup.
	Программа &man.ypinit.8; во FreeBSD по умолчанию этой карты не
	создаёт, хотя реализация NIS будет её поддерживает, как только она
	будет создана.  Чтобы создать пустую карту, просто наберите</para>

      <screen>ellington&prompt.root; <userinput>vi /var/yp/netgroup</userinput></screen>

      <para>и начните добавлять содержимое.  Например, нам нужно по крайней
	мере четыре сетевых группы: сотрудники IT, практиканты IT, обычные
	сотрудники и интернатура.</para>

      <programlisting>IT_EMP	(,alpha,test-domain)	(,beta,test-domain)
IT_APP	(,charlie,test-domain)	(,delta,test-domain)
USERS	(,echo,test-domain)	(,foxtrott,test-domain) \
	(,golf,test-domain)
INTERNS (,able,test-domain)	(,baker,test-domain)</programlisting>

      <para><literal>IT_EMP</literal>, <literal>IT_APP</literal> и так далее
	являются именами сетевых групп.  Несколько слов в скобках служат для
	добавления пользователей в группу.  Три поля внутри группы обозначают
	следующее:</para>

      <orderedlist>
	<listitem>
	  <para>Имя хоста или хостов, к которым применимы последующие записи.
	    Если имя хоста не указано, то запись применяется ко всем хостам.
	    Если же указывается имя хоста, то вы получите мир темноты, ужаса
	    и страшной путаницы.</para>
	</listitem>

	<listitem>
	  <para>Имя учетной записи, которая принадлежит этой сетевой
	    группе.</para>
	</listitem>

	<listitem>
	  <para>Домен NIS для учетной записи.  Вы можете импортировать в вашу
	    сетевую группу учетные записи из других доменов NIS, если вы один
	    из тех несчастных, имеющих более одного домена NIS.</para>
	</listitem>
      </orderedlist>

      <para>Каждое из этих полей может содержать шаблоны, подробности даны в
	странице справочника по &man.netgroup.5;.</para>

      <note>
	<indexterm><primary>сетевые группы</primary></indexterm>
	<para>Не нужно использовать имена сетевых групп длиннее 8 символов,
	  особенно если в вашем домене NIS имеются машины, работающие под
	  управлением других операционных систем.  Имена чувствительны к
	  регистру; использование заглавных букв для имен сетевых групп
	  облегчает распознавание пользователей, имен машин и сетевых
	  групп.</para>

	<para>Некоторые клиенты NIS (отличные от FreeBSD) не могут работать
	  с сетевыми группами, включающими большое количество записей.
	  Например, в некоторых старых версиях &sunos; возникают проблемы, если
	  сетевая группа содержит более 15 <emphasis>записей</emphasis>.  Вы
	  можете обойти это ограничение, создав несколько подгрупп с 15 или
	  меньшим количеством пользователей и настоящую сетевую группу,
	  состоящую из подгрупп:</para>

	<programlisting>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</programlisting>

	<para>Вы можете повторить этот процесс, если вам нужно иметь более 225
	  пользователей в одной сетевой группе.</para>
      </note>

      <para>Активация и распространение вашей карты NIS проста:</para>

      <screen>ellington&prompt.root; <userinput>cd /var/yp</userinput>
ellington&prompt.root; <userinput>make</userinput></screen>

      <para>Это приведет к созданию трех карт NIS
	<filename>netgroup</filename>, <filename>netgroup.byhost</filename> и
	<filename>netgroup.byuser</filename>.  Воспользуйтесь утилитой
	&man.ypcat.1; для проверки доступности ваших новых карт NIS:</para>

      <screen>ellington&prompt.user; <userinput>ypcat -k netgroup</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byhost</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byuser</userinput></screen>

      <para>Вывод первой команды должен соответствовать содержимому файла
	<filename>/var/yp/netgroup</filename>.	Вторая команда не выведет
	ничего, если вы не зададите сетевые группы, специфичные для хоста.
	Третья команда может использоваться пользователем для получения
	списка сетевых групп.</para>

      <para>Настройка клиента достаточно проста.  Чтобы настроить сервер
	<hostid>war</hostid>, вам достаточно запустить &man.vipw.8;
	и заменить строку</para>

      <programlisting>+:::::::::</programlisting>

      <para>на</para>

      <programlisting>+@IT_EMP:::::::::</programlisting>

      <para>Теперь только данные, касающиеся пользователей, определенных в
	сетевой группе <literal>IT_EMP</literal>, импортируются в
	базу паролей машины <hostid>war</hostid> и только этим
	пользователям будет разрешен вход.</para>

      <para>К сожалению, это ограничение также касается и функции <literal>~</literal> командного
	процессора и всех подпрограмм, выполняющих преобразование между
	именами пользователей и их числовыми ID.  Другими
	словами, команда <command>cd ~<replaceable>user</replaceable></command>
	работать не будет, команда <command>ls -l</command> будет выдавать
	числовые идентификаторы вместо имён пользователей, а
	<command>find . -user joe -print</command> работать откажется, выдавая
	сообщение <errorname>No such user</errorname>.  Чтобы это исправить,
	вам нужно будет выполнить импорт всех записей о пользователях
	<emphasis>без разрешения на вход на ваши серверы</emphasis>.</para>

      <para>Это можно сделать, добавив еще одну строку в файл
	<filename>/etc/master.passwd</filename>.  Эта строка должна
	содержать:</para>

      <para><literal>+:::::::::/sbin/nologin</literal>, что означает
	<quote>Произвести импортирование всех записей с заменой командного
	процессора на <filename>/sbin/nologin</filename> в импортируемых
	записях</quote>.  Вы можете заменить любое поле в строке с паролем,
	указав значение по умолчанию в вашем
	<filename>/etc/master.passwd</filename>.</para>

      <!-- Been there, done that, got the scars to prove it - ue -->
      <warning>
	<para>Проверьте, что строка
	  <literal>+:::::::::/sbin/nologin</literal> помещена после
	  <literal>+@IT_EMP:::::::::</literal>.  В противном случае все
	  пользовательские записи, импортированные из NIS, будут иметь
	  <filename>/sbin/nologin</filename> в качестве оболочки.</para>
      </warning>

      <para>После этого изменения при появлении нового сотрудника IT вам будет
	достаточно изменять только одну карту NIS.  Вы можете применить
	подобный метод для менее важных серверов, заменяя
	старую строку <literal>+:::::::::</literal> в их файлах
	<filename>/etc/master.passwd</filename> на нечто, подобное
	следующему:</para>

      <programlisting>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Соответствующие строки для обычных рабочих станций могут иметь
	такой вид:</para>

      <programlisting>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>И все было прекрасно до того момента, когда через несколько
	недель изменилась политика: Департамент IT начал нанимать интернатуру.
	Интернатуре в IT позволили использовать обычные рабочие станции и
	менее важные серверы; практикантам позволили входить на главные
	серверы.  Вы создали новую сетевую группу <literal>IT_INTERN</literal>, добавили в нее
	новую интернатуру и начали изменять настройки на всех и каждой
	машине...  Как говорит старая мудрость: <quote>Ошибки в
	централизованном планировании приводят к глобальному
	хаосу</quote>.</para>

      <para>Возможность в NIS создавать сетевые группы из других сетевых
	групп может использоваться для предотвращения подобных ситуаций.  Одним
	из вариантов является создание сетевых групп на основе ролей.
	Например, вы можете создать сетевую группу с именем
	<literal>BIGSRV</literal> для задания ограничений на вход на
	важные серверы, другую сетевую группу с именем
	<literal>SMALLSRV</literal> для менее важных серверов и третью
	сетевую группу под названием <literal>USERBOX</literal> для
	обычных рабочих станций.  Каждая из этих сетевых групп содержит
	сетевые группы, которым позволено входить на эти машины.  Новые записи
	для вашей карты NIS сетевой группы должны выглядеть таким
	образом:</para>

      <programlisting>BIGSRV	  IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</programlisting>

      <para>Этот метод задания ограничений на вход работает весьма хорошо,
	если вы можете выделить группы машин с одинаковыми ограничениями.  К
	сожалению, такая ситуация может быть исключением, но не правилом.  В
	большинстве случаев вам нужна возможность определять ограничения на
	вход индивидуально для каждой машины.</para>

      <para>Задание сетевых групп в зависимости от машин является другой
	возможностью, которой можно воспользоваться при изменении политики,
	описанной выше.  При таком развитии событий файл
	<filename>/etc/master.passwd</filename> на каждой машине содержит две
	строки, начинающиеся с <quote>+</quote>.  Первая из них добавляет
	сетевую группу с учётными записями, которым разрешено входить на эту
	машину, а вторая добавляет все оставшиеся учетные записи с
	<filename>/sbin/nologin</filename> в качестве командного процессора.
	Хорошей идеей является использование <quote>ИМЕНИ МАШИНЫ</quote> заглавными буквами
	для имени сетевой группы.  Другими словами, строки должны иметь такой
	вид:</para>

      <programlisting>+@<replaceable>BOXNAME</replaceable>:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Как только вы завершите эту работу для всех ваших машин, вам не
	нужно будет снова модифицировать локальные версии
	<filename>/etc/master.passwd</filename>.  Все будущие изменения могут
	быть выполнены изменением карты NIS.  Вот пример возможной карты
	сетевой группы для этого случая с некоторыми полезными
	дополнениями:</para>

      <programlisting># Сначала определяем группы пользователей
IT_EMP	  (,alpha,test-domain)	  (,beta,test-domain)
IT_APP	  (,charlie,test-domain)  (,delta,test-domain)
DEPT1	  (,echo,test-domain)	  (,foxtrott,test-domain)
DEPT2	  (,golf,test-domain)	  (,hotel,test-domain)
DEPT3	  (,india,test-domain)	  (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)	  (,lima,test-domain)
D_INTERNS (,able,test-domain)	  (,baker,test-domain)
#
# Теперь задаем несколько групп на основе ролей
USERS	  DEPT1   DEPT2     DEPT3
BIGSRV	  IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# И группы для специальных задач
# Открыть пользователям echo и golf доступ к антивирусной машине
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# Сетевые группы, специфичные для машин
# Наши главные серверы
WAR	  BIGSRV
FAMINE	  BIGSRV
# Пользователю india необходим доступ к этому серверу
POLLUTION  BIGSRV  (,india,test-domain)
#
# Этот очень важен и ему требуются большие ограничения доступа
DEATH	  IT_EMP
#
# Антивирусная машина, упомянутая выше
ONE	  SECURITY
#
# Ограничить машину единственным пользователем
TWO	  (,hotel,test-domain)
# [...далее следуют другие группы]</programlisting>

      <para>Если вы используете какие-либо базы данных для управления
	учетными записями ваших пользователей, вы должны смочь создать первую
	часть карты с помощью инструментов построения отчетов вашей базы
	данных.  В таком случае новые пользователи автоматически получат
	доступ к машинам.</para>

      <para>И последнее замечание: Не всегда бывает разумно использовать
	сетевые группы на основе машин.  Если в студенческих лабораториях вы
	используете несколько десятков или даже сотен одинаковых машин, то
	вам нужно использовать сетевые группы на основе ролей, а не основе
	машин, для того, чтобы размеры карты NIS оставались в разумных
	пределах.</para>
    </sect2>

  <sect2>
    <title>Важные замечания</title>

    <para>Есть некоторые действия, которые нужно будет выполнять по-другому,
      если вы работаете с NIS.</para>

    <itemizedlist>
      <listitem>
	<para>Каждый раз, когда вы собираетесь добавить пользователя в
	  лаборатории, вы должны добавить его <emphasis>только</emphasis> на
	  главном сервере NIS и <emphasis>обязательно перестроить карты
	  NIS</emphasis>.  Если вы забудете сделать это, то новый
	  пользователь не сможет нигде войти, кроме как на главном сервере
	  NIS.  Например, если в лаборатории нам нужно добавить нового
	  пользователя <username>jsmith</username>, мы делаем вот что:</para>

	<screen>&prompt.root; <userinput>pw useradd jsmith</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>make test-domain</userinput></screen>

	<para>Вместо <command>pw useradd jsmith</command> вы можете также
	  запустить команду <command>adduser jsmith</command>.</para>
      </listitem>

      <listitem>
	<para><emphasis>Не помещайте административные учетные записи в карты
	  NIS</emphasis>.  Вам не нужно распространять административных
	  пользователей и их пароли на машины, которые не должны иметь доступ
	  к таким учётным записям.</para>
      </listitem>

      <listitem>
	<para><emphasis>Сделайте главный и вторичные серверы NIS безопасными
	  и минимизируйте их время простоя</emphasis>.	Если кто-то либо
	  взломает, либо просто отключит эти машины, то люди без права
	  входа в лабораторию с легкостью получат доступ.</para>

	<para>Это основное уязвимое место в любой централизованно
	  администрируемой системе.  Если вы не
	  защищаете ваши серверы NIS, вы будете иметь дело с толпой
	  разозлённых пользователей!</para>
      </listitem>
    </itemizedlist>
  </sect2>

  <sect2>
    <title>Совместимость с NIS v1</title>

    <para><application>ypserv</application> из поставки FreeBSD имеет
      встроенную поддержку для обслуживания клиентов NIS v1.  Реализация
      NIS
      во FreeBSD использует только протокол NIS v2, хотя другие реализации
      имеют поддержку протокола v1 для совместимости со старыми системами.
      Даемоны <application>ypbind</application>, поставляемые с такими
      системами, будут пытаться осуществить привязку к серверу NIS v1, даже
      если это им не нужно (и они будут постоянно рассылать широковещательные
      запросы в поиске такого сервера даже после получения ответа от сервера
      v2).  Отметьте, что хотя имеется поддержка обычных клиентских вызовов,
      эта версия <application>ypserv</application> не отрабатывает запросы на передачу карт v1;
      следовательно, она не может использоваться в качестве главного или
      вторичного серверов вместе с другими серверами NIS, поддерживающими
      только протокол v1.  К счастью, скорее всего, в настоящий момент
      такие серверы практически не используются.</para>
  </sect2>

    <sect2 id="network-nis-server-is-client">
      <title>Серверы NIS, которые также являются клиентами NIS</title>

      <para>Особое внимание следует уделить использованию
	<application>ypserv</application> в домене со
	многими серверами, когда серверные машины являются также клиентами
	NIS.
	Неплохо бы заставить серверы осуществить привязку к самим себе,
	запретив рассылку запросов на привязку и возможно, перекрестную
	привязку друг к другу.  Если один сервер выйдет из строя, а другие
	будут зависеть от него, то в результате могут возникнуть странные
	ситуации.  Постепенно все клиенты попадут в таймаут и попытаются
	привязаться к другим серверам, но полученная задержка может быть
	значительной, а странности останутся, так как серверы снова могут
	привязаться друг к другу.</para>

      <para>Вы можете заставить хост выполнить привязку к конкретному серверу,
	запустив команду <command>ypbind</command> с флагом
	<option>-S</option>.  Если вы не хотите делать это вручную каждый
	раз при перезагрузке
	вашего сервера NIS, то можете добавить в файл
	<filename>/etc/rc.conf</filename> такие строки:</para>

      <programlisting>nis_client_enable="YES"   # run client stuff as well
nis_client_flags="-S <replaceable>NIS domain</replaceable>,<replaceable>server</replaceable>"</programlisting>

      <para>Дополнительную информацию можно найти на странице справки по
	&man.ypbind.8;.</para>
    </sect2>

    <sect2>
      <title>Форматы паролей</title>

      <indexterm>
	<primary>NIS</primary>
	<secondary>форматы паролей</secondary>
      </indexterm>

      <para>Одним из общих вопросов, которые возникают в начале работы с NIS,
	является вопрос совместимости форматов паролей.  Если ваш сервер NIS
	использует пароли, зашифрованные алгоритмом DES, то он будет
	поддерживать только тех клиентов, что также используют DES.  К
	примеру, если в вашей сети имеются клиенты NIS, использующие &solaris;,
	то вам, скорее всего, необходимо использовать пароли с шифрованием по
	алгоритму DES.</para>

      <para>Чтобы понять, какой формат используют ваши серверы и клиенты,
	загляните в файл <filename>/etc/login.conf</filename>.  Если хост
	настроен на использование паролей, зашифрованных по алгоритму DES,
	то класс <literal>default</literal> будет содержать запись вроде
	следующей:</para>

      <programlisting>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Последующие строки опущены]</programlisting>

      <para>Другими возможными значениями для <literal>passwd_format</literal>
	являются <literal>blf</literal> и <literal>md5</literal> (для паролей,
	шифруемых по стандартам Blowfish и MD5 соответственно).</para>

      <para>Если вы внесли изменения в файл
	<filename>/etc/login.conf</filename>, то вам также нужно перестроить
	базу данных параметров входа в систему, что достигается запуском
	следующей команды пользователем <username>root</username>:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>

      <note>
	<para>Формат паролей, которые уже находятся в файле
	  <filename>/etc/master.passwd</filename>, не будет изменён до тех пор,
	  пока пользователь не сменит свой пароль <emphasis>после</emphasis>
	  перестроения базы данных параметров входа в систему.</para>
      </note>

      <para>После этого, чтобы удостовериться в том, что пароли зашифрованы
	в том формате, который выбран вами, нужно проверить, что строка
	<literal>crypt_default</literal> в <filename>/etc/auth.conf</filename>
	указывает предпочтение выбранного вами формата паролей.  Для этого
	поместите выбранный формат первым в списке.  Например, при
	использовании DES-шифрования паролей строка будет выглядеть так:</para>

      <programlisting>crypt_default	=	des blf md5</programlisting>

      <para>Выполнив вышеперечисленные шаги на каждом из серверов и клиентов
	NIS, работающих на FreeBSD, вы можете обеспечить их согласованность
	относительно используемого в вашей сети формата паролей.  Если у вас
	возникли проблемы с аутентификацией клиента NIS, начать
	её решать определённо стоит отсюда.  Запомните: если вы хотите
	использовать сервер NIS в гетерогенной сети, вам, наверное, нужно
	будет использовать DES на всех системах в силу того, что это
	минимальный общий стандарт.</para>
    </sect2>
  </sect1>

  <sect1 id="network-dhcp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Greg</firstname>
	  <surname>Sutter</surname>
	  <contrib>Текст написал </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Автоматическая настройка сети (DHCP)</title>

  <sect2>
    <title>Что такое DHCP?</title>
    <indexterm>
      <primary>Dynamic Host Configuration Protocol</primary>
      <see>DHCP</see>
    </indexterm>
    <indexterm>
      <primary>Internet Software Consortium (ISC)</primary>
    </indexterm>

    <para>DHCP, или Dynamic Host Configuration Protocol (Протокол
      Динамической Конфигурации Хостов), описывает порядок, по которому
      система может подключиться к сети и получить необходимую информацию
      для работы в ней.  Во FreeBSD используется реализация DHCP от ISC
      (Internet Software Consortium), так что вся информация, описывающая
      особенности, зависящие от реализации, относится к дистрибутиву
      ISC.</para>
  </sect2>

  <sect2>
    <title>Что описывается в этом разделе</title>

    <para>В этом разделе описываются компоненты системы ISC DHCP как со стороны
      клиента, так и со стороны сервера.  Программа, работающая на клиентской
      стороне, <command>dhclient</command>, интегрирована в поставку FreeBSD,
      а серверная часть доступна в виде порта <filename
      role="package">net/isc-dhcp3-server</filename>.  Кроме ссылок ниже,
      много полезной информации находится на страницах справочной системы,
      описывающих &man.dhclient.8;, &man.dhcp-options.5; и
      &man.dhclient.conf.5;.</para>
  </sect2>

  <sect2>
    <title>Как это работает</title>

    <indexterm><primary>UDP</primary></indexterm>
    <para>Когда на клиентской машине выполняется программа
      <command>dhclient</command>, являющаяся клиентом DHCP, она начинает
      широковещательную рассылку запросов на получение настроечной информации.
      По умолчанию эти запросы делаются на 68 порт UDP.	Сервер отвечает на UDP
      67, выдавая клиенту адрес IP и другую необходимую информацию, такую, как
      сетевую маску, маршрутизатор и серверы DNS.  Вся эта информация даётся в
      форме <quote>аренды</quote> DHCP и верна только определенное время (что
      настраивается администратором сервера DHCP).  При таком подходе
      устаревшие адреса IP тех клиентов, которые больше не подключены к сети,
      могут автоматически использоваться повторно.</para>

    <para>Клиенты DHCP могут получить от сервера очень много информации.
      Подробный список находится в странице Справочника
      &man.dhcp-options.5;.</para>
  </sect2>

  <sect2>
    <title>Интеграция с FreeBSD</title>

    <para>Клиент DHCP от ISC, <command>dhclient</command>, полностью
      интегрирован во FreeBSD.	Поддержка клиента DHCP есть как в программе
      установки, так и в самой системе, что исключает необходимость в
      знании подробностей конфигурации сети в любой сети, имеющей сервер
      DHCP.  Утилита <command>dhclient</command> включена во все версии
      FreeBSD, начиная с 3.2.</para>

    <indexterm>
      <primary><application>sysinstall</application></primary>
    </indexterm>
    <para>DHCP поддерживается утилитой <application>sysinstall</application>.
      При настройке сетевого интерфейса из программы
      <application>sysinstall</application> первый
      вопрос, который вам задается: <quote>Do you want to try DHCP
      configuration of this interface?</quote> (<quote>Хотите ли вы попробовать
      настроить этот интерфейс через DHCP?</quote>).  Утвердительный ответ
      приведёт к запуску программы <command>dhclient</command>, и при удачном
      его выполнении к автоматическому заданию информации для настройки
      интерфейса.</para>

    <para>Есть две вещи, которые вы должны сделать для того, чтобы ваша
      система использовала DHCP при загрузке:</para>

    <indexterm>
      <primary>DHCP</primary>
      <secondary>требования</secondary>
    </indexterm>
    <itemizedlist>
      <listitem>
	<para>Убедитесь, что устройство <devicename>bpf</devicename>
	  включено в компиляцию вашего ядра.  Чтобы это сделать, добавьте
	  строчку <literal>device bpf</literal>
	  (<literal>pseudo-device bpf</literal> в &os;&nbsp;4.X)
	  в конфигурационный
	  файл ядра и перестройте ядро.  Более подробная информация о
	  построении ядер имеется в <xref
	  linkend="kernelconfig">.</para>

	<para>Устройство <devicename>bpf</devicename> уже является частью
	  ядра <filename>GENERIC</filename>, которое поставляется вместе с
	  FreeBSD, так что, если вы не используете другое ядро, то вам и
	  не нужно его делать для того, чтобы работал DHCP.</para>

	<note>
	  <para>Те, кто беспокоится о безопасности, должны иметь в виду, что
	    устройство <devicename>bpf</devicename> является также тем самым
	    устройством, которое позволяет работать программам-снифферам
	    пакетов (хотя для этого они должны быть запущены пользователем
	    <username>root</username>).  Наличие устройства
	    <devicename>bpf</devicename> <emphasis>необходимо</emphasis> для
	    использования DHCP, но если вы чересчур беспокоитесь о
	    безопасности, то вам нельзя добавлять устройство
	    <devicename>bpf</devicename> в ядро только для того, чтобы
	    в неопределённом будущем использовать DHCP.</para>
	</note>
      </listitem>

      <listitem>
	<para>Отредактируйте ваш файл <filename>/etc/rc.conf</filename>,
	  включив в него следующее:</para>

	<programlisting>ifconfig_fxp0="DHCP"</programlisting>
      </listitem>
    </itemizedlist>

    <note>
      <para>Обязательно замените <literal>fxp0</literal> на имя интерфейса,
	который вы хотите настраивать динамически, как это описано в <xref
	linkend="config-network-setup">.</para>
    </note>

    <para>Если <command>dhclient</command> в вашей системе находится в другом
      месте или если вы хотите задать дополнительные параметры для
      <command>dhclient</command>, то также укажите следующее (изменив так,
      как вам нужно):</para>

    <programlisting>dhcp_program="/sbin/dhclient"
dhcp_flags=""</programlisting>

    <indexterm>
      <primary>DHCP</primary>

      <secondary>сервер</secondary>
    </indexterm>

    <para>Сервер DHCP, <application>dhcpd</application>, включён как часть порта
      <filename role="package">net/isc-dhcp3-server</filename> в коллекцию
      портов.  Этот порт содержит DHCP-сервер от ISC и документацию.</para>
  </sect2>

  <sect2>
    <title>Файлы</title>

    <indexterm>
      <primary>DHCP</primary>
      <secondary>конфигурационные файлы</secondary>
    </indexterm>
    <itemizedlist>
      <listitem>
	<para><filename>/etc/dhclient.conf</filename></para>

	<para><command>dhclient</command> требует наличия конфигурационного
	  файла, <filename>/etc/dhclient.conf</filename>.  Как правило, файл
	  содержит только комментарии, а настройки по умолчанию достаточно
	  хороши.  Этот настроечный файл описан на страницах справочной
	  системы по &man.dhclient.conf.5;.</para>
      </listitem>

      <listitem>
	<para><filename>/sbin/dhclient</filename></para>

	<para><command>dhclient</command> скомпонован статически и находится
	  в каталоге <filename>/sbin</filename>.  На страница Справочника
	  &man.dhclient.8; дается более подробная информация о
	  <command>dhclient</command>.</para>
      </listitem>

      <listitem>
	<para><filename>/sbin/dhclient-script</filename></para>

	<para><command>dhclient-script</command> является специфичным для
	  FreeBSD скриптом настройки клиента DHCP.  Он описан в
	  &man.dhclient-script.8;, но для нормального функционирования
	  никаких модификаций со стороны пользователя не требуется.</para>
      </listitem>

      <listitem>
	<para><filename>/var/db/dhclient.leases</filename></para>

	<para>В этом файле клиент DHCP хранит базу данных выданных к
	  использованию адресов в виде журнала.  На странице
	  &man.dhclient.leases.5; дается гораздо более подробное
	  описание.</para>
      </listitem>
    </itemizedlist>
  </sect2>

    <sect2>
      <title>Дополнительная литература</title>

      <para>Полное описание протокола DHCP дается в <ulink
	url="http://www.freesoft.org/CIE/RFC/2131/">RFC 2131</ulink>.  Кроме
	того, дополнительная информация есть на сервере <ulink
	url="http://www.dhcp.org/"></ulink>.</para>
    </sect2>

    <sect2 id="network-dhcp-server">
      <title>Установка и настройка сервера DHCP</title>

      <sect3>
	<title>Чему посвящён этот раздел</title>

	<para>Этот раздел даёт информацию о том, как настроить систему
	  FreeBSD для работы в качестве сервера DHCP на основе реализации
	  пакета DHCP от ISC (Internet Software Consortium).</para>

	<para>Серверная часть пакета не поставляется как часть FreeBSD, так
	  что вам потребуется установить порт <filename
	  role="package">net/isc-dhcp3-relay</filename> для получения
	  этого сервиса.  Обратитесь к <xref linkend="ports"> для получения
	  более полной информации об использовании коллекции портов.</para>
      </sect3>

      <sect3>
	<title>Установка сервера DHCP</title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>установка</secondary>
	</indexterm>

	<para>Для того, чтобы настроить систему FreeBSD на работу в качестве
	  сервера DHCP, вам необходимо обеспечить присутствие устройства
	  &man.bpf.4;, вкомпилированного в ядро.  Для этого
	  добавьте строку <literal>device bpf</literal>
	  (<literal>pseudo-device bpf</literal> в &os;&nbsp;4.X) в файл
	  конфигурации вашего ядра.  Для получения более полной информации о
	  построении ядер, обратитесь к <xref linkend="kernelconfig">.</para>

	<para>Устройство <devicename>bpf</devicename> уже входит в состав
	  ядра <filename>GENERIC</filename>, поставляемого с FreeBSD, так что
	  вам не нужно создавать собственное ядро для обеспечения работы
	  DHCP.</para>

	<note>
	  <para>Те, кто обращает особое внимание на вопросы безопасности,
	    должны заметить, что <devicename>bpf</devicename> является тем
	    устройством, что позволяет нормально работать снифферам пакетов
	    (хотя таким программам требуются привилегированный доступ).
	    Наличие устройства <devicename>bpf</devicename>
	    <emphasis>обязательно</emphasis> для использования DHCP, но если
	    вы очень обеспокоены безопасностью, наверное, вам не нужно
	    включать <devicename>bpf</devicename> в ваше ядро только потому,
	    что в отдалённом будущем вы собираетесь использовать DHCP.</para>
	</note>

	<para>Следующим действием, которое вам нужно выполнить, является
	  редактирование примерного <filename>dhcpd.conf</filename>, который
	  устанавливается в составе порта <filename
	  role="package">net/isc-dhcp3-server</filename>.  По умолчанию это
	  файл <filename>/usr/local/etc/dhcpd.conf.sample</filename>, и вы
	  должны скопировать его в файл
	  <filename>/usr/local/etc/dhcpd.conf</filename> перед тем, как его
	  редактировать.</para>
      </sect3>

      <sect3>
	<title>Настройка сервера DHCP</title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>dhcpd.conf</secondary>
	</indexterm>

	<para><filename>dhcpd.conf</filename> состоит из деклараций
	  относительно подсетей и хостов, и проще всего описывается на
	  примере:</para>

	<programlisting>option domain-name "example.com";<co id="domain-name">
option domain-name-servers 192.168.4.100;<co id="domain-name-servers">
option subnet-mask 255.255.255.0;<co id="subnet-mask">

default-lease-time 3600;<co id="default-lease-time">
max-lease-time 86400;<co id="max-lease-time">
ddns-update-style none;<co id="ddns-update-style">

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<co id="range">
  option routers 192.168.4.1;<co id="routers">
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<co id="hardware">
  fixed-address mailhost.example.com;<co id="fixed-address">
}</programlisting>

	<calloutlist>
	  <callout arearefs="domain-name">
	    <para>Этот параметр задаёт домен, который будет выдаваться
	      клиентам в качестве домена, используемого по умолчанию при
	      поиске.  Обратитесь к страницам справочной системы по
	      &man.resolv.conf.5; для получения дополнительной информации о
	      том, что это значит.</para>
	  </callout>

	  <callout arearefs="domain-name-servers">
	    <para>Этот параметр задаёт список разделённых запятыми серверов
	      DNS, которые должен использовать клиент.</para>
	  </callout>

	  <callout arearefs="subnet-mask">
	    <para>Маска сети, которая будет выдаваться клиентам.</para>
	  </callout>

	  <callout arearefs="default-lease-time">
	    <para>Клиент может запросить определённое время, которое будет
	      действовать выданная информация.  В противном случае сервер
	      выдаст настройки с этим сроком (в секундах).</para>
	  </callout>

	  <callout arearefs="max-lease-time">
	    <para>Это максимальное время, на которое сервер будет выдавать
	      конфигурацию.  Если клиент запросит больший срок, он будет
	      подтверждён, но будет действовать только
	      <literal>max-lease-time</literal> секунд.</para>
	  </callout>

	  <callout arearefs="ddns-update-style">
	    <para>Этот параметр задаёт, будет ли сервер DHCP пытаться
	      обновить DNS при выдаче или освобождении конфигурационной
	      информации.  В реализации ISC этот параметр является
	      <emphasis>обязательным</emphasis>.</para>
	  </callout>

	  <callout arearefs="range">
	    <para>Это определение того, какие IP-адреса должны использоваться
	      в качестве резерва для выдачи клиентам.  IP-адреса между и
	      включая границы, будут выдаваться клиентам.</para>
	  </callout>

	  <callout arearefs="routers">
	    <para>Объявление маршрутизатора, используемого по умолчанию,
	      который будет выдаваться клиентам.</para>
	  </callout>

	  <callout arearefs="hardware">
	    <para>Аппаратный MAC-адрес хоста (чтобы сервер DHCP мог
	      распознать хост, когда тот делает запрос).</para>
	  </callout>

	  <callout arearefs="fixed-address">
	    <para>Определение того, что хосту всегда будет выдаваться один и
	      тот же IP-адрес.  Заметьте, что указание здесь имени хоста
	      корректно, так как сервер DHCP будет разрешать имя хоста
	      самостоятельно до того, как выдать конфигурационную
	      информацию.</para>
	  </callout>
	</calloutlist>

	<para>Как только вы закончите составлять свой
	  <filename>dhcpd.conf</filename>, вы можете продолжить работу
	  запуском сервера при помощи следующей команды:</para>

	<screen>&prompt.root; <userinput>/usr/local/etc/rc.d/isc-dhcpd.sh start</userinput></screen>

	<para>Если в будущем вам понадобится сделать изменения в настройке
	  вашего сервера, то важно заметить, что посылка сигнала
	  <literal>SIGHUP</literal> приложению
	  <application>dhcpd</application> <emphasis>не приведёт</emphasis> к
	  перезагрузке настроек, как это бывает для большинства даемонов.
	  Вам нужно послать сигнал <literal>SIGTERM</literal> для остановки
	  процесса, а затем перезапустить его при помощи вышеприведённой
	  команды.</para>
      </sect3>

      <sect3>
	<title>Файлы</title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>конфигурационный файлы</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para><filename>/usr/local/sbin/dhcpd</filename></para>

	    <para><application>dhcpd</application> скомпонован статически и
	      расположен в каталоге <filename>/usr/local/sbin</filename>.
	      Страницы справочной системы &man.dhcpd.8;,
	      устанавливаемые портом, содержат более полную информацию о
	      <application>dhcpd</application>.</para>
	  </listitem>

	  <listitem>
	    <para><filename>/usr/local/etc/dhcpd.conf</filename></para>

	    <para><application>dhcpd</application> требует наличия
	      конфигурационного файла,
	      <filename>/usr/local/etc/dhcpd.conf</filename>, до того, как
	      он будет запущен и начнёт предоставлять сервис клиентам.
	      Необходимо, чтобы этот файл содержал все данные, которая
	      будет выдаваться обслуживаемым клиентам, а также информацию о
	      работе сервера.  Этот конфигурационный файл описывается на
	      страницах справочной системы &man.dhcpd.conf.5;, которые
	      устанавливаются портом.</para>
	  </listitem>

	  <listitem>
	    <para><filename>/var/db/dhcpd.leases</filename></para>

	    <para>Сервер DHCP ведёт базу данных выданной информации в этом
	      файле, который записывается в виде протокола.  Страницы
	      справочной системы &man.dhcpd.leases.5;, устанавливаемые портом,
	      дают гораздо более подробное описание.</para>
	  </listitem>

	  <listitem>
	    <para><filename>/usr/local/sbin/dhcrelay</filename></para>

	    <para><application>dhcrelay</application> используется в сложных
	      ситуациях, когда сервер DHCP пересылает запросы от клиента
	      другому серверу DHCP в отдельной сети.  Если вам нужна такая
	      функциональность, то установите порт <filename
	      role="package">net/isc-dhcp3-server</filename>.  На страницах
	      справочной системы &man.dhcrelay.8;, которые устанавливаются
	      портом, даётся более полное описание.</para>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-dns">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Текст предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Domain Name System (DNS)</title>

    <sect2>
      <title>Обзор</title>

      <indexterm><primary>BIND</primary></indexterm>
      <para>По умолчанию во FreeBSD используется одна из версий программы BIND
	(Berkeley Internet Name Domain), являющейся самой распространенной
	реализацией протокола DNS.  DNS - это протокол, при помощи которого
	имена преобразуются в IP-адреса и наоборот.  Например, в ответ на
	запрос о <hostid role="fqdn">www.FreeBSD.org</hostid> будет получен IP-адрес
	веб-сервера Проекта FreeBSD, а запрос о
	<hostid role="fqdn">ftp.FreeBSD.org</hostid> возвратит IP-адрес соответствующей
	машины с FTP-сервером.  Точно также происходит и обратный процесс.
	Запрос, содержащий IP-адрес машины, возвратит имя хоста.  Для
	выполнения запросов к DNS вовсе не обязательно иметь в системе
	работающий сервер имён.</para>

      <indexterm><primary>DNS</primary></indexterm>
      <para>В сети Интернет DNS управляется через достаточно сложную систему
	авторизированных корневых серверов имён, и других менее крупных
	серверов имён, которые содержат и кэшируют информацию о конкретных
	доменах.</para>

      <para>В этом документа рассматривается BIND 8.x, так как это стабильная
	версия, используемая во FreeBSD.  BIND 9.x может быть установлен как
	порт <filename role="package">net/bind9</filename>.</para>

      <para>Протокол DNS стандартизован в RFC1034 и RFC1035.</para>

      <para>На данный момент пакет BIND поддерживается Internet Software
	Consortium <ulink url="http://www.isc.org/"></ulink>.</para>
    </sect2>

    <sect2>
      <title>Используемая терминология</title>

      <para>Для понимания этого документа нужно понимать значения некоторых
	терминов, связанных с работой DNS.</para>

      <indexterm><primary>ресолвер</primary></indexterm>
      <indexterm><primary>обратный DNS</primary></indexterm>
      <indexterm><primary>корневая зона</primary></indexterm>
      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="3*">
	  <thead>
	    <row>
	      <entry>Термин</entry>
	      <entry>Определение</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Прямой запрос к DNS (forward DNS)</entry>

	      <entry>Преобразование имён хостов в адреса IP</entry>
	    </row>

	    <row>
	      <entry>Ориджин (origin)</entry>

	      <entry>Обозначает домен, покрываемый конкретным файлом
		зоны</entry>
	    </row>

	    <row>
	      <entry><application>named</application>, bind, сервер
		имён</entry>

	      <entry>Общеупотребительные названия для обозначения пакета BIND,
		обеспечивающего работу сервера имён во FreeBSD.</entry>
	    </row>

	    <row>
	      <entry>Ресолвер</entry>

	      <entry>Системный процесс, посредством которого машина обращается
		к серверу имён для получения информации о зоне</entry>
	    </row>

	    <row>
	      <entry>Обратный DNS (reverse DNS)</entry>

	      <entry>Операция, обратная прямому запросу к DNS; преобразование
		адресов IP в имена хостов</entry>
	    </row>

	    <row>
	      <entry>Корневая зона</entry>

	      <entry>Начало иерархии зон Интернет.  Все зоны находятся под
		корневой зоной, подобно тому, как все файлы располагаются ниже
		корневого каталога.</entry>
	    </row>

	    <row>
	      <entry>Зона</entry>

	      <entry>Отдельный домен, поддомен или часть DNS, управляемая
		одним сервером.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <indexterm>
	<primary>зоны</primary>
	<secondary>примеры</secondary>
      </indexterm>

      <para>Примеры зон:</para>

      <itemizedlist>
	<listitem>
	  <para><hostid>.</hostid> является корневой зоной</para>
	</listitem>

	<listitem>
	  <para><hostid>org.</hostid> является зоной ниже корневой зоны</para>
	</listitem>

	<listitem>
	  <para><hostid role="domainname">example.org</hostid> является зоной под зоной
	    <hostid>org.</hostid></para>
	</listitem>

	<listitem>
	  <para><hostid role="domainname">foo.example.org.</hostid> является поддоменом,
	    зоной под зоной <hostid role="domainname">example.org.</hostid></para>
	</listitem>

	<listitem>
	  <para><hostid>1.2.3.in-addr.arpa</hostid> является зоной, в которую
	    включены все IP-адреса, формирующие пространство адресов
	    <hostid role="ipaddr">3.2.1.*</hostid>.</para>
	</listitem>
      </itemizedlist>

      <para>Как можно видеть, уточняющая часть имени хоста появляется слева.
	Например, <hostid role="domainname">example.org.</hostid> более точен, чем
	<hostid>org.</hostid>, также, как <hostid>org.</hostid> более
	точен, чем корневая зона.  Расположение каждой части имени хоста сильно
	похоже на файловую систему: каталог <filename>/dev</filename>
	расположен в корневой файловой системе, и так далее.</para>
    </sect2>

    <sect2>
      <title>Причины, по которым вам может понадобиться сервер имён</title>

      <para>Сервера имён обычно используются в двух видах: авторитетный сервер
	имён и кэширующий сервер имён.</para>

      <para>Авторитетный сервер имён нужен, когда:</para>

      <itemizedlist>
	<listitem>
	  <para>нужно предоставлять информацию о DNS остальному миру, отвечая
	    на запросы авторизированно.</para>
	</listitem>

	<listitem>
	  <para>зарегистрирован домен, такой, как
	    <hostid role="domainname">example.org</hostid> и в этом домене требуется
	    поставить имена машин в соответствие с их адресами IP.</para>
	</listitem>

	<listitem>
	  <para>блоку адресов IP требуется обратные записи DNS (IP в имена
	    хостов).</para>
	</listitem>

	<listitem>
	  <para>резервный (slave) сервер имён должен отвечать на запросы о
	    домене, когда основной не работает или не доступен.</para>
	</listitem>
      </itemizedlist>

      <para>Кэширующий сервер имён нужен, когда:</para>

      <itemizedlist>
	<listitem>
	  <para>локальный сервер DNS может кэшировать информацию и отвечать на
	    запросы быстрее, чем это происходит при прямом опросе внешнего
	    сервера имён.</para>
	</listitem>

	<listitem>
	  <para>требуется уменьшение общего сетевого трафика (DNS
	    составляет около 5% всего трафика Интернет, или чуть
	    больше).</para>
	</listitem>
      </itemizedlist>

      <para>Например, когда кто-нибудь запрашивает информацию о
	<hostid role="fqdn">www.FreeBSD.org</hostid>, то обычно ресолвер обращается к
	серверу имён вашего провайдера, посылает запрос и ожидает ответа.  С
	локальным кэширующим сервером DNS запрос во внешний мир будет делаться
	всего один раз.  Каждый дополнительный запрос не будет посылаться за
	пределы локальной сети, потому что информация уже имеется в
	кэше.</para>
    </sect2>

    <sect2>
      <title>Как это работает</title>

      <para>Во FreeBSD даемон BIND, по очевидным причинам, называется
	<application>named</application>.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Файл</entry>
	      <entry>Описание</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><application>named</application></entry>
	      <entry>даемон BIND</entry>
	    </row>

	    <row>
	      <entry><command>ndc</command></entry>
	      <entry>программа управления даемоном сервера имён</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>каталог, в котором располагается вся информация о зонах
		BIND</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/named.conf</filename></entry>
	      <entry>конфигурационный файл для даемона</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Файлы зон обычно располагаются в каталоге
	<filename>/etc/namedb</filename> и содержат информацию о зоне DNS,
	за которую отвечает сервер имён.</para>
    </sect2>

    <sect2>
      <title>Запуск BIND</title>

      <indexterm>
	<primary>BIND</primary>
	<secondary>запуск</secondary>
      </indexterm>
      <para>Так как сервер имён BIND устанавливается по умолчанию, его
	настройка сравнительно проста.</para>

      <para>Чтобы даемон <application>named</application> запускался во
	время загрузки, поместите в <filename>/etc/rc.conf</filename>
	следующую строку:</para>

      <programlisting>named_enable="YES"</programlisting>

      <para>Для запуска даемона вручную (после его настройки):</para>

      <screen>&prompt.root; <userinput>ndc start</userinput></screen>
    </sect2>

    <sect2>
      <title>Конфигурационные файлы</title>

      <indexterm>
	<primary>BIND</primary>
	<secondary>конфигурационные файлы</secondary>
      </indexterm>

      <sect3>
	<title>Использование <command>make-localhost</command></title>

	<para>Обязательно выполните следующие команды:</para>

	<screen>&prompt.root; <userinput>cd /etc/namedb
&prompt.root; sh make-localhost</userinput></screen>

	<para>для того, чтобы правильно создать файл
	  <filename>/etc/namedb/localhost.rev</filename> локальной обратной
	  зоны для loopback-интерфейса.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/namedb/named.conf</filename></title>

	<programlisting>// &dollar;FreeBSD$
//
// Refer to the named(8) manual page for details.  If you are ever going
// to setup a primary server, make sure you've understood the hairy
// details of how DNS is working.  Even with simple mistakes, you can
// break connectivity for affected parties, or cause huge amount of
// useless Internet traffic.

options {
	directory "/etc/namedb";

// In addition to the "forwarders" clause, you can force your name
// server to never initiate queries of its own, but always ask its
// forwarders only, by enabling the following line:
//
//      forward only;

// If you've got a DNS server around at your upstream provider, enter
// its IP address here, and enable the line below.  This will make you
// benefit from its cache, thus reduce overall DNS traffic in the
Internet.
/*
	forwarders {
		127.0.0.1;
	};
*/</programlisting>

      <para>Как и говорится в комментариях, если вы хотите получить эффект от
	использования кэша провайдера, то можно включить раздел
	<literal>forwarders</literal>.  В обычном случае сервер имён будет
	рекурсивно опрашивать определённые серверы имён Интернет до тех пор,
	пока не получит ответ на свой запрос.  При включении этого раздела
	он будет автоматически опрашивать сервер имён вашего провайдера (или
	тот, который здесь указан), используя преимущества его кэша.
	наличия нужной информации.  Если соответствующий сервер имён провайдера
	работает быстро и имеет хороший канал связи, то в результате такой
	настройки вы можете получить хороший результат.

      <warning>
	<para><hostid role="ipaddr">127.0.0.1</hostid> здесь
	  работать <emphasis>не будет</emphasis>.  Измените
	  его на IP-адрес сервера имён провайдера.</para>
      </warning>

      <programlisting>/*
	 * If there is a firewall between you and name servers you want
	 * to talk to, you might need to uncomment the query-source
	 * directive below.  Previous versions of BIND always asked
	 * questions using port 53, but BIND 8.1 uses an unprivileged
	 * port by default.
	 */
	// query-source address * port 53;

	/*
	 * If running in a sandbox, you may have to specify a different
	 * location for the dumpfile.
	 */
	// dump-file "s/named_dump.db";
};

// Note: the following will be supported in a future release.
/*
host { any; } {
	topology {
		127.0.0.0/8;
	};
};
*/

// Setting up secondaries is way easier and the rough picture for this
// is explained below.
//
// If you enable a local name server, don't forget to enter 127.0.0.1
// into your /etc/resolv.conf so this server will be queried first.
// Also, make sure to enable it in /etc/rc.conf.

zone "." {
	type hint;
	file "named.root";
};

zone "0.0.127.IN-ADDR.ARPA" {
	type master;
	file "localhost.rev";
};

zone
"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.INT" {
	type master;
	file "localhost.rev";
};

// NB: Do not use the IP addresses below, they are faked, and only
// serve demonstration/documentation purposes!
//
// Example secondary config entries.  It can be convenient to become
// a secondary at least for the zone where your own domain is in.  Ask
// your network administrator for the IP address of the responsible
// primary.
//
// Never forget to include the reverse lookup (IN-ADDR.ARPA) zone!
// (This is the first bytes of the respective IP address, in reverse
// order, with ".IN-ADDR.ARPA" appended.)
//
// Before starting to setup a primary zone, better make sure you fully
// understand how DNS and BIND works, however.  There are sometimes
// unobvious pitfalls.  Setting up a secondary is comparably simpler.
//
// NB: Don't blindly enable the examples below. :-)  Use actual names
// and addresses instead.
//
// NOTE!!! FreeBSD runs BIND in a sandbox (see named_flags in rc.conf).
// The directory containing the secondary zones must be write accessible
// to BIND.  The following sequence is suggested:
//
//      mkdir /etc/namedb/s
//      chown bind:bind /etc/namedb/s
//      chmod 750 /etc/namedb/s</programlisting>

      <para>Дополнительная информация о запуске BIND в ограниченном окружении
	находится в <link linkend="network-named-sandbox">соответствующем
	разделе</link>.</para>

      <programlisting>/*
zone "example.com" {
	type slave;
	file "s/example.com.bak";
	masters {
		192.168.1.1;
	};
};

zone "0.168.192.in-addr.arpa" {
	type slave;
	file "s/0.168.192.in-addr.arpa.bak";
	masters {
		192.168.1.1;
	};
};
*/</programlisting>

      <para>Это примеры описаний прямой и обратной зон из файла
	<filename>named.conf</filename> для вторичных серверов.</para>

      <para>Для каждого новой зоны, которую будет обслуживать сервер имён,
	в файл <filename>named.conf</filename> должна быть добавлена
	запись.</para>

      <para>К примеру, самая простая запись для домена <hostid
	role="domainname">example.org</hostid> может выглядеть вот так:</para>

      <programlisting>zone "example.org" {
	type master;
	file "example.org";
};</programlisting>

      <para>Зона является первичной, что отражается в поле
	<option>type</option>, и информация о зоне хранится в файле
	<filename>/etc/namedb/example.org</filename>, что указывается в
	поле <option>file</option>.</para>

      <programlisting>zone "example.org" {
	type slave;
	file "example.org";
};</programlisting>

      <para>В случае вторичной зоны информация о ней передается с основного
	сервера имён для заданной зоны и сохраняется в указанном файле.  Если
	и когда основной сервер имён выходит и строя или недосягаем, то
	скачанная информация о зоне будет находиться на вторичных серверах и
	они смогут обслуживать эту зону.</para>
    </sect3>

    <sect3>
      <title>Файлы зон</title>

      <para>Пример файла зоны <hostid role="domainname">example.org</hostid>
	для основного
	сервера  (располагающийся в файле
	<filename>/etc/namedb/example.org</filename>) имеет такой
	вид:</para>

      <programlisting>$TTL 3600

example.org. IN SOA ns1.example.org. admin.example.org. (
			5	       ; Serial
			10800	   ; Refresh
			3600	    ; Retry
			604800	  ; Expire
			86400 )	 ; Minimum TTL

; DNS Servers
@       IN NS	   ns1.example.org.
@       IN NS	   ns2.example.org.

; Machine Names
localhost       IN A    127.0.0.1
ns1	     IN A    3.2.1.2
ns2	     IN A    3.2.1.3
mail	    IN A    3.2.1.10
@	       IN A    3.2.1.30

; Aliases
www	     IN CNAME	@

; MX Record
@	       IN MX   10      mail.example.org.</programlisting>

      <para>Заметьте, что все имена хостов, оканчивающиеся на <quote>.</quote>,
	задают полное имя, тогда как все имена без символа <quote>.</quote> на
	конце считаются заданными относительно origin.  Например,
	<literal>www</literal> преобразуется в
	<literal>www.<replaceable>origin</replaceable></literal>.
	В нашем воображаемом файле ориджином является
	<hostid>example.org.</hostid>, так что
	<literal>www</literal> преобразуется в
	<hostid>www.example.org.</hostid></para>

      <para>Файл зоны имеет следующий формат:</para>

      <programlisting>recordname      IN recordtype  value</programlisting>

      <indexterm>
	<primary>DNS</primary>
	<secondary>записи</secondary>
      </indexterm>
      <para>Наиболее часто используемые записи DNS:</para>

      <variablelist>
	<varlistentry>
	  <term>SOA</term>

	  <listitem>
	    <para>начало зоны ответственности</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>NS</term>

	  <listitem>
	    <para>авторитативный сервер имен</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>A</term>

	  <listitem>
	    <para>адрес хоста</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>CNAME</term>

	  <listitem>
	    <para>каноническое имя для алиаса</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>MX</term>

	  <listitem>
	    <para>обмен почтой</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>PTR</term>

	  <listitem>
	    <para>указатель на доменное имя (используется в обратных
	      зонах DNS)</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <programlisting>example.org. IN SOA ns1.example.org. admin.example.org. (
			5	       ; Serial
			10800	   ; Refresh after 3 hours
			3600	    ; Retry after 1 hour
			604800	  ; Expire after 1 week
			86400 )	 ; Minimum TTL of 1 day</programlisting>

      <variablelist>
	<varlistentry>
	  <term><hostid role="domainname">example.org.</hostid></term>

	  <listitem>
	    <para>имя домена, а также ориджин для этого файла зоны.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><hostid role="fqdn">ns1.example.org.</hostid></term>

	  <listitem>
	    <para>основной/авторитативный сервер имён для этой зоны.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>admin.example.org.</literal></term>

	  <listitem>
	    <para>человек, отвечающий за эту зону, адрес электронной почты с
	      подменённым символом <quote>@</quote>.  (<email>admin@example.org</email>
	      становится <literal>admin.example.org</literal>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>5</literal></term>

	  <listitem>
	    <para>последовательный номер файла.  При каждом изменении файла
	      зоны это число должно увеличиваться.  В настоящее время для
	      нумерации многие администраторы предпочитают формат
	      <literal>ггггммддвв</literal>.  <literal>2001041002</literal>
	      будет означать, что
	      файл последний раз изменялся 10.04.2001, а последнее число
	      <literal>02</literal>
	      означает, что это была вторая модификация файла за день.
	      Последовательный номер важен, так как он служит для того, чтобы
	      вторичные серверы узнавали об обновлении зоны.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <programlisting>@       IN NS	   ns1.example.org.</programlisting>

      <para>Это NS-запись.   Такие записи должны иметься для
	всех серверов имён, которые будут отвечать за зону.  Символ
	<literal>@</literal>, используемый здесь, преобразуется в
	<hostid role="domainname">example.org.</hostid>  Этот
	символ <literal>@</literal> соответствует ориджину.</para>

      <programlisting>localhost       IN A    127.0.0.1
ns1	     IN A    3.2.1.2
ns2	     IN A    3.2.1.3
mail	    IN A    3.2.1.10
@	       IN A    3.2.1.30</programlisting>

      <para>Записи типа A служат для обозначения имён машин.  Как это видно
	выше, имя <hostid role="fqdn">ns1.example.org</hostid> будет
	преобразовано в
	<hostid role="ipaddr">3.2.1.2</hostid>.  И снова здесь используется
	символ ориджина <literal>@</literal>, обозначая, что
	<hostid role="domainname">example.org</hostid> будет преобразовано
	в <hostid
	role="ipaddr">3.2.1.30</hostid>.</para>

      <programlisting>www	     IN CNAME	@</programlisting>

      <para>Записи с каноническими именами обычно используются для присвоения
	машинам псевдонимов.  В этом примере <hostid>www</hostid> является
	псевдонимом для машины, соответствующей ориджину, то есть
	<hostid role="domainname">example.org</hostid> (<hostid
	role="ipaddr">3.2.1.30</hostid>).
	Записи CNAME могут использоваться для присвоения
	псевдонимов именам хостов или для использования одного имени
	несколькими машинами по очереди.</para>

	<indexterm>
	  <primary>MX record</primary>
	</indexterm>

      <programlisting>@	       IN MX   10      mail.example.org.</programlisting>

      <para>MX-запись указывает, какие почтовые серверы
	отвечают за обработку входящей электронной почты для зоны.  <hostid
	role="fqdn">mail.example.org</hostid> является именем почтового
	сервера, а 10 обозначает приоритет этого почтового сервера.</para>

      <para>Можно иметь несколько почтовых серверов с приоритетами 3, 2 и 1.
	Почтовый сервер, пытающийся доставить почту для <hostid
	role="domainname">example.org</hostid>,
	сначала попробует связаться с машиной, имеющий MX-запись с самым
	большим приоритетом, затем с приоритетом поменьше и так далее, до тех
	пор, пока почта не будет отправлена.</para>

      <para>Для файлов зон in-addr.arpa (обратные записи DNS) используется тот
	же самый формат, отличающийся только использованием записей
	PTR вместо A или
	CNAME.</para>

      <programlisting>$TTL 3600

1.2.3.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
			5	       ; Serial
			10800	   ; Refresh
			3600	    ; Retry
			604800	  ; Expire
			3600 )	  ; Minimum

@       IN NS   ns1.example.org.
@       IN NS   ns2.example.org.

2       IN PTR  ns1.example.org.
3       IN PTR  ns2.example.org.
10      IN PTR  mail.example.org.
30      IN PTR  example.org.</programlisting>

      <para>В этом файле дается полное соответствие имён хостов IP-адресам в
	нашем описанном ранее вымышленном домене.</para>
    </sect3>
  </sect2>

    <sect2>
      <title>Кэширующий сервер имён</title>
      <indexterm>
	<primary>BIND</primary>
	<secondary>кэширующий сервер имён</secondary>
      </indexterm>

      <para>Кэширующий сервер имён - это сервер имён, не отвечающий ни
	за какую зону.  Он просто выполняет запросы от своего имени и сохраняет
	результаты для последующего использования.  Для настройки такого
	сервера достаточно исключить все описания зон из стандартной
	конфигурации сервера имён.</para>
    </sect2>

    <sect2 id="network-named-sandbox">
      <title>Запуск <application>named</application> в песочнице</title>

      <indexterm>
	<primary>BIND</primary>
	<secondary>работа в песочнице</secondary>
      </indexterm>

      <indexterm>
	<primary><command>chroot</command></primary>
      </indexterm>

      <para>Для дополнительной безопасности вам может потребоваться запускать
	&man.named.8; с правами непривилегированного пользователя и настроить
	его на выполнение &man.chroot.8; в каталог-песочницу.  Это позволит
	сделать недоступным для даемона <application>named</application> все,
	что расположено вне песочницы.  Если <application>named</application>
	будет взломан, то это поможет уменьшить возможный ущерб.  По умолчанию
	во FreeBSD имеются пользователь и группа с именами
	<groupname>bind</groupname>, которые предназначены именно для такого
	использования.</para>

      <note>
	<para>Многие рекомендуют вместо настройки
	  <application>named</application> на использование
	  <command>chroot</command>, запускать <application>named</application>
	  внутри &man.jail.8;.  В этом разделе такой подход не
	  рассматривается.</para>
      </note>

      <para>Так как <application>named</application> не сможет обратиться ни к
	чему вне песочницы (например, совместно используемым библиотекам,
	сокетам протоколов и так далее), то нужно выполнить несколько шагов,
	чтобы <application>named</application> смог работать нормально.  В
	следующем списке предполагается, что каталогом песочницы является
	<filename>/etc/namedb</filename> и что вы не делали никаких изменений
	в содержимом этого каталога.  Выполните следующие шаги, работая как
	пользователь <username>root</username>:</para>

      <itemizedlist>
	<listitem>
	  <para>Создайте все каталоги, которые ожидает увидеть
	    <application>named</application>:</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>mkdir -p bin dev etc var/tmp var/run master slave</userinput>
&prompt.root; <userinput>chown bind:bind slave var/*</userinput><co id="chown-slave"></screen>

	  <calloutlist>
	    <callout arearefs="chown-slave">
	      <para>Программе <application>named</application> нужен доступ с
		правом записи в эти каталоги, так что это все, что мы ей
		предоставим.</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
	  <para>Измените и создайте базовые файлы зоны и настроек:</para>

	  <screen>&prompt.root; <userinput>cp /etc/localtime etc</userinput><co id="localtime">
&prompt.root; <userinput>mv named.conf etc && ln -sf etc/named.conf</userinput>
&prompt.root; <userinput>mv named.root master</userinput>
<!-- Следующее мне не нравится -->
&prompt.root; <userinput>sh make-localhost && mv localhost.rev localhost-v6.rev master</userinput>
&prompt.root; <userinput>cat > master/named.localhost
$ORIGIN localhost.
$TTL 6h
@	IN	SOA	localhost. postmaster.localhost. (
			1	; serial
			3600	; refresh
			1800	; retry
			604800	; expiration
			3600 )	; minimum
	IN	NS	localhost.
	IN	A		127.0.0.1
^D</userinput></screen>

	  <calloutlist>
	    <callout arearefs="localtime">
	      <para>Это позволит программе <application>named</application>
		протоколировать правильное время в &man.syslogd.8;.</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<indexterm><primary>syslog</primary></indexterm>
	<indexterm><primary>лог файлы</primary>
	  <secondary>DNS</secondary></indexterm>

	<listitem>
	  <para>Если вы используете &os; версии ранее 4.9-RELEASE, то постройте
	    статически скомпонованную копию
	    <application>named-xfer</application> и скопируйте её в
	    песочницу:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make NOSHARED=yes all</userinput>
&prompt.root; <userinput>cp named-xfer /etc/namedb/bin && chmod 555 /etc/namedb/bin/named-xfer</userinput><co id="clean-cruft"></screen>

	  <para>После установки статически скомпонованного
	    <command>named-xfer</command>, во избежание появления старых копий
	    библиотек и программ в дереве исходного кода, требуется некоторая
	    зачистка:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	  <calloutlist>
	    <callout arearefs="clean-cruft">
	      <para>Иногда при выполнении этого шага возникают ошибки.  Если
		это случилось, выполните такую команду:</para>

	      <screen>&prompt.root; <userinput>cd /usr/src && make cleandir && make cleandir</userinput></screen>

	      <para>и удалите ваше дерево <filename>/usr/obj</filename>:</para>

	      <screen>&prompt.root; <userinput>rm -fr /usr/obj && mkdir /usr/obj</userinput></screen>

	      <para>При этом из вашего дерева исходных текстов будет удалён
		весь <quote>мусор</quote>, и повторение вышеописанных шагов
		должно выполниться успешно.</para>
	    </callout>
	  </calloutlist>

	  <para>Если вы используете &os; 4.9-RELEASE или более позднюю версию,
	    то копия <command>named-xfer</command> в каталоге
	    <filename>/usr/libexec</filename> по умолчанию является статически
	    скомпонованной, и вы можете просто скопировать её в песочницу при
	    помощи команды &man.cp.1;.</para>
	</listitem>

	<listitem>
	  <para>Создайте файл устройства <filename>dev/null</filename>,
	    который <application>named</application> может видеть и писать в
	    него:</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb/dev && mknod null c 2 2</userinput>
&prompt.root; <userinput>chmod 666 null</userinput></screen>
	</listitem>

	<listitem>
	  <para>Создайте символическую ссылку
	    <filename> /var/run/ndc</filename> на
	    <filename>/etc/namedb/var/run/ndc</filename>:</para>

	  <screen>&prompt.root; <userinput>ln -sf /etc/namedb/var/run/ndc /var/run/ndc</userinput></screen>

	  <note>
	    <para>Это просто для того, чтобы не задавать опцию
	      <option>-c</option> при каждом запуске &man.ndc.8;.  Так как
	      содержимое каталога <filename>/var/run</filename> удаляется
	      при загрузке, и если это
	      показалось вам полезным, то вы можете добавить эту команду
	      в <filename>crontab</filename> для <username>root</username>
	      с использованием параметра
	      <option>@reboot</option>.  Обратитесь к справочной странице по
	      &man.crontab.5; для получения более полной информации
	      относительно этого.</para>
	  </note>
	</listitem>

	<indexterm><primary>syslog</primary></indexterm>
	<indexterm><primary>лог файлы</primary>
	  <secondary>named</secondary></indexterm>

	<listitem>
	  <para>Настройте &man.syslogd.8; на создание дополнительного
	    протоколирующего сокета <devicename>log</devicename>, в который
	    может писать <application>named</application>.  Для этого добавьте
	    <literal>-l /etc/namedb/dev/log</literal> к переменной
	    <varname>syslogd_flags</varname> из файла
	    <filename>/etc/rc.conf</filename>.</para>
	</listitem>

	<indexterm><primary><command>chroot</command></primary></indexterm>

	<listitem>
	  <para>Задайте запуск <application>named</application> и выполнение
	    <command>chroot</command> в песочницу, добавив следующее в
	    <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>named_enable="YES"
named_flags="-u bind -g bind -t /etc/namedb /etc/named.conf"</programlisting>

	  <note>
	    <para>Заметьте, что конфигурационный файл
	      <replaceable>/etc/named.conf</replaceable> именуется по полному
	      имени <emphasis>относительно песочницы</emphasis>, то есть в
	      вышеприведённой строке указывается файл, который на самом деле
	      является файлом
	      <filename>/etc/namedb/etc/named.conf</filename>.</para>
	  </note>
	</listitem>
      </itemizedlist>

      <para>Следующим шагом является редактирование файла
	<filename>/etc/namedb/etc/named.conf</filename> так, чтобы
	<application>named</application> знал, какую зону загружать и где найти
	их на диске.  Далее следует прокомментированный пример (все, что
	специально не прокомментировано, ничем не отличается от настройки
	сервера DNS, работающего не в песочнице):</para>

      <programlisting>options {
	directory "/";<co id="directory">
	named-xfer "/bin/named-xfer";<co id="named-xfer">
	version "";		// Не выдавайте версию BIND
	query-source address * port 53;
};
// управляющий сокет ndc
controls {
	unix "/var/run/ndc" perm 0600 owner 0 group 0;
};
// Далее следуют зоны:
zone "localhost" IN {
	type master;
	file "master/named.localhost";<co id="master">
	allow-transfer { localhost; };
	notify no;
};
zone "0.0.127.in-addr.arpa" IN {
	type master;
	file "master/localhost.rev";
	allow-transfer { localhost; };
	notify no;
};
zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.int" {
       type master;
       file "master/localhost-v6.rev";
       allow-transfer { localhost; };
       notify no;
};
zone "." IN {
	type hint;
	file "master/named.root";
};
zone "private.example.net" in {
	type master;
	file "master/private.example.net.db";
	allow-transfer { 192.168.10.0/24; };
};
zone "10.168.192.in-addr.arpa" in {
	type slave;
	masters { 192.168.10.2; };
	file "slave/192.168.10.db";<co id="slave">
};</programlisting>

      <calloutlist>
	<callout arearefs="directory">
	  <para>В директиве <literal>directory</literal> указан каталог
	    <filename>/</filename>, так как все файлы, которые нужны для
	    <application>named</application>, находятся внутри этого каталога
	    (вспомните, что это равнозначно <quote>обычному</quote>
	    пользовательскому <filename>/etc/namedb</filename>).</para>
	</callout>

	<callout arearefs="named-xfer">
	  <para>Задает полный путь к двоичному выполнимому файлу
	    <command>named-xfer</command> (внутри границ видимости
	    <application>named</application>).  Это необходимо, так как
	    <application>named</application> компилируется с тем, чтобы
	    брать <command>named-xfer</command> по умолчанию из
	    <filename>/usr/libexec</filename>.</para>
	</callout>

	<callout arearefs="master">
	  <para>Задает имя файла (относительно директивы
	    <literal>directory</literal> выше), в котором
	    <application>named</application> может найти файл зоны для этой
	    зоны.</para>
	</callout>

	<callout arearefs="slave">
	  <para>Задает имя файла (относительно директивы
	    <literal>directory</literal> выше), в котором
	    <application>named</application> должен записывать копию файла
	    зоны для этой зоны после успешной передачи ее с основного сервера.
	    Вот почему нам нужно изменить владельца каталога
	    <filename>slave</filename> на <groupname>bind</groupname> на этапах
	    настроек выше.</para>
	</callout>
      </calloutlist>

      <para>После выполнения шагов выше либо перезагрузите ваш сервер, либо
	перезапустите &man.syslogd.8; и запустите &man.named.8;, не забыв
	использовать новые опции, заданные в <varname>syslogd_flags</varname> и
	<varname>named_flags</varname>.  Теперь
	<application>named</application> должен заработать в песочнице!</para>
    </sect2>

    <sect2>
      <title>Безопасность</title>

      <para>Хотя BIND является самой распространенной реализацией DNS, всегда
	стоит вопрос об обеспечении безопасности.  Время от времени
	обнаруживаются возможные и реальные бреши в безопасности.</para>

      <para>Весьма полезно прочесть сообщения безопасности <ulink
	url="http://www.cert.org/">CERT</ulink> и подписаться на
	&a.security-notifications; для того, чтобы быть в курсе
	текущих проблем с обеспечением безопасности Internet и FreeBSD.</para>

      <tip>
	<para>Если возникают проблемы, то наличие последних исходных текстов и
	  свежеоткомпилированного <application>named</application>
	  не помешает.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Дополнительная литература</title>

      <para>Справочная информация по BIND/<application>named</application>:
	&man.ndc.8;, &man.named.8; и
	&man.named.conf.5;</para>

      <itemizedlist>
	<listitem>
	  <para><ulink url="http://www.isc.org/products/BIND/">
	    Официальная страница ISC BIND</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="http://www.nominum.com/getOpenSourceResource.php?id=6">
	    FAQ по BIND</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.oreilly.com/catalog/dns4/">
	    Книга издательства O'Reilly DNS and BIND 4th
	    Edition</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="ftp://ftp.isi.edu/in-notes/rfc1034.txt">RFC1034 - Domain
	    Names - Concepts and Facilities</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="ftp://ftp.isi.edu/in-notes/rfc1035.txt">RFC1035 - Domain
	    Names - Implementation and Specification</ulink></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="network-bind9">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Автор: </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Dmitry</firstname>
	  <surname>Morozovsky</surname>
	  <contrib>Перевод на русский язык: </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title><acronym>BIND</acronym>9 and &os;</title>

<!-- комментарий-введение trhodes@ shamelessly skipped ;) -->

    <indexterm><primary>bind9</primary>
      <secondary>установка</secondary></indexterm>

    <para>&os; начиная с версии&nbsp;5.3 содержит в базовой поставке
      сервер <acronym>DNS</acronym> <acronym>BIND</acronym>9.
      Среди прочих нововведений стоит отметить новые возможности, связанные
      с безопасностью, новую организацию файлов конфигурации и автоматическое
      использование опции &man.chroot.8;.  Первая часть этой главы посвящена
      обсуждению новых возможностей и их использования, вторая описывает
      процесс обновления сервера DNS при переходе на &os;&nbsp;5.3.  Мы будем
      ссылаться на сервер <acronym>BIND</acronym> как &man.named.8;.
      Мы подразумеваем, что читатель знаком с терминологией, описываемой в
      предыдущей главе.</para>

    <para>Файлы конфигурации для <command>named</command> в настоящее время
      располагаются в каталоге
      <filename role="directory">/var/named/etc/namedb/</filename> и требуют
      модификации перед началом использования сервера.  Большая часть работы
      по конфигурации сервера DNS происходит именно в этом каталоге.</para>

    <sect2>
      <title>Конфигурация основной (Master) зоны</title>

      <para>Для создания основной зоны перейдите в каталог
	<filename role="directory">/var/named/etc/namedb/</filename>
	и выполните команду</para>

      <screen>&prompt.root; <userinput>sh make-localhost</userinput></screen>

      <para>При удачном стечении обстоятельств в каталоге
	<filename role="directory">master</filename> появится два новых файла:
	<filename>localhost.rev</filename> для локального домена и
	<filename>localhost-v6.rev</filename> для локальной зоны
	<acronym>IPv6</acronym>.  В поставляемом стандартном файле
	конфигурации <filename>named.conf</filename> уже есть ссылки на оба
	файла зон.</para>
    </sect2>

    <sect2>
      <title>Конфигурация зависимой (Slave) Зоны</title>

      <para>Дополнительные домены и поддомены могут быть добавлены как
	зависимые зоны.  В большинстве случаев достаточно просто скопировать
	файл <filename>master/localhost.rev</filename> в каталог
	<filename role="directory">slave</filename> и изменить копию.
	После изменения файлов зон нажно добавить ссылки на них в
	основной файл конфигурации <filename>named.conf</filename>, например,
	так:</para>

      <programlisting>zone "example.com" {
	type slave;
	file "slave/example.com";
	masters {
		10.0.0.1;
	};
};

zone "0.168.192.in-addr.arpa" {
	type slave;
	file "slave/0.168.192.in-addr.arpa";
	masters {
		10.0.0.1;
	};
};</programlisting>

      <!-- XXX What the heck does the following mean???
      <para>Note well that in this example, the master
	<acronym>IP</acronym> address is the primary domain server
	from which the zones are transferred; it does not necessary serve
	as <acronym>DNS</acronym> server itself.</para>

	Wild-guess translation follows.
      -->

      <para>Отметим, что использованный в этом примере <acronym>IP</acronym>
	адрес является адресом, с которого будут копироваться файлы зон;
	этот адрес не обязательно является публичным сервером
	<acronym>DNS</acronym>.</para>
    </sect2>

    <sect2>
      <title>Стартовая конфигурация системы</title>

      <para>Для автоматического запуска даемона <command>named</command>
	при загрузке системы добавьте в файл стартовой конфигурации
	<filename>rc.conf</filename> строку</para>

      <programlisting>named_enable="YES"</programlisting>

      <para>Есть и другие параметры конфигурации, но эта строка&nbsp;&mdash;
	минимально необходима.  Список параметров можно найти на странице
	справочника &man.rc.conf.5;.  Если запуск <command>named</command>
	не разрешен в <filename>rc.conf</filename>, сервер можно запустить
	вручную командой</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/named start</userinput></screen>
    </sect2>

    <sect2>
      <title><acronym>BIND</acronym>9: вопросы безопасности</title>

      <para>&os автоматически запускает <command>named</command>
	в ограниченном пространстве &man.chroot.8;; кроме того, существует
	еще несколько средств, помогающих защитить сервис
	<acronym>DNS</acronym> от возможных атак.</para>

      <sect3>
	<title>Списки ограничения доступа</title>

	<para>Для ограничения доступа к зонам могут применяться списки
	  доступа.  Для этого опишите для домена список <acronym>IP</acronym>
	  адресов, которым разрешены запросы к содержимому доменной зоны, и
	  используйте имя этого списка в конфигурации зоны.
	  Вот пример описания списка ограничения доступа:</para>

	<programlisting>acl "example.com" {
	192.168.0.0/24;
};

zone "example.com" {
	type slave;
	file "slave/example.com";
	masters {
		10.0.0.1;
	};
	allow-query { example.com; };
};

zone "0.168.192.in-addr.arpa" {
	type slave;
	file "slave/0.168.192.in-addr.arpa";
	masters {
		10.0.0.1;
	};
	allow-query { example.com; };
};</programlisting>
      </sect3>

      <sect3>
	<title>Версия сервера</title>

	<para>Разрешать всем запросы о версии вашего <acronym>DNS</acronym>
	  сервера может быть не самой лучшей идеей: возможный злоумышленник
	  может воспользоваться ей для выяснения известных ошибок и
	  уязвимостей и применить их вашего сервера.  Для предотвращения этого
	  в раздел <literal>options</literal> файла конфигурации
	  <filename>named.conf</filename> можно вписать строку, скрывающую
	  версию сервера:</para>

	<programlisting>options {
	directory       "/etc/namedb";
	pid-file	"/var/run/named/pid";
	dump-file       "/var/dump/named_dump.db";
	statistics-file "/var/stats/named.stats";
	version		"None of your business";</programlisting>
      </sect3>
<!-- Here is where I stopped for now
      <sect3>
	<title>Authentication</title>

	<para> ... </para>

-->
    </sect2>
  </sect1>

  <sect1 id="network-apache">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Apache HTTP сервер</title>

    <indexterm><primary>веб сервер</primary>
      <secondary>настройка</secondary></indexterm>
    <indexterm><primary>Apache</primary></indexterm>

    <sect2>
      <title>Обзор</title>

      <para>&os; используется в качестве платформы для многих из самых
	нагруженных серверов в мире.  Большинство серверов в интернет
	используют <application>Apache HTTP сервер</application>.
	Пакеты <application>Apache</application> должны быть включены
	в поставку FreeBSD.  Если вы не установили их во вместе с
	системой, воспользуйтесь портами <filename
	role="package">www/apache13</filename> или <filename
	role="package">www/apache2</filename>.</para>

      <para>Как только <application>Apache</application> был успешно
	установлен, его необходимо настроить.</para>

      <note><para>В этом разделе рассказывается о версии 1.3.X
	<application>Apache HTTP сервера</application>, поскольку
	эта версия наиболее широко используется в &os;.
	<application>Apache&nbsp;2.X</application>
	содержит много новых технологий, но здесь они не обсуждаются.
	За дополнительной информацией о
	<application>Apache&nbsp;2.X</application>, обращайтесь к <ulink
	url="http://httpd.apache.org/"></ulink>.</para></note>

    </sect2>

    <sect2>
      <title>Настройка</title>

      <indexterm><primary>Apache</primary>
	<secondary>файл настройки</secondary></indexterm>

      <para>В &os; основной файл настройки <application>Apache HTTP сервера</application>
	устанавливается в
	<filename>/usr/local/etc/apache/httpd.conf</filename>.
	Это обычный текстовый &unix; файл настройки с строками
	комментариев, начинающимися с символа <literal>#</literal>.
	Исчерпывающее описание всех возможных параметров настройки
	находится за пределом рассмотрения этой книги, поэтому
	здесь будут описаны только наиболее часто модифицируемые
	директивы.</para>

      <variablelist>
	<varlistentry>
	  <term><literal>ServerRoot "/usr/local"</literal></term>

	  <listitem>
	    <para>Указывает верхний каталог установки
	      <application>Apache</application> по
	      умолчанию.  Бинарные файлы находятся в
	      <filename role="directory">bin</filename> и
	      <filename role="directory">sbin</filename>, подкаталоги
	      расположены относительно корневого каталога сервера, файлы
	      настройки находятся в
	      <filename role="directory">etc/apache</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>ServerAdmin you@your.address</literal></term>

	  <listitem>
	    <para>Адрес, на который должны будут отправляться
	      сообщения о проблемах с сервером.  Этот адрес
	      выводится на некоторые генерируемые сервером
	      страницы, например с сообщениями об ошибках.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>ServerName www.example.com</literal></term>

	  <listitem>
	    <para><literal>ServerName</literal> позволяет вам устанавливать имя хоста,
	      которое отправляется обратно клиентам, если оно
	      отличается от того, с которым настроен хост
	      (например, использование <hostid>www</hostid> вместо реального
	      имени хоста).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>DocumentRoot "/usr/local/www/data"</literal></term>

	  <listitem>
	    <para><literal>DocumentRoot</literal>: Каталог, внутри которого будут храниться
	      документы.  По умолчанию, все запросы обрабатываются внутри
	      этого каталога, но символические ссылки и синонимы могут
	      использоваться для указания на другие каталоги.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Хорошей идеей будет сделать резервные копии настроек
	<application>Apache</application> перед внесением изменений.   Как только вы будете
	удовлетворены первоначальной настройкой, можно запускать
	<application>Apache</application>.</para>

<!-- sect3 for performance tuning directives?  maxservers minservers -->
<!-- etc..?? -->

<!-- Advanced configuration section.

Performance tuning directives.

Log file format -->

    </sect2>

    <sect2>
      <title>Запуск <application>Apache</application></title>

      <indexterm><primary>Apache</primary>
	<secondary>запуск или остановка</secondary></indexterm>

      <para><application>Apache</application> не запускается из
	<application>inetd</application>, как это делают многие
	другие сетевые серверы.  Он настроен для автономного запуска,
	чтобы обеспечивать большую производительность при обработке
	HTTP запросов от браузеров клиентов.  Для упрощения запуска,
	остановки и перезапуска сервера существует shell скрипт.
	Для запуска <application>Apache</application> в первый раз
	просто выполните:</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/apachectl start</userinput></screen>

      <para>Вы можете остановить сервер в любой момент, выполнив:</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/apachectl stop</userinput></screen>

      <para>После внесения любых изменений в файл настроек, вам потребуется
	перезапустить сервер:</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/apachectl restart</userinput></screen>

      <para>Для запуска <application>Apache</application> при старте системы,
	добавьте в <filename>/etc/rc.conf</filename> следующую строку:</para>

      <programlisting>apache_enable="YES"</programlisting>

      <para>Если вы хотите передать программе <application>Apache</application>
	<command>httpd</command> дополнительные параметры командной
	при загрузке системы, они могут быть помещены в дополнительную
	строку <filename>rc.conf</filename>:</para>

      <programlisting>apache_flags=""</programlisting>

      <para>Теперь, когда веб сервер запущен, вы можете просмотреть свой веб
	сайт, задав в строке браузера адрес
	<literal>http://localhost/</literal>.  По умолчанию отображается
	веб страница
	<filename>/usr/local/www/data/index.html</filename>.</para>

    </sect2>

    <sect2>
      <title>Виртуальный хостинг</title>

      <para><application>Apache</application> поддерживает два различных
	типа виртуального хостинга (Virtual Hosting).  Первый метод
	основан на именах (Name-based Virtual Hosting).  Он использует
	полученные от клиента заголовки HTTP/1.1 для определения имени
	хоста.  Это позволяет многим различным доменам использовать
	один и тот же IP адрес.</para>

      <para>Для настройки <application>Apache</application> на использование
	этого типа хостинга добавьте в <filename>httpd.conf</filename>
	запись подобную следующей:</para>

      <programlisting>NameVirtualHost *</programlisting>

      <para>Если веб сервер назывался <hostid role="fqdn">www.domain.tld</hostid> и
	вы хотите настроить виртуальный домен для
	<hostid role="fqdn">www.someotherdomain.tld</hostid>, необходимо добавить
	в <filename>httpd.conf</filename> следующие записи:</para>

      <screen>&lt;VirtualHost *&gt;
ServerName www.domain.tld
DocumentRoot /www/domain.tld
&lt;VirtualHost&gt;

&lt;VirtualHost *&gt;
ServerName www.someotherdomain.tld
DocumentRoot /www/someotherdomain.tld
&lt;/VirtualHost&gt;</screen>

      <para>Замените адреса и пути к документам на те, что вы будете
	использовать.</para>

      <para>За дополнительной информацией по настройке виртуальных хостов
	обращайтесь к официальной документации
	<application>Apache</application>: <ulink
	url="http://httpd.apache.org/docs/vhosts/"></ulink></para>

    </sect2>

    <sect2>
      <title>Модули Apache</title>

      <indexterm><primary>Apache</primary>
	<secondary>модули</secondary></indexterm>

      <para>Существуют множество различных модулей
	<application>Apache</application>,
	которые добавляют функциональность к основному
	серверу.  Коллекция портов FreeBSD предоставляет
	простой способ установки <application>Apache</application>
	с некоторыми наиболее популярными дополнительными
	модулями.</para>

      <sect3>
	<title>mod_ssl</title>

	<indexterm><primary>веб сервер</primary>
	  <secondary>защита</secondary></indexterm>
	<indexterm><primary>SSL</primary></indexterm>
	<indexterm><primary>криптография</primary></indexterm>

	<para>Модуль <application>mod_ssl</application> использует
	  библиотеку OpenSSL для
	  сильной криптографии через протоколы Secure Sockets Layer
	  (SSL v2/v3) и Transport Layer Security (TLS v1).
	  Этот модуль содержит все необходимое для запроса
	  подписанного сертификата из центра сертификации
	  для защищенного веб сервера на &os;.</para>

	<para>Если вы еще не установили
	  <application>Apache</application>, версия
	  <application>Apache</application> с
	  <application>mod_ssl</application> может быть установлена
	  через порт <filename
	  role="package">www/apache13-modssl</filename>.</para>

<!-- XXX add more information about configuring mod_ssl here. -->
<!-- Generating keys, getting the key signed, setting up your secure -->
<!-- web server! -->
      </sect3>

      <sect3>
	<title>mod_perl</title>

	<indexterm><primary>Perl</primary></indexterm>

	<para>Проект интеграции
	  <application>Apache</application>/Perl объединяет мощь
	  языка программирования Perl и HTTP сервера
	  <application>Apache</application>.
	  С модулем <application>mod_perl</application> возможно
	  написание модулей <application>Apache</application>
	  полностью на Perl.  Кроме того, постоянно
	  запущенный встроенный в сервер интерпретатор
	  позволяет не тратить ресурсы на запуск внешнего
	  интерпретатора и время на запуск Perl.</para>

	<para>Если вы еще не установили <application>Apache</application>,
	  его версия с модулем <application>mod_perl</application> может
	  быть установлена через
	  порт <filename
	  role="package">www/apache13-modperl</filename>.</para>
      </sect3>

      <sect3>
	<title>PHP</title>

	<indexterm><primary>PHP</primary></indexterm>

	<para>PHP, сокращение от <quote>PHP: Hypertext
	  Preprocessor</quote> это широко используемый Open Source
	  скриптовый язык общего назначения, который в основном
	  предназначен для веб разработки и может быть встроен в
	  HTML.  Его синтаксис был взят от C, &java;, и Perl и язык
	  легок в изучении.  Основное преимущество языка в том, что
	  он позволяет веб разработчикам создавать веб страницы быстро,
	  но есть и множество других возможностей.</para>

	<para>PHP может быть установлен из порта <filename
	  role="package">lang/php5</filename>.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-samba">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Файл сервер и печать для &microsoft.windows; клиентов
      (Samba)</title>

    <indexterm><primary>Samba сервер</primary></indexterm>
    <indexterm><primary>Microsoft Windows</primary></indexterm>
    <indexterm>
      <primary>файл сервер</primary>
      <secondary>Windows клиенты</secondary>
    </indexterm>
    <indexterm>
      <primary>принт сервер</primary>
      <secondary>Windows клиенты</secondary>
    </indexterm>

    <sect2>
      <title>Обзор</title>

      <para><application>Samba</application> это популярный пакет
	программ с открытыми исходными текстами, которая предоставляет
	файловые и принт-сервисы &microsoft.windows; клиентам.
	Эти клиенты могут подключаться и использовать файловое
	пространство FreeBSD, как если бы это был локальный диск,
	или принтеры FreeBSD, как если бы это были локальные
	принтеры.</para>

      <para>Пакет <application>Samba</application> должен быть включен
	в поставку FreeBSD.  Если вы не установили
	<application>Samba</application> при первой установке системы,
	ее можно установить из порта или пакета <filename
	role="package">net/samba3</filename>.</para>

<!-- mention LDAP, Active Directory, WinBIND, ACL, Quotas, PAM, .. -->

    </sect2>

    <sect2>
      <title>Настройка</title>

      <para>Файл настройки <application>Samba</application> по умолчанию
	устанавливается в
	<filename>/usr/local/etc/smb.conf.default</filename>.  Этот файл
	необходимо скопировать в
	<filename>/usr/local/etc/smb.conf</filename> и отредактировать
	перед использованием <application>Samba</application>.</para>

      <para>В файле <filename>smb.conf</filename> находится информация,
	необходимая для работы <application>Samba</application>,
	например определение принтеров и <quote>общих каталогов</quote>,
	которые будут использоваться совместно с &windows; клиентами.
	В пакет <application>Samba</application> входит программа с
	веб интерфейсом, называемая <application>swat</application>,
	которая дает простой способ редактирования файла
	<filename>smb.conf</filename>.</para>

      <sect3>
	<title>Использование Samba Web Administration Tool (SWAT)</title>

	<para>Программа веб администрирования Samba (Samba Web
	  Administration Tool, SWAT) запускается как даемон из
	  <application>inetd</application>.  Следовательно, в
	  <filename>/etc/inetd.conf</filename> необходимо снять комментарий
	  перед тем, как использовать <application>swat</application> для
	  настройки <application>Samba</application>:</para>

	<programlisting>swat   stream  tcp     nowait/400      root    /usr/local/sbin/swat</programlisting>

	<para>Как описано в <xref linkend="network-inetd-hangup">,
	  после изменения настроек <application>inetd</application>
	  необходимо отправить HangUP сигнал.</para>

	<para>Как только <application>swat</application> был включен
	  <filename>inetd.conf</filename>, вы можете использовать
	  браузер для подключения к <ulink
	  url="http://localhost:901"></ulink>.
	  Сначала необходимо зарегистрироваться с системной
	  учетной записью <username>root</username>.</para>

<!-- XXX screenshots go here, loader is creating them -->

	<para>После успешного входа на основную страницу настройки
	  <application>Samba</application>, вы можете просмотреть
	  документацию или начать настройку, нажав на кнопку
	  <guimenu>Globals</guimenu>.  Раздел <guimenu>Globals</guimenu>
	  соответствует переменным,
	  установленным в разделе <literal>[global]</literal> файла
	  <filename>/usr/local/etc/smb.conf</filename>.</para>
      </sect3>

      <sect3>
	<title>Глобальные настройки</title>

	<para>Независимо от того, используете ли вы
	  <application>swat</application>, или редактируете
	  <filename>/usr/local/etc/smb.conf</filename> непосредственно,
	  первые директивы, которые вы скорее всего встретите при
	  настройке <application>Samba</application>, будут
	  следующими:</para>

	<variablelist>
	  <varlistentry>
	    <term><literal>workgroup</literal></term>

	    <listitem>
	      <para>Имя домена или рабочей группы NT для компьютеров,
		которые будут получать доступ к этому серверу.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>netbios name</literal></term>
	    <indexterm><primary>NetBIOS</primary></indexterm>

	    <listitem>
	      <para>Устанавливает имя NetBIOS, под которым будет
		работать <application>Samba</application> сервер.  По
		умолчанию оно устанавливается
		равным первому компоненту DNS имени хоста.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>server string</literal></term>

	    <listitem>
	      <para>Устанавливает строку, которая будет показана командой
		<command>net view</command> и некоторыми другими сетевыми
		инструментами, которые отображают строку описания
		сервера.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>Настройки безопасности</title>

	<para>Две из наиболее важных настроек в
	  <filename>/usr/local/etc/smb.conf</filename> отвечают за
	  выбор модели безопасности и за формат паролей для
	  клиентов.  Эти параметры контролируются следующими
	  директивами:</para>

	<variablelist>
	  <varlistentry>
	    <term><literal>security</literal></term>

	    <listitem>
	      <para>Два наиболее часто используемых параметра это
		<literal>security = share</literal> и <literal>security
		= user</literal>.  Если имена пользователей для клиентов
		совпадают с их именами на компьютере &os;, вы возможно
		захотите включить безопасность уровня пользователя (user).
		Это политика безопасности по умолчанию, она требует,
		чтобы клиент авторизовался перед доступом к совместно
		используемым ресурсам.</para>

	      <para>На уровне безопасности share клиенту не требуется
		входить на сервер перед подключением к ресурсу.
		Эта модель безопасности использовалась по умолчанию
		в старых версиях <application>Samba</application>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>passdb backend</literal></term>

	    <indexterm><primary>NIS+</primary></indexterm>
	    <indexterm><primary>LDAP</primary></indexterm>
	    <indexterm><primary>SQL база данных</primary></indexterm>

	    <listitem>
	      <para><application>Samba</application> поддерживает
		несколько различных подсистем аутентификации.  Вы можете
		аутентифицировать клиентов с помощью LDAP, NIS+,
		базы данных SQL, или через модифицированный файл
		паролей.  Метод аутентификации по умолчанию
		<literal>smbpasswd</literal>, и здесь рассматривается
		только он.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Предполагая, что используется подсистема по умолчанию
	  <literal>smbpasswd</literal>, необходимо создать файл
	  <filename>/usr/local/private/smbpasswd</filename>, чтобы
	  <application>Samba</application> могла аутентифицировать
	  клиентов.  Если вы хотите разрешить всем учетным записям
	  &unix; доступ с &windows; клиентов, используйте следующую
	  команду:</para>

	<screen>&prompt.root; <userinput>cat /etc/passwd | grep -v "^#" | make_smbpasswd &gt; /usr/local/private/smbpasswd</userinput>
&prompt.root; <userinput>chmod 600 /usr/local/private/smbpasswd</userinput></screen>

	<para>Обратитесь к документации на <application>Samba</application>
	  за дополнительной информацией о параметрах настройки.
	  Основные настройки, рассмотренные здесь, достаточны для
	  первого запуска <application>Samba</application>.</para>
      </sect3>

    </sect2>
    <sect2>
      <title>Запуск <application>Samba</application></title>

      <para>Для запуска <application>Samba</application> при
	загрузке системы, добавьте в <filename>/etc/rc.conf</filename>
	следующую строку:</para>

      <programlisting>samba_enable="YES"</programlisting>

      <para>Затем вы можете запустить <application>Samba</application> в
	любой момент, набрав:</para>

      <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/samba.sh start</userinput>
Starting SAMBA: removing stale tdbs :
Starting nmbd.
Starting smbd.</screen>

      <para><application>Samba</application> состоит из трех
	отдельных даемонов.  Вы можете видеть, что
	<application>nmbd</application> и <application>smbd</application>
	запускаются скриптом <filename>samba.sh</filename>.
	Если вы включили сервис разрешения имен winbind
	в <filename>smb.conf</filename>, то увидите также
	запуск даемона <application>winbindd</application>.</para>

      <para>Вы можете остановить <application>Samba</application> в любой
	момент, набрав:</para>

      <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/samba.sh stop</userinput></screen>

      <para><application>Samba</application> это сложный программный
	набор с функциональностью, позволяющей полную интеграцию в сети
	&microsoft.windows;.  За дальнейшей информацией о функциях,
	выходящих за рамки описанной здесь базовой установки,
	обращайтесь к <ulink url="http://www.samba.org"></ulink>.</para>
    </sect2>

  </sect1>

  <sect1 id="network-ftp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Протокол передачи файлов (FTP)</title>

    <indexterm><primary>FTP сервер</primary></indexterm>

    <sect2>
      <title>Обзор</title>

      <para>Протокол передачи файлов (File Transfer Protocol, FTP) дает
	пользователям простой путь передачи файлов на и с <acronym
	role="File Transfer Protocol">FTP</acronym> сервера. В &os;
	серверная программа <acronym
	role="File Transfer Protocol">FTP</acronym>,
	<application>ftpd</application>, включена в базовую систему.
	Это упрощает настройку и администрирование <acronym
	role="File Transfer Protocol">FTP</acronym> сервера в
	FreeBSD.</para>
    </sect2>

    <sect2>
      <title>Настройка</title>

      <para>Наиболее важный шаг заключается в определении того,
	каким учетным записям будет позволено получать доступ
	к FTP серверу.  В обычной системе FreeBSD есть множество
	системных учетных записей, используемых различными даемонами,
	но пользователям должно быть запрещен вход с использованием
	этих учетных записей.  В файле <filename>/etc/ftpusers</filename>
	находится список пользователей, которым запрещен доступ по
	FTP.  По умолчанию он включает упомянутые системные учетные
	записи, но в него можно добавить и определенных пользователей,
	которым будет запрещен доступ по FTP.</para>

      <para>Вам может понадобиться ограничить доступ определенных
	пользователей без полного запрета использования FTP.
	Это можно сделать через файл <filename>/etc/ftpchroot</filename>.
	В нем находится список пользователей и групп, к которым
	применяется ограничение доступа.  На странице справочника
	&man.ftpchroot.5; дана подробная информация, и она не будет
	дублироваться здесь.</para>

      <para>Если вы захотите разрешить анонимный FTP доступ на
	сервер, в системе &os; необходимо создать пользователя
	<username>ftp</username>.  Этот пользователь сможет
	входить на FTP сервер с именем пользователя
	<username>ftp</username> или <username>anonymous</username>,
	с любым паролем (существует соглашение об использовании
	почтового адреса пользователя в качестве пароля).
	FTP сервер выполнит &man.chroot.2; при входе пользователя
	anonymous для ограничения доступа только домашним каталогом
	пользователя <username>ftp</username>.</para>

      <para>Существуют два текстовых файла, определяющих сообщение,
	отправляемое FTP клиентам.  Содержимое файла
	<filename>/etc/ftpwelcome</filename> будет выведено пользователям
	перед приглашением на вход.  После успешного входа
	будет выведено содержимое файла <filename>/etc/ftpmotd</filename>.
	Обратите внимание, что путь к этому файлу задается относительно
	домашнего каталога пользователя, так что анонимным пользователям
	будет отправляться <filename>~ftp/etc/ftpmotd</filename>.</para>

      <para>Как только FTP сервер был правильно настроен, он должен
	быть включен в <filename>/etc/inetd.conf</filename>.  Все, что
	необходимо, это удалить символ комментария
	<quote>#</quote> из начала существующей строки
	<application>ftpd</application>:</para>

      <programlisting>ftp	stream	tcp	nowait	root	/usr/libexec/ftpd	ftpd -l</programlisting>

      <para>Как описано в <xref linkend="network-inetd-hangup">,
	сигнал HangUP должен быть отправлен <application>inetd</application>
	после того, как этот файл настройки был изменен.</para>

      <para>Теперь вы можете войти на FTP сервер, введя:</para>

      <screen>&prompt.user; <userinput>ftp localhost</userinput></screen>

    </sect2>

    <sect2>
      <title>Поддержка</title>

      <indexterm><primary>syslog</primary></indexterm>
      <indexterm><primary>лог файлы</primary>
	<secondary>FTP</secondary></indexterm>

      <para>Для протоколирования даемон <application>ftpd</application>
	использует сообщения &man.syslog.3;.  По умолчанию, &man.syslog.3;
	поместит сообщения, относящиеся к FTP, в файл
	<filename>/var/log/xferlog</filename>.  Местоположение
	лог файла FTP может быть изменено путем изменения следующей
	строки в файле <filename>/etc/syslog.conf</filename>:</para>

      <programlisting>ftp.info      /var/log/xferlog</programlisting>

      <para>Учитывайте потенциальные проблемы, возникающие с
	анонимным FTP сервером.  В частности, вы должны дважды
	подумать, прежде чем позволить анонимным пользователям
	загружать файлы на сервер.  Вы можете обнаружить, что
	FTP сайт стал форумом, на котором происходит обмен
	нелицензионным коммерческим программным обеспечением
	или чем-то еще хуже.  Если вам необходимо разрешить
	анонимную выгрузку файлов на FTP, права должны быть настроены
	таким образом, чтобы эти файлы не могли прочитать другие
	анонимные пользователи до их рассмотрения администратором.</para>
    </sect2>
  </sect1>

  <sect1 id="network-ntp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Hukins</surname>
	  <contrib>Текст предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Синхронизация часов через NTP</title>

    <indexterm><primary>NTP</primary></indexterm>

    <sect2>
      <title>Обзор</title>

      <para>С течением времени часы компьютера имеют тенденцию отставать.
	Network Time
	Protocol - Сетевой Протокол Времени (<acronym role="Network
	Time Protocol">NTP</acronym>) является одним из способов
	вести точное время.</para>

      <para>Многие сервисы Интернет опираются или сильно зависят от точности
	часов компьютеров.  К примеру, веб-сервер может получать запрос на
	посылку файла, который был недавно модифицирован.  В локальной сети
	необходимо, чтобы часы компьютеров, совместно использующих файлы,
	были синхронизированы, чтобы время модификации файлов устанавливалось
	правильно. Такие службы, как
	&man.cron.8;, также зависят от правильности установки системных
	часов, поскольку запускают команды в определенное время.</para>

      <indexterm>
	<primary>NTP</primary>
	<secondary>ntpd</secondary>
      </indexterm>
      <para>FreeBSD поставляется с сервером <acronym role="Network Time
	Protocol">NTP</acronym> &man.ntpd.8;, который можно
	использовать для опроса других серверов NTP для установки часов на
	вашей машине или предоставления услуг точного времени.</para>
    </sect2>

    <sect2>
      <title>Выбор подходящих серверов NTP</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>выбор серверов</secondary>
      </indexterm>

      <para>Для синхронизации ваших часов вам нужно найти для использования
	один или большее количество серверов NTP.  Ваш сетевой администратор
	или провайдер могут иметь сервер NTP для этой цели&mdash;обратитесь к
	ним, так ли это в вашем случае.  Существует <ulink
	url="http://ntp.isc.org/bin/view/Servers/WebHome">онлайн список
	общедоступных серверов NTP</ulink>, которым можно воспользоваться для
	поиска ближайшего к вам сервера NTP.  Не забудьте выяснить политику
	выбранного вами сервера и спросить разрешения, если это
	требуется.</para>

      <para>Выбор нескольких несвязанных серверов NTP является хорошей идеей в
	том случае, если один из используемых вами серверов станет недоступным
	или его часы неточны.  &man.ntpd.8; использует ответы, которые он
	получает от других серверов с умом&mdash;он делает предпочтение
	надежным серверам.</para>
    </sect2>

    <sect2>
      <title>Настройка вашей машины</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>настройка</secondary>
      </indexterm>

      <sect3>
	<title>Базовая конфигурация</title>

	<indexterm><primary>ntpdate</primary></indexterm>

	<para>Если вам нужно только синхронизировать ваши часы при загрузке
	  машины, вы можете воспользоваться утилитой &man.ntpdate.8;.  Это
	  может подойти для некоторых настольных машин, которые часто
	  перезагружаются и только требуют изредка синхронизироваться, но
	  на большинстве машин должен работать &man.ntpd.8;.</para>

	<para>Использование &man.ntpdate.8; при загрузке также хорошо для
	  машин, на которых запущен даемон &man.ntpd.8;.  Программа
	  &man.ntpd.8; изменяет время постепенно, тогда как &man.ntpdate.8;
	  устанавливает время вне
	  зависимости от того, насколько велика разница между текущим временем
	  машины и точным временем.</para>

	<para>Для включения &man.ntpdate.8; во время загрузки, добавьте строчку
	  <literal>ntpdate_enable="YES"</literal> в файл
	  <filename>/etc/rc.conf</filename>.  Вам также потребуется указать
	  все серверы, с которыми вы хотите синхронизироваться, и все
	  параметры, которые передаются в &man.ntpdate.8;, в
	  <varname>ntpdate_flags</varname>.</para>
      </sect3>

      <sect3>
	<indexterm>
	  <primary>NTP</primary>

	  <secondary>ntp.conf</secondary>
	</indexterm>

	<title>Общие настройки</title>

	<para>NTP настраивается в файле <filename>/etc/ntp.conf</filename>,
	  формат которого описан в &man.ntp.conf.5;.  Вот простой
	  пример:</para>

	<programlisting>server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift</programlisting>

	<para>Параметр <literal>server</literal> задает, какие серверы будут
	  использоваться, по одному в каждой строке.  Если сервер задан с
	  аргументом <literal>prefer</literal>, как <hostid
	  role="fqdn">ntplocal.example.com</hostid>, то этому серверу отдается
	  предпочтение перед остальными.  Ответ от предпочтительного сервера
	  будет отброшен, если он значительно отличается от ответов других
	  серверов, в противном случае он будет использоваться безотносительно
	  к другим ответам.  Аргумент <literal>prefer</literal> обычно
	  используется для серверов NTP, о которых известно, что они очень
	  точны, такими, на которых используется специальное оборудование
	  точного времени.</para>

	<para>Параметр <literal>driftfile</literal> задает файл, который
	  используется для хранения смещения частоты системных часов.
	  Программа &man.ntpd.8; использует его для автоматической компенсации
	  естественного смещения часов, позволяя ему поддерживать достаточно
	  правильную настройку, даже если он на некоторый период отключается от
	  внешнего источника информации о времени.</para>

	<para>Параметр <literal>driftfile</literal> задает, какой файл
	  используется для сохранения информации о предыдущих ответах от
	  серверов NTP, которые вы используете.  Этот файл содержит внутреннюю
	  информацию для NTP.  Он не должен изменяться никакими другими
	  процессами.</para>
      </sect3>

      <sect3>
	<title>Управление доступом к вашему серверу</title>

	<para>По умолчанию ваш сервер NTP будет доступен всем хостам в
	  Интернет.  Параметр <literal>restrict</literal> в файле
	  <filename>/etc/ntp.conf</filename> позволяет вам контролировать,
	  какие машины могут обращаться к вашему серверу.</para>

	<para>Если вы хотите запретить всем машинам обращаться к вашему серверу
	  NTP, добавьте следующую строку в
	  файл <filename>/etc/ntp.conf</filename>:</para>

	<programlisting>restrict default ignore</programlisting>

	<para>Если вы хотите разрешить синхронизировать свои часы с вашим
	  сервером только машинам в вашей сети, но запретить им настраивать
	  сервер или быть равноправными участниками синхронизации времени, то
	  вместо указанной добавьте строчку</para>

	<programlisting>restrict 192.168.1.0 mask 255.255.255.0 notrust nomodify notrap</programlisting>

	<para>где <hostid role="ipaddr">192.168.1.0</hostid> является адресом
	  IP вашей сети, а <hostid role="netmask">255.255.255.0</hostid> её
	  сетевой маской.</para>

	<para><filename>/etc/ntp.conf</filename> может содержать несколько
	  директив <literal>restrict</literal>.  Для получения подробной
	  информации обратитесь к подразделу <literal>Access Control
	  Support</literal> (Поддержка Управления Доступом) в
	  &man.ntp.conf.5;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Запуск сервера NTP</title>

      <para>Для того, чтобы сервер NTP запускался при загрузке, добавьте строку
	<literal>xntpd_enable="YES"</literal> в файл
	<filename>/etc/rc.conf</filename>.  Если вы хотите передать
	дополнительные опции в &man.ntpd.8;, то отредактируйте параметр
	<varname>xntpd_flags</varname> в файле
	<filename>/etc/rc.conf</filename>.</para>

      <para>Для запуска сервера без перезагрузки вашей машины, выполните
	команду <command>ntpd</command>, не забыв задать дополнительные
	параметры из переменной <varname>xntpd_flags</varname> в файле
	<filename>/etc/rc.conf</filename>.  К примеру:</para>

      <screen>&prompt.root; <userinput>ntpd -p /var/run/ntpd.pid</userinput></screen>

      <note>
	<para>Во &os;&nbsp;5.X различные параметры из
	  <filename>/etc/rc.conf</filename> были переименованы.  В частности,
	  в списке параметров вам необходимо заменить каждую строчку
	  <literal>xntpd</literal> на <literal>ntpd</literal>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Использование ntpd с временным подключением к
	Интернет</title>

      <para>Для нормальной работы программе &man.ntpd.8; не требуется
	постоянное подключение к Интернет.  Однако если ваше временное
	подключение к Интернет настроено для дозвона по требованию, хорошо бы
	запретить трафику NTP вызывать дозвон или поддерживать соединение
	постоянно.  Если вы используете пользовательский PPP, то можете
	воспользоваться директивами <literal>filter</literal> в файле
	<filename>/etc/ppp/ppp.conf</filename>.  К примеру:</para>

      <programlisting> set filter dial 0 deny udp src eq 123
 # Prevent NTP traffic from initiating dial out
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Prevent incoming NTP traffic from keeping the connection open
 set filter alive 1 deny udp dst eq 123
 # Prevent outgoing NTP traffic from keeping the connection open
 set filter alive 2 permit 0/0 0/0</programlisting>

      <para>Более подробную информацию можно найти в разделе <literal>PACKET
	FILTERING</literal> (ФИЛЬТРАЦИЯ ПАКЕТОВ) в &man.ppp.8;, а примеры в
	<filename>/usr/share/examples/ppp/</filename>.</para>

      <note>
	<para>Некоторые провайдеры Интернет блокируют трафик по портам с
	  маленькими номерами, что приводит к неработоспособности NTP, так как
	  ответы никогда не достигают вашей машины.</para>
      </note>
    </sect2>

    <sect2>
      <title>Дополнительная литература</title>

      <para>Документация по серверу NTP может быть найдена в каталоге
	<filename>/usr/share/doc/ntp/</filename> в формате HTML.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
<!--  LocalWords:  config mnt www -->
