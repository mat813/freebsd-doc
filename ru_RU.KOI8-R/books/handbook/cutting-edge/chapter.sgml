<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/cutting-edge/chapter.sgml,v 1.38 2004/04/13 06:55:15 den Exp $

     Original revision: 1.198
-->

<chapter id="cutting-edge">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Jim</firstname>

        <surname>Mock</surname>

        <contrib>Реструктурирование, реорганизацию и частичное обновление
          выполнил </contrib>
      </author>
      <!-- Март 2000 -->
    </authorgroup>

    <authorgroup>
      <author>
        <firstname>Jordan</firstname>
        <surname>Hubbard</surname>
        <contrib>Оригинальный текст написал </contrib>
      </author>

      <author>
        <firstname>Poul-Henning</firstname>
        <surname>Kamp</surname>
      </author>

      <author>
        <firstname>John</firstname>
        <surname>Polstra</surname>
      </author>

      <author>
        <firstname>Nik</firstname>
        <surname>Clayton</surname>
      </author>
    </authorgroup>
    <!-- с замечаниями от многих других -->
  </chapterinfo>

  <title>На переднем крае разработок</title>

  <sect1 id="cutting-edge-synopsis">
    <title>Краткий обзор</title>

    <para>Между релизами над &os; ведется постоянная работа.  Для тех,
      кто хочет быть на переднем крае, есть несколько простых методов для
      поддержания своей системы в соответствии с последними разработками.
      Будьте осторожны &mdash; передний край не для всех!  Эта глава поможет
      вам решить, хотите ли вы отслеживать систему в процессе работы над ней
      или останетесь верным одному из выпущенных релизов.</para>

    <para>После чтения этой главы вы будете знать:</para>

    <itemizedlist>
      <listitem>
        <para>Разницу между двумя ветвями разработки: &os.stable; и
          &os.current;.</para>
      </listitem>

      <listitem>
        <para>Как поддерживать вашу систему в актуальном состоянии при помощи
	  <application>CVSup</application>, <application>CVS</application> или
	  <application>CTM</application>.</para>
      </listitem>

      <listitem>
        <para>Как перестраивать и переустанавливать базовую систему полностью
          при помощи <command>make world</command>.</para>
      </listitem>
    </itemizedlist>

    <para>Перед чтением этой главы вы должны:</para>

    <itemizedlist>
      <listitem>
        <para>Полностью настроить своё подключение к сети (<xref
          linkend="advanced-networking">).</para>
      </listitem>

      <listitem>
        <para>Знать, как устанавливать дополнительное программное обеспечение
          других разработчиков (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="current-stable">
    <title>&os.current; против &os.stable;</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Во FreeBSD имеется две ветки разработки: &os.current; и &os.stable;.
      Этот раздел описывает каждую из них и объясняет, как синхронизировать
      вашу систему с любой из веток.  Сначала будет обсуждаться ветка
      &os.current;, затем &os.stable;.</para>

    <sect2 id="current">
      <title>Как следовать текущим разработкам во &os;</title>

      <para>Пока вы читаете этот текст, помните, что &os.current; является
        <quote>передовым краем</quote> работ над &os;.  Предполагается, что
        пользователи &os.current; технически более грамотны и могут решать
        проблемы с системой самостоятельно.  Если вы являетесь во &os;
        новичком, вам лучше сначала дважды подумать, прежде чем
        её устанавливать.</para>

      <sect3>
        <title>Что такое &os.current;?</title>
        <indexterm><primary>snapshot</primary></indexterm>

        <para>&os.current; является последними рабочими версиями исходных
          текстов &os;.  Сюда включаются неоконченные работы, экспериментальные
          изменения и промежуточные механизмы, которые могут присутствовать, а
          могут и отсутствовать в следующем официальном релизе программного
          обеспечения.  Хотя многие из разработчиков &os; выполняют компиляцию
          из исходных текстов &os.current; ежедневно, случаются периоды, когда
          исходные тексты заведомо не могут быть откомпилированы.  Такие
          проблемы обычно решаются так быстро, как это возможно, но всё-таки
          момент, когда вы сгрузили исходные тексты &os.current;, может
          повлиять на то, содержат они мину замедленного действия или очень
          нужную функциональность!</para>
      </sect3>

      <sect3>
        <title>Кому нужна &os.current;?</title>

        <para>&os.current; предназначается трём основным заинтересованным
          группам:</para>

        <orderedlist>
          <listitem>
            <para>Члены команды разработчиков &os;, активно работающие над
              некоторой частью дерева исходных текстов и для кого работа в
              <quote>current</quote> является абсолютной
              необходимостью.</para>
          </listitem>

          <listitem>
            <para>Члены команды разработчиков &os;, которые являются
              активными тестерами.  Они тратят свое время на
              исправление проблем для того, чтобы &os.current; оставалась,
              насколько это возможно, нормально работающей системой.  Есть
              также люди, которые вносят важные предложения по изменениям и
              общему направлению развития &os; и присылают свои патчи,
              реализующие эти изменения.</para>
          </listitem>

          <listitem>
            <para>Те, кто просто хотят быть в курсе всех изменений или
              используют текущие исходные тексты для ознакомительных целей (к
              примеру, для <emphasis>чтения</emphasis>, но не для
              использования).  Такие люди также иногда высказывают замечания
              или предоставляют код.</para>
          </listitem>
        </orderedlist>
      </sect3>

      <sect3>
        <title>Чем &os.current; <emphasis>не</emphasis> является?</title>

        <orderedlist>
          <listitem>
            <para>Быстрым способом получить предварительную версию, в
              случае, если вы услышали, что здесь появилась некая крутая
              возможность, и вы хотите быть первым в вашем микрорайоне, у
              кого она есть.  Здесь быть первым из тех, кто имеет это
              программное обеспечение означает также быть первым из тех, кто
              столкнулся с ошибками в нём.</para>
          </listitem>

          <listitem>
            <para>Быстрым способом получения исправлений.  Любая версия
              &os.current; является в равной мере как источником исправлений
              существующих ошибок, так и источником появления новых.</para>
          </listitem>

          <listitem>
            <para><quote>Официально поддерживаемой</quote> каким бы то ни было
              способом.  Мы прилагаем все усилия, чтобы помочь тем, кто
              изначально принадлежит одной из трех <quote>признанных</quote>
              групп пользователей &os.current;, но у нас просто <emphasis>нет
              времени</emphasis> на техническую поддержку.  Это не потому, что
              мы гадкие и злые люди, которые ни за что не будут помогать другим
              (если бы это было так, мы бы не создали &os;).  Мы просто не в
              силах отвечать на сотни сообщений в день <emphasis>и</emphasis>
              работать над FreeBSD!  Если бы стоял выбор между тем, отвечать ли
              на множество вопросов об экспериментально коде или продолжать
              работу над совершенствованием &os;, большинство разработчиков
              проголосовало бы за последнее.</para>
          </listitem>
        </orderedlist>
      </sect3>

      <sect3>
        <title>Использование &os.current;</title>

        <indexterm>
          <primary>-CURRENT</primary>

          <secondary>использование</secondary>
        </indexterm>

        <orderedlist>
          <listitem>
            <para>Подпишитесь на списки рассылки &a.current.name; и
              &a.cvsall.name;.  Это не просто хорошая идея, это
              <emphasis>необходимость</emphasis>.  Если вы не являетесь
              участником списка рассылки <emphasis>&a.current.name;</emphasis>,
              то вы не увидите замечаний,
              высказываемых о текущем состоянии системы и в итоге можете
              столкнуться со множеством проблем, которые уже были найдены и
              решены другими.  Ещё хуже, если вы пропустите важные сообщения,
              касающиеся жизнеспособности вашей системы.</para>

            <para>Список рассылки &a.cvsall.name; позволит вам для каждого
              изменения увидеть соответствующую запись в журнале коммитов,
              а они порой содержат относящуюся к делу
              информацию о возможных побочных эффектах.</para>

            <para>Чтобы подключиться к этим и другим доступным спискам
              рассылки, перейдите по ссылке &a.mailman.lists.link; и щёлкните
              на списке, к которому вы хотите подключиться.  Инструкции по
              дальнейшим действиям размещены там же.</para>
          </listitem>

          <listitem>
            <para>Сгрузите исходные тексты с <link
              linkend="mirrors">зеркального сайта</link> &os;.  Вы можете
              сделать это одним из следующих двух способов:</para>

            <orderedlist>
              <indexterm>
                <primary><command>cvsup</command></primary>
              </indexterm>

              <indexterm>
                <primary><command>cron</command></primary>
              </indexterm>

              <indexterm>
                <primary>-CURRENT</primary>
                <secondary>
                  Синхронизация при помощи <application>CVSup</application>
                </secondary>
              </indexterm>

              <listitem>
                <para>При помощи программы <link linkend="cvsup">cvsup</link>
                  с <filename>sup</filename>-файлом
                  <filename>standard-supfile</filename>, который можно найти в
                  каталоге <filename>/usr/share/examples/cvsup</filename>.  Это
                  наиболее
                  рекомендуемый метод, так как он позволяет вам сгрузить набор
                  исходных текстов один раз полностью, а затем сгружать только
                  произошедшие изменения.  Многие запускают
                  <command>cvsup</command> при помощи программы
                  <command>cron</command> и получают самые свежие исходные
                  тексты автоматически.  Измените примерный файл
                  <filename>supfile</filename> выше и отконфигурируйте <link
                  linkend="cvsup">cvsup</link> для вашего окружения.</para>
              </listitem>

              <indexterm>
                <primary>-CURRENT</primary>
                <secondary>Синхронизация при помощи CTM</secondary>
              </indexterm>

              <listitem>
                <para>При помощи <application><link
                  linkend="ctm">CTM</link></application>.  Если у вас очень
                  плохое подключение (дорогое или предоставляющее доступ только
                  к электронной почте), то <application>CTM</application>
                  можно рассматривать как вариант.  Однако в нем много
                  &quot;подводных камней&quot;, и его использование может
                  привести к появлению неправильных файлов.  Это привело к
                  тому, что этот способ используется редко, что, в свою
                  очередь, увеличивает шанс появления периодов его
                  неработы.  Мы рекомендуем использовать <application><link
                  linkend="cvsup">CVSup</link></application> всем, чья скорость
                  подключения равна 9600&nbsp;bps и выше.</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Если вам нужны исходные тексты для компиляции и запуска, а
              не просто для ознакомления, то сгружайте исходные тексты
              ветки &os.current; <emphasis>полностью</emphasis>, а не отдельные
              ее части.  Причиной является то, что многие части исходных
              текстов зависят от других обновлений где-то еще, и попытка
              компиляции лишь некоторой части программ в этом случае
              гарантированно вызовет проблемы.</para>

            <indexterm>
              <primary>-CURRENT</primary>

              <secondary>компиляция</secondary>
            </indexterm>

            <para>Перед тем, как компилировать &os.current;, внимательно
              прочтите файл <filename>Makefile</filename> в каталоге
              <filename>/usr/src</filename>.  В процессе обновления вы
              по крайней мере раз должны пройти через <link
              linkend="makeworld">установку нового ядра и перестроение всех
              компонентов системы</link>.  Чтение &a.current; и
              <filename>/usr/src/UPDATING</filename> позволит вам быть в курсе
              всех процедур, которые иногда бывают необходимы в процессе
              работы над следующим релизом.</para>
          </listitem>

          <listitem>
            <para>Будьте активным подписчиком!  Если вы работаете с
              &os.current;, мы хотим знать, что вы думаете о ней, особенно
              если у вас есть соображения по ее улучшению или исправлению
              ошибок.  Пожелания, к которым прилагается код, всегда
              принимаются с большим энтузиазмом!</para>
          </listitem>
        </orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>Работа с веткой stable во &os;</title>

      <sect3>
        <title>Что такое &os.stable;?</title>
        <indexterm><primary>-STABLE</primary></indexterm>

        <para>&os.stable; является нашей веткой разработки, из которой делаются
          основные релизы.  Изменения в этой ветке происходят с разной
          скоростью, и при этом предполагается, что сначала они были выполнены
          для &os.current; в целях тестирования.  Однако эта ветка
          <emphasis>остаётся</emphasis> веткой для разработки, а это значит,
          что в любой момент времени исходные тексты &os.stable; могут
          оказаться неприменимы для некоторой задачи.  Это просто ещё одна
          ветка при разработке, а не ресурс для конечных пользователей.</para>
      </sect3>

      <sect3>
        <title>Кому нужна &os.stable;?</title>

        <para>Если вы заинтересованы в отслеживании процесса разработки FreeBSD
          или хотите принять в нём участие, особенно в той мере, насколько это
          касается выпуска следующего релиза FreeBSD с <quote>точкой</quote>, то
          вам необходимо отслеживать &os.stable;.</para>

        <para>Хотя правда то, что исправления, касающиеся безопасности, также
          делаются и в ветке &os.stable;, вам <emphasis>не нужно</emphasis>
          для этого отслеживать &os.stable;.  Каждый бюллетень по безопасности
          FreeBSD описывает, как решить проблему для тех релизов, которых он
          касается
	  <footnote>
            <para>Это не совсем так.  Мы не можем поддерживать старые релизы
              FreeBSD бесконечно долго, хотя мы поддерживаем их многие годы.
              Полное описание текущей политики безопасности относительно
              старых релизов FreeBSD можно найти по адресу <ulink
    	      url="../../../../security/index.html">
              http://www.FreeBSD.org/security/</ulink>.</para>
	  </footnote>
          , а отслеживание ветки разработки в полном объёме только ради
          исправлений пробелов в безопасности приводит к появлению большого
          количества дополнительных ненужных изменений.</para>

        <para>Хотя мы прилагаем все усилия, чтобы ветка &os.stable; всегда
          компилировалась и работала, этого нельзя гарантировать.  Кроме того,
          несмотря на то, что перед включением в &os.stable;, код
          разрабатывается в &os.current;, гораздо большее количество людей
          работают с &os.stable;, чем с &os.current;.  Поэтому неудивительно,
          что в &os.stable; иногда
          обнаруживаются ошибки и всплывают непредвиденные ситуации, которые не
          проявляли себя в &os.current;.</para>

        <para>По этим причинам мы <emphasis>не</emphasis> рекомендуем слепо
          отслеживать &os.stable;, и, что особенно важно, вы не должны
          обновлять какие-либо сервера, находящиеся в активной эксплуатации, до
          &os.stable; без предварительного тщательного тестирования кода в
          вашей среде разработки.</para>

        <para>Если у вас нет возможности сделать это, то мы рекомендуем
          работать с самой последним релизом &os; и использовать механизм
          обновления бинарных файлов для перехода от релиза к релизу.</para>
      </sect3>

      <sect3>
        <title>Использование &os.stable;</title>

        <indexterm>
          <primary>-STABLE</primary>
          <secondary>использование</secondary>
        </indexterm>
        <orderedlist>
          <listitem>
            <para>Подпишитесь на список рассылки &a.stable.name;.  Это позволит
              вам узнавать о зависимостях процесса компиляции,
              которые могут появиться в ветке &os.stable; или
              любых других проблемах, требующих особого внимания.  В этом
              списке рассылки разработчики также делают объявления о
              спорных исправлениях или добавлениях,
              давая пользователям возможность высказать свое мнение о
              возможных тонких моментах.</para>

            <para>Список рассылки &a.cvsall.name; позволит вам для каждого
              изменения увидеть соответствующую запись в журнале коммитов,
              а они порой содержат относящуюся к делу
              информацию о возможных побочных эффектах.</para>

            <para>Чтобы подключиться к этим и другим доступным спискам
              рассылки, перейдите по ссылке &a.mailman.lists.link; и щёлкните
              на списке, к которому вы хотите подключиться.  Инструкции по
              дальнейшим действиям размещены там же.</para>
          </listitem>

          <listitem>
            <para>Если вы устанавливаете новую систему и хотите, чтобы она
              работала максимально стабильно, то можете просто сгрузить
              самый свежий снэпшот ветки по адресу <ulink
              url="ftp://snapshots.jp.FreeBSD.org/pub/FreeBSD/snapshots/">
              </ulink> и установить его, как любой другой релиз.  Либо вы
              можете установить самый последний релиз &os.stable;, сгрузив его
              с <link linkend="mirrors">зеркалирующих сайтов</link>, а затем
              следовать инструкциям ниже по обновлению исходных текстов вашей
              системы до самой последней версии &os.stable;.</para>

            <para>Если вы уже работаете с предыдущим релизом &os; и хотите
              обновить его из исходных текстов, то вы можете легко это
              сделать с <link linkend="mirrors">зеркального сайта</link> &os;.
              Это можно сделать одним из двух способов:</para>

            <orderedlist>
              <indexterm>
                <primary><command>cvsup</command></primary>
              </indexterm>

              <indexterm>
                <primary><command>cron</command></primary>
              </indexterm>

              <indexterm>
                <primary>-STABLE</primary>

                <secondary>
                  Синхронизация при помощи <application>CVSup</application>
                </secondary>
              </indexterm>

              <listitem>
                <para>При помощи программы <link linkend="cvsup">cvsup</link>
                  с <filename>sup</filename>-файлом
                  <filename>stable-supfile</filename> из каталога
                  <filename>/usr/share/examples/cvsup</filename>.
                  Это наиболее рекомендуемый
                  метод, так как он позволяет вам сгрузить набор исходных
                  текстов один раз полностью, а затем сгружать только
                  произошедшие изменения.  Многие запускают
                  <command>cvsup</command> при помощи программы
                  <command>cron</command> и получают самые свежие исходные
                  тексты автоматически.  Измените примерный файл
                  <filename>supfile</filename> выше и отконфигурируйте <link
                  linkend="cvsup">cvsup</link> для вашего окружения.</para>
              </listitem>

              <indexterm>
                <primary>-STABLE</primary>
                <secondary>синхронизация при помощи CTM</secondary>
              </indexterm>

              <listitem>
                <para>При помощи <application><link
                  linkend="ctm">CTM</link></application>.  Если у вас нет
                  быстрого и недорогого подключения к Интернет, то это как раз
                  тот метод, которым вы должны воспользоваться.</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Итак, если вам нужен быстрый доступ к
              исходным текстам и нагрузка на каналы связи для вас не
              проблема, то используйте <command>cvsup</command>
              или <command>ftp</command>.  В противном случае воспользуйтесь
              <application>CTM</application>.</para>
          </listitem>

          <indexterm>
            <primary>-STABLE</primary>
            <secondary>компиляция</secondary>
          </indexterm>

          <listitem>
            <para>Перед тем, как компилировать &os.stable;, внимательно
              прочтите файл <filename>Makefile</filename> в каталоге
              <filename>/usr/src</filename>.  В процессе обновления вы
              по крайней мере раз должны пройти через <link
              linkend="makeworld">установку нового ядра и перестроение всех
              компонентов системы</link>.  Чтение &a.stable; и
              <filename>/usr/src/UPDATING</filename>
              позволит вам быть в курсе всех процедур,
              которые иногда бывают необходимы при переходе к следующему
              релизу.</para>
          </listitem>
        </orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Синхронизация ваших исходных текстов</title>

    <para>Имеются различные способы использования Интернет (или почтового)
      подключения для того, чтобы иметь самые последние версии исходных
      текстов любого проекта &os;, в зависимости от
      того, чем вы интересуетесь.  Основной сервис, который мы предлагаем,
      это <link linkend="anoncvs">Анонимный CVS</link>, <link
      linkend="cvsup">CVSup</link> и <link linkend="ctm">CTM</link>.</para>

    <warning>
      <para>Хотя имеется возможностью обновлять только часть дерева исходных
        текстов, процедурой, которую мы настоятельно советуем, является обновление всего
        дерева и перекомпиляция пользовательских программ (то есть тех,
        которые работают в пространстве имен пользователя, например те, что
        находятся в каталогах <filename>/bin</filename> и
        <filename>/sbin</filename>) и ядра.  Обновление только части дерева
        исходных текстов, только текстов ядра или только текстов
        пользовательских программ часто приводит к возникновению проблем.  Эти
        проблемы могут варьироваться от ошибок компиляции до аварийных
        остановов системы или порчи данных.</para>
    </warning>

    <indexterm><primary>анонимный CVS</primary></indexterm>
    <para><application>Анонимный CVS</application> и
      <application>CVSup</application> используют модель
      <emphasis>pull</emphasis> обновления исходных текстов.  В случае
      <application>CVSup</application> пользователь (или скрипт программы
      <application>cron</application>) вызывают <command>cvsup</command>, а она
      работает с каким-либо сервером <application>cvsupd</application>, чтобы
      выполнить обновление ваших
      файлов.  Обновления, которые вы получаете, актуальны с точностью до
      минуты, и вы получаете их тогда и только тогда, когда сами захотите.
      Вы можете с легкостью ограничить обновления конкретными файлами
      или каталогами, которые представляют для вас интерес.  Обновления
      создаются на лету сервером согласно тому, что у вас есть и что вы
      хотите иметь.  <application>Анонимный CVS</application> гораздо проще,
      чем <application>CVSup</application> в том смысле, что он представляет
      собой всего лишь расширение
      <application>CVS</application>, позволяющее сгрузить изменения
      непосредственно с удаленного хранилища CVS.
      <application>CVSup</application> может делать это гораздо более
      эффективно, однако <application>анонимным CVS</application> легче
      пользоваться.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para><application>CTM</application>, с другой стороны, не сравнивает
      последовательно исходные тексты, имеющиеся у вас, с теми, что
      находятся в главном архиве и вообще ни коим образом не касается наших
      серверов.  Вместо этого несколько раз в день на главной машине CTM
      запускается скрипт, находящий изменения в файлах с момента
      своего предыдущего запуска; все замеченные изменения сжимаются,
      помечаются последовательным номером и кодируются для передачи по
      электронной почте (в форме печатаемых символов ASCII).
      После получения эти <quote>дельта-файлы CTM</quote> могут быть
      переданы утилите &man.ctm.rmail.1;, которая осуществит автоматическое
      декодирование, проверку и применение изменений к пользовательской
      копии исходных текстов.  Этот процесс гораздо более эффективен, чем
      <application>CVSup</application>, и требует меньше ресурсов нашего
      сервера, так как он сделан по модели <emphasis>push</emphasis>, а не
      <emphasis>pull</emphasis>.</para>

    <para>Несомненно, есть и минусы.  Если вы случайно уничтожили
      часть вашего архива, то <application>CVSup</application> обнаружит
      и сгрузит поврежденную часть.  <application>CTM</application> этого
      делать не будет, и если вы уничтожили какую-то часть вашего дерева
      исходных текстов (и у вас нет архивной копии), то вам нужно будет
      начать с самого начала (с последнего <quote>базового
      дельта-файла</quote>), перестроив всё с помощью
      <application>CTM</application>, или, используя <application>анонимный
      CVS</application>, просто удалить повреждённую часть и
      пересинхронизироваться.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>Использование <command>make world</command></title>

    <indexterm>
      <primary><command>make world</command></primary>
    </indexterm>
    <para>После того, как вы синхронизировали ваше локальное дерево
      исходных текстов с некоторой версией &os;
      (&os.stable;, &os.current; и так далее),
      то можете использовать эти исходные тексты для перестроения
      системы.</para>

    <warning>
      <title>Создайте резервную копию</title>

      <para>Невозможно переоценить важность создания резервной
        копии вашей системы <emphasis>до того</emphasis>, как вы будете
        это делать.  Хотя перестроение системы (пока вы следуете этим
        инструкциям) является простой задачей, вы всегда можете допустить
        ошибку, или ошибка может оказаться в исходных текстах, что может
        привести к тому, что система перестанет загружаться.</para>

      <para>Обязательно сделайте резервную копию.  И держите под рукой
        аварийную (fixit) дискету.  Может быть, вам никогда не приходилось ими
        пользоваться, но, постучав по дереву, всегда лучше подготовиться, чем
        потом сожалеть.</para>
    </warning>

    <warning>
      <title>Подпишитесь на соответствующий список рассылки</title>

      <indexterm><primary>список рассылки</primary></indexterm>
      <para>Ветки &os.stable; и &os.current; кода по природе своей являются
        <emphasis>изменяющимися</emphasis>.  В разработке &os; участвуют
        люди, и время от времени случаются ошибки.</para>

      <para>Иногда эти ошибки достаточно безобидны и приводят к выводу
        нового диагностического сообщения.  Бывает, что изменение оказывается
        катастрофическим, и система не может загрузиться или разрушаются
        файловые системы (или что-нибудь ещё хуже).</para>

      <para>Если возникают подобные проблемы, в соответствующем списке
        рассылки публикуется сообщение <quote>heads up</quote>, в котором
        описывается природа проблемы и затрагиваемые системы.  Когда проблема
        решается, публикуется сообщение <quote>all clear</quote>.</para>

      <para>Если вы пытаетесь отслеживать &os.stable; или &os.current; и не
        читаете списки рассылки &a.stable; или &a.current; соответственно, то
        вы напрашиваетесь на неприятности.</para>
    </warning>

    <sect2>
      <title>Канонический способ обновления вашей системы</title>

      <para>Для обновления вашей системы вы должны воспользоваться следующей
        процедурой:</para>

      <screen>&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <para>Вы должны загрузиться в однопользовательский режим (например, по
        команде <command>boot -s</command> из приглашения загрузчика).  Затем
        выполните:</para>

      <screen>&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <para>Вы должны загрузиться в однопользовательский режим (например, по
        команде <command>boot -s</command> из приглашения загрузчика).  Затем
        выполните:</para>

      <screen>&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
        <title>Прочтите более полное описание</title>

        <para>Описанная выше последовательность является только краткой
          выжимкой для того, чтобы помочь вам начать.  Вы должны всё же
          прочесть последующие разделы для полного понимания каждого шага,
          особенно если собираетесь использовать собственную конфигурацию
          ядра.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Прочтите <filename>/usr/src/UPDATING</filename></title>

      <para>Перед тем, как делать что-либо, прочтите
        <filename>/usr/src/UPDATING</filename> (или соответствующий файл
        в вашей копии исходных текстов).  В этом файле
        содержится важная информация о проблемах, с которыми вы можете
        столкнуться, или указан порядок, в котором вы должны запускать
        определенные команды.  Если в файле <filename>UPDATING</filename>
        написано нечто, противоречащее тому, что вы здесь читаете, то
        нужно следовать указаниям в <filename>UPDATING</filename>.</para>

      <important>
        <para>Чтение <filename>UPDATING</filename> не заменит подписки на
          соответствующий список рассылки, как это и описано выше.  Эти два
          условия являются дополняющими, а не взаимоисключающими друг
          друга.</para>
      </important>
    </sect2>

    <sect2>
      <title>Проверьте содержимое <filename>/etc/make.conf</filename></title>
      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Просмотрите файлы <filename>/etc/defaults/make.conf</filename> и
        <filename>/etc/make.conf</filename>.  Первый содержит некоторые
        предопределенные по умолчанию значения &ndash; большинство из них
        закомментировано.  Чтобы воспользоваться ими при перестроении системы
        из исходных текстов, добавьте их в файл
        <filename>/etc/make.conf</filename>.  Имейте в виду, что все,
        добавляемое вами в <filename>/etc/make.conf</filename>, используется
        также каждый раз при запуске команды <command>make</command>, так что
        полезно задать здесь значения, подходящие вашей системе.</para>

      <para>Вероятно стоит скопировать строки
        <makevar>CFLAGS</makevar> и <makevar>NOPROFILE</makevar>,
        расположенные в <filename>/etc/defaults/make.conf</filename>, в файл
        <filename>/etc/make.conf</filename> и раскомментировать их.</para>

      <para>Посмотрите на другие определения (<makevar>COPTFLAGS</makevar>,
        <makevar>NOPORTDOCS</makevar> и так далее) и решите, нужны ли они
        вам.</para>
    </sect2>

    <sect2>
      <title>Обновите файлы в каталоге <filename>/etc</filename></title>

      <para>Каталог <filename>/etc</filename> содержит значительную часть
        информации о конфигурации вашей системы, а также скрипты, работающие
        в начале работы системы.  Некоторые из этих скриптов меняются от
        версии к версии &os;.</para>

      <para>Некоторые конфигурационные файлы также используются в ежедневной
        работе системы.  В частности, файл
        <filename>/etc/group</filename>.</para>

      <para>Случалось, что установочная часть <quote>make world</quote>
        ожидала существования определённых имен пользователей или групп.  При
        обновлении существует вероятность, что эти пользователи или группы не
        существуют.  Это вызывает проблемы при обновлении.</para>

      <para>Свежим примером этого является добавление пользователя
        <username>smmsp</username>.  Пользователи столкнулись с прерыванием
        процесса установки, когда &man.mtree.8; пыталась
        создать <filename>/var/spool/clientmqueue</filename>.</para>

      <para>Выходом является просмотр файла
        <filename>/usr/src/etc/group</filename> и сравнение списка групп в
        нем с вашим собственным.  Если в новом файле есть группы,
        отсутствующие в вашем, то скопируйте их.  Таким же образом вы должны
        переименовывать все группы в <filename>/etc/group</filename>, которые
        имеют тот же самый GID, но другое название в
        <filename>/usr/src/etc/group</filename>.</para>

      <para>Начиная с 4.6-RELEASE, вы можете запустить &man.mergemaster.8; в
        режиме, предваряющем построение системы, задаваемым опцией
        <option>-p</option>.  Она будет сравнивать только те файлы, которые
        необходимы для успешного выполнения целей
        <maketarget>buildworld</maketarget> или
        <maketarget>installworld</maketarget>.  Если ваша старая версия
        утилиты <command>mergemaster</command> не поддерживает опцию
        <option>-p</option>, воспользуйтесь новой версией из дерева исходных
        текстов при первом запуске:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
        <para>Если вы параноик, можете поискать файлы, владельцем которых
          является та группа, которую вы переименовываете или удаляете:</para>

        <screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

        <para>выдаст список всех файлов, владельцем которых является группа
          <replaceable>GID</replaceable> (задаваемая именем или
          численным значением ID).</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Перейдите в однопользовательский режим</title>
      <indexterm><primary>однопользовательский режим</primary></indexterm>

      <para>Вам может понадобиться откомпилировать систему в
        однопользовательском режиме.  Кроме обычного выигрыша в
        скорости процесса, переустановка системы затрагивает много важных
        системных файлов, все стандартные выполнимые файлы системы,
        библиотеки, include-файлы и так далее.  Изменение их на работающей
        системе (в частности, в которой активно работают пользователи) может
        привести к неприятностям.</para>

      <indexterm><primary>многопользовательский режим</primary></indexterm>
      <para>Другим способом является компиляция системы в многопользовательском
        режиме с последующим переходом в однопользовательский режим для
        выполнения установки.  Если вы хотите поступить именно так, просто
        следуйте инструкциям до момента окончания построения.  Вы можете
        отложить переход в однопользовательский режим до завершения целей
        <maketarget>installkernel</maketarget> или
        <maketarget>installworld</maketarget>.</para>

      <para>Как администратор, вы можете выполнить:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>на работающей системе, что переведет ее в однопользовательский
        режим.</para>

      <para>Либо вы можете выполнить перезагрузку и в приглашении загрузчика
        задать флаг <option>-s</option>.  После этого система загрузится в
        однопользовательском режиме.  В приглашении командного процессора вы
        должны запустить:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Эти команды выполняют проверку файловых систем, повторно монтируют
        <filename>/</filename> в режиме чтения/записи, монтируют все
        остальные файловые системы UFS, перечисленные в файле
        <filename>/etc/fstab</filename> и включат подкачку.</para>

      <note>
        <para>Если часы в вашей CMOS настроены на местное время, а не на GMT
          (это имеет место, если команда &man.date.1; выдаёт
          неправильные время и зону), то вам может понадобиться запустить
          следующую команду:</para>

        <screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

        <para>Это обеспечит корректную настройку местного часового пояса
          &mdash; без этого впоследствии вы можете столкнуться с некоторыми
          проблемами.</para>
      </note>
    </sect2>

    <sect2>
      <title>Удалите <filename>/usr/obj</filename></title>

      <para>При перестроении частей системы они помещаются в каталоги,
        которые (по умолчанию) находятся в <filename>/usr/obj</filename>.
        Структура повторяет структуру <filename>/usr/src</filename>.</para>

      <para>Вы можете ускорить выполнение процесса <quote>make world</quote>
        и, возможно, избавить себя от некоторой головной боли, связанной с
        зависимостями, удалив этот каталог.</para>

      <para>На некоторых файлах из <filename>/usr/obj</filename> могут быть
        установлены специальные флаги (обратитесь к &man.chflags.1; за
        дополнительной информацией), которые сначала должны быть
        сняты.</para>

      <screen>
&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput>
      </screen>
    </sect2>

    <sect2>
      <title>Перекомпилируйте исходные тексты</title>

      <sect3>
        <title>Сохраните вывод</title>

        <para>Неплохо сохранить вывод, получаемый при работе программы
          &man.make.1;, в файл.  Если что-то вдруг пойдет не так, вы будете
          иметь копию сообщения об ошибке и полную картину того, где она
          произошла.  Хотя это может и не помочь в определении причин
          происходящего, это может помочь другим, если вы опишите вашу
          проблему в одном из списков рассылки &os;.</para>

        <para>Проще всего это сделать при помощи команды &man.script.1; с
          параметром, в котором указано имя файла, в который нужно сохранить
          вывод.  Вы должны сделать это непосредственно перед тем, как
          перестроить систему, а по окончании процесса набрать
          <userinput>exit</userinput>.</para>

        <screen>
&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make world</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;
        </screen>

        <para>Если вы делаете это, <emphasis>не</emphasis> сохраняйте
          вывод в <filename>/tmp</filename>.  Этот каталог может быть
          очищен при следующей перезагрузке.  Лучше сохранить его в
          <filename>/var/tmp</filename> (как в предыдущем примере) или в
          домашнем каталоге пользователя <username>root</username>.</para>
      </sect3>

      <sect3 id="make-buildworld">
        <title>Компиляция базовых компонентов системы</title>

        <para>Вы должны находиться в каталоге
          <filename>/usr/src</filename>:</para>

        <screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

        <para>(если, конечно, ваш исходный код не находится в другом месте, в
          случае чего вам нужно перейти в соответствующий каталог).</para>

        <indexterm><primary><command>make</command></primary></indexterm>

        <para>Для полного перестроения системы используется
          команда &man.make.1;.  Эта команда читает инструкции из файла
          <filename>Makefile</filename>, описывающего, как должны быть
          перестроены программы, которые составляют систему &os;, в каком
          порядке они должны быть построены и так далее.</para>

        <para>Общий формат командной строки, которую вы будет набирать,
          таков:</para>

        <screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

        <para>В этом примере <option>-<replaceable>x</replaceable></option>
          является параметром, который вы передаете в &man.make.1;.
          Обратитесь к справочной странице программы &man.make.1;, которая
          содержит список возможных параметров.</para>

        <para><option>-D<replaceable>VARIABLE</replaceable></option>
          передает переменную в <filename>Makefile</filename>.  Поведение
          <filename>Makefile</filename> определяется этими переменными.  Это
          те же самые переменные, которые задаются в
          <filename>/etc/make.conf</filename>, и это &mdash; еще один способ
          их задания.</para>

        <screen>&prompt.root; <userinput>make -DNOPROFILE=true <replaceable>target</replaceable></userinput></screen>

        <para>является другим способом указания того, что библиотеки для
          профилирования строить не нужно, и соответствует строке</para>

        <programlisting>NOPROFILE=    true	# Обход построения библиотек для профилирования</programlisting>

        <para>в файле <filename>/etc/make.conf</filename>.</para>

        <para><replaceable>target</replaceable> указывает программе
          &man.make.1; на то, что вы хотите сделать.  Каждый файл
          <filename>Makefile</filename> определяет некоторое количество
          различных <quote>целей</quote>, и ваш выбор цели определяет то, что
          будет делаться.</para>

        <para>Некоторые цели, перечисленные в файле
          <filename>Makefile</filename>, не предназначены для вызова.  Просто
          они используются в процессе построения для разбиения его на этапы.</para>

        <para>В большинстве случаев вам не нужно передавать никаких
          параметров в &man.make.1;, так что ваша команда будет выглядеть
          примерно так:</para>

        <screen>
&prompt.root; <userinput>make <replaceable>target</replaceable></userinput>
        </screen>

        <para>Начиная с версии &os; 2.2.5 (на самом деле впервые это было
          сделано в ветке &os.current;, а затем адаптировано в &os.stable;
          где-то между 2.2.2 и 2.2.5) цель <maketarget>world</maketarget> была
          разделена на две: <maketarget>buildworld</maketarget> и
          <maketarget>installworld</maketarget>.</para>

        <para>Как указывают на это названия,
          <maketarget>buildworld</maketarget> строит полностью новое дерево
          в каталоге <filename>/usr/obj</filename>, а
          <maketarget>installworld</maketarget> устанавливает это дерево на
          используемой машине.</para>

        <para>Это весьма полезно по двум причинам.  Во-первых, это позволяет
          вам безопасно строить систему, зная, что компоненты вашей рабочей
          системы затронуты не будут.  Построение
          <quote>самодостаточно</quote>.  По этой причине вы можете спокойно
          запустить <maketarget>buildworld</maketarget> на машине, работающей в
          многопользовательском режиме без опаски получить какие-либо проблемы.
          Но всё же рекомендуется запускать цель
          <maketarget>installworld</maketarget> в однопользовательском
          режиме.</para>

        <para>Во-вторых, это позволяет вам использовать монтирование по NFS для
          обновления многих машин в сети.  Если у вас есть три машины,
          <hostid>A</hostid>, <hostid>B</hostid> и <hostid>C</hostid>, которые
          вы хотите обновить, запустите <command>make buildworld</command> и
          <command>make installworld</command> на машине <hostid>A</hostid>.
          Хосты <hostid>B</hostid> и <hostid>C</hostid> должны будут
          затем смонтировать по NFS каталоги <filename>/usr/src</filename>
          и <filename>/usr/obj</filename> с машины <hostid>A</hostid>, и вы
          сможете запустить <command>make installworld</command> для установки
          результатов построения на машинах <hostid>B</hostid> и
          <hostid>C</hostid>.</para>

        <para>Хотя цель <maketarget>world</maketarget> всё ещё имеется в
          наличии, вам настоятельно рекомендуется не пользоваться ею.</para>

        <para>Выполните</para>

        <screen>&prompt.root; <userinput>make buildworld</userinput></screen>

        <para>В настоящее время имеется возможность задавать команде
          <command>make</command> параметр <option>-j</option>, который
          приводит к запуску нескольких одновременно работающих процессов.
          Наиболее полезно использовать это на многопроцессорных машинах.
          Однако, так как процесс компиляции больше всего требователен к
          подсистеме ввода/вывода, а не к производительности процессора, это
          можно использовать и на машинах с одним процессором.</para>

        <para>На типичной машине с одним CPU вы должны запускать:</para>

        <screen>
&prompt.root; <userinput>make -j4 buildworld</userinput>
        </screen>

        <para>&man.make.1; будет иметь до 4 одновременно работающих
          процессов.  Эмпирические замеры, опубликованные как-то в списке рассылки,
          показывают, что в среднем это дает наибольшее увеличение
          производительности.</para>

        <para>Если у вас многопроцессорная машина и вы используете ядро с
          настройками для SMP, попробуйте использовать значения между 6 и
          10 и посмотрите, как это отразится на скорости работы.</para>

        <para>Имейте в виду, что это все еще экспериментальная возможность, и
          изменения в дереве исходных текстов иногда могут быть не
          совместимы с параллельной сборкой.  Если
          система не может быть построена с использованием этого параметра,
          попробуйте еще раз без него перед тем, как сообщать о
          проблемах.</para>
      </sect3>

      <sect3>
        <title>Время на построение</title>
        <indexterm>
          <primary><command>make world</command></primary>
          <secondary>затраченное время</secondary>
        </indexterm>

        <para>На время компиляции влияет множество факторов, но на данный
          момент &pentium;&nbsp;III частотой 500&nbsp;МГц и 128&nbsp;МБ ОЗУ
          справляется с построением дерева &os.stable; примерно за 2&nbsp;часа
          без дополнительных хитростей и убыстряющих процесс уловок.  Дерево
          &os.current; строится несколько дольше.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Откомпилируйте и установите новое ядро</title>
      <indexterm>
        <primary>ядро</primary>
        <secondary>компиляция</secondary>
      </indexterm>

      <para>Чтобы получить полную отдачу от вашей новой системы, вы должны
        перекомпилировать ядро.  Это практически необходимость, так как
        отдельные структуры в памяти могут меняться, и программы типа
        &man.ps.1; и &man.top.1; не будут работать, пока версии ядра и
        исходных текстов системы не будут совпадать.</para>

      <para>Самым простым и надежным способом сделать это является компиляция и
        установка ядра на основе <filename>GENERIC</filename>.  Хотя в
        <filename>GENERIC</filename> могут оказаться не все необходимые для
        работы вашей системы устройства, в нем имеется все необходимое
        для перезагрузки вашей системы обратно в однопользовательский режим.
        Это является хорошей проверкой на правильность работы новой системы.
        После загрузки с ядром <filename>GENERIC</filename> и проверки
        работоспособности системы вы можете построить новое ядро на основе
        вашего обычного конфигурационного файла ядра.</para>

      <para>Если вы обновляете систему до &os; 4.0 и выше, то старая
        процедура построения ядра (как это описано в <xref
        linkend="kernelconfig">) не подходит.  Вместо этого вы должны выполнить
        следующие команды <emphasis>после</emphasis> того, как <link
        linkend="make-buildworld">перестроили систему командой
        <maketarget>buildworld</maketarget></link>.</para>

      <note>
        <para>Если вы хотите построить собственное ядро и уже подготовили файл
          конфигурации, просто используйте
          <literal>KERNCONF=<replaceable>MYKERNEL</replaceable></literal>
          следующим образом:</para>

        <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>

        <para>Для FreeBSD&nbsp;4.2 и более старых версиях вы должны заменять
          <literal>KERNCONF=</literal> на <literal>KERNEL=</literal>.
          4.2-STABLE, сгруженная до 2 февраля 2001 года, не распознаёт
          <literal>KERNCONF=</literal>.</para>
      </note>

      <para>Заметьте, что, если вы установили
        <literal>kern.securelevel</literal> в значение, превышающее 1,
        <emphasis>и</emphasis> установили флаг <literal>noschg</literal> или
        подобный на бинарный файл ядра, то вы будете вынуждены перейти в
        однопользовательский режим для того, чтобы воспользоваться
        <maketarget>installkernel</maketarget>.  В противном случае вы
        должны выполнять эти команды без проблем.  Обратитесь к справочным
        страницам об &man.init.8; для получения подробной информации о
        <literal>kern.securelevel</literal> и &man.chflags.1; для получения
        информации о различных флагах файлов.</para>

      <para>Если вы производите обновление до версии &os; ниже 4.0, то нужно
        использовать старую процедуру построения ядра.  Однако
        рекомендуется использовать новую версию программы &man.config.8; со
        следующей командной строкой.</para>

      <screen>
&prompt.root; <userinput>/usr/obj/usr/src/usr.sbin/config/config<replaceable>KERNELNAME</replaceable></userinput>
      </screen>
    </sect2>

    <sect2>
      <title>Перезагрузитесь в однопользовательский режим</title>
      <indexterm><primary>однопользовательский режим</primary></indexterm>

      <para>Для проверки работоспособности ядра вы должны перезагрузить систему
        и перейти в однопользовательский режим.  Сделайте это, следуя указаниям
        в <xref linkend="makeworld-singleuser">.</para>
    </sect2>

    <sect2>
      <title>Установите новые версии системных программ</title>

      <para>Если вы компилировали достаточно свежую версию &os;, в которой
        имеется команда <command>make buildworld</command>, то для установки
        новых версий программ вы должны теперь выполнить команду
        <maketarget>installworld</maketarget>.</para>

      <para>Запустите</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
        <para>Если при выполнении команды <command>make buildworld</command> вы
          задавали значения каких-либо переменных, то при выполнении
          <command>make installworld</command> вы должны задать те же самые
          переменные.  Это не всегда так для остальных параметров; например,
          при выполнении <maketarget>installworld</maketarget> никогда не
          должен использоваться параметр <option>-j</option>.</para>

        <para>Например, если вы выполняли команду:</para>

        <screen>&prompt.root; <userinput>make -DNOPROFILE buildworld</userinput></screen>

        <para>то результат её выполнения должен устанавливаться командой</para>

        <screen>&prompt.root; <userinput>make -DNOPROFILE installworld</userinput></screen>

        <para>В противном случае будет делаться попытка установить библиотеки
          для профилирования, которые не компилировались на этапе выполнения
          команды <command>make buildworld</command>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Обновите файлы, не обновленные по команде
        <command>make world</command></title>

      <para>При перестроении системы не будут обновляться некоторые каталоги
        (в частности, <filename>/etc</filename>, <filename>/var</filename> и
        <filename>/usr</filename>) с конфигурационными
        файлами.</para>

      <para>Самым простым способом обновить такие файлы является запуск
        утилиты &man.mergemaster.8;, хотя можно сделать это и вручную, если вам
        так больше нравится.  Вне зависимости от выбранного вами способа
        обязательно сделайте резервную копию каталога <filename>/etc</filename>
        на случай, если произойдёт что-то непредвиденное.</para>

      <sect3 id="mergemaster">
        <sect3info>
          <authorgroup>
            <author>
              <firstname>Tom</firstname>
              <surname>Rhodes</surname>
              <contrib>Текст предоставил </contrib>
            </author>
          </authorgroup>
        </sect3info>

        <title><command>mergemaster</command></title>

        <indexterm>
          <primary><command>mergemaster</command></primary>
        </indexterm>

        <para>Утилита &man.mergemaster.8; является скриптом для оболочки Боурна,
          которая поможет вам в определении разницы между вашими
          конфигурационными файлами в каталоге <filename>/etc</filename> и
          конфигурационными файлами из дерева исходных текстов
          <filename>/usr/src/etc</filename>.  Это является рекомендуемым
          способом синхронизации системных конфигурационных файлов с теми, что
          размещены в дереве исходных текстов.</para>

        <para><command>mergemaster</command> была интегрирована в базовый
          комплект системы FreeBSD между выпусками 3.3-RELEASE и 3.4-RELEASE,
          что означает её наличие во всех системах -STABLE и -CURRENT, начиная с
          3.3.</para>

        <para>Для начала просто наберите <command>mergemaster</command> в
          приглашении командной строки и посмотрите, что происходит.
          <command>mergemaster</command> построит временное окружение для
          пользователя root, начиная от <filename>/</filename>, а затем
          заполнит его различными системными конфигурационными файлами.  Эти
          файлы затем будут сравниваться с теми, что установлены в вашей
          системе.  В этот момент файлы, которые имеют отличия, будут выданы в
          формате &man.diff.1;, где знак <option>+</option> будет означать
          добавленные или изменённые строки, а знак <option>-</option> будет
          означать строки, которые были либо полностью удалены, либо заменены
          на новые.  Обратитесь к страницам справочной системы по команде
          &man.diff.1; для получения более полной информации о синтаксисе
          команды &man.diff.1; и формате выдачи отличий в файлах.</para>

        <para>Затем &man.mergemaster.8; выдаст вам каждый файл, в котором есть
          изменения, и в этот момент у вас есть возможность либо удалить новый
          файл (который будем считать временным), установить временный файл в
          его неизменённом виде, объединить временный файл с установленным на
          данный момент, либо просмотреть выдачу &man.diff.1; ещё раз.</para>

        <para>Выбор удаления временного файла укажет &man.mergemaster.8; на то,
          что мы хотим оставить наш текущий файл без изменений и удалить его
          новую версию.  Делать это не рекомендуется, если только
          у вас нет причин вносить изменения в текущий файл.  Вы можете
          получить помощь в любое время, набрав <keycap>?</keycap> в
          приглашении &man.mergemaster.8;.  Если пользователь выбирает пропуск
          файла, запрос появится снова после того, как будут обработаны все
          остальные файлы.</para>

        <para>Выбор установки немодифицированного временного файла приведёт к
          замене текущего файла новым.  Для большинства немодифицированных
          файлов это является подходящим вариантом.</para>

        <para>Выбор варианта с объединением файла приведёт к вызову текстового
          редактора, содержащего текст обоих файлов.  Теперь вы можете
          объединить их, просматривая оба файла на экране, и выбирая те части
          из обоих, что подходят для окончательного варианта.  Когда файлы
          сравниваются на экране, то нажатие <keycap>l</keycap> выбирает
          содержимое слева, а нажатие <keycap>r</keycap> выбирает содержимое
          справа.  В окончательном варианте будет файл, состоящий из обеих
          частей, который и будет установлен.  Этот вариант используется для
          файлов, настройки в которых изменялись пользователем.</para>

        <para>Выбор повторного просмотра &man.diff.1;-разниц выдаст вам разницы
          между файлами, как это делала утилита &man.mergemaster.8; до того,
          как запросила вас о выборе.</para>

        <para>После того, как утилита &man.mergemaster.8; закончит работу с
          системными файлами, она выдаст запрос относительно других параметров.
          &man.mergemaster.8; может запросить вас относительно перестроения
          файла паролей и/или запуска &man.MAKEDEV.8; при использовании FreeBSD
          версий, меньших чем 5.0, и завершит запросом на удаление оставшихся
          временных файлов.</para>
      </sect3>

      <sect3>
        <title>Обновление в ручном режиме</title>

        <para>Однако если вы хотите произвести обновление вручную, то вы не
          можете просто скопировать файлы из <filename>/usr/src/etc</filename> в
          <filename>/etc</filename> и получить работающую систему.  Некоторые
          из этих файлов сначала нужно <quote>установить</quote>.  Это нужно
          потому, что каталог <filename>/usr/src/etc</filename>
          <emphasis>не</emphasis> является копией того, что должен содержать
          ваш каталог <filename>/etc</filename>.  Кроме того, есть файлы,
          которые должны присутствовать в <filename>/etc</filename>, но которых
          нет в <filename>/usr/src/etc</filename>.</para>

        <para>Если вы используете &man.mergemaster.8; (как это рекомендуется),
          то вы можете перейти сразу к <link linkend="update-dev">следующему
          разделу</link>.</para>

      <para>Вручную проще всего сделать это, установив файлы в новый каталог,
        а затем пройтись по ним, отмечая разницу.</para>

      <warning>
        <title>Сделайте резервную копию вашего каталога
          <filename>/etc</filename></title>

        <para>Хотя, в теории, никаких автоматических действий с этим
          каталогом не производится,
          всегда лучше чувствовать себя уверенным.  Так что скопируйте
          имеющийся каталог <filename>/etc</filename> в какое-нибудь
          безопасное место.  Запустите что-то вроде:</para>

        <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

        <para><option>-R</option> задает выполнение рекурсивного копирования,
          а <option>-p</option> сохраняет даты, владельца файлов и тому
          подобное.</para>
      </warning>

      <para>Вам нужно создать шаблонную структуру каталогов для установки
        нового содержимого <filename>/etc</filename> и других файлов.
        Подходящим местом является <filename>/var/tmp/root</filename>, и в нём
        потребуется разместить некоторое количество подкаталогов.</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>Эти команды приведут к созданию нужной структуры каталогов и
        установке файлов.  Множество каталогов, созданных в
        <filename>/var/tmp/root</filename>, будут пустыми и должны быть удалены.
        Проще всего сделать это так:</para>

      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

      <para>Эти команды удалят все пустые каталоги.  (Стандартный поток
        диагностических сообщений перенаправляется в
        <filename>/dev/null</filename> для исключения предупреждений о
        непустых каталогах.)</para>

      <para>Теперь <filename>/var/tmp/root</filename> содержит все файлы,
        которые должны быть помещены в соответствующие места в
        <filename>/</filename>.  Теперь пройдитесь по каждому их этих файлов
        и определите, чем они отличаются от имеющихся у вас файлов.</para>

      <para>Заметьте, что некоторые из файлов, которые были установлены в
        каталог <filename>/var/tmp/root</filename>, имеют первым символом
        <quote>.</quote>.  На момент написания единственными такими файлами
        являлись файлы начальных скриптов командных процессоров в
        <filename>/var/tmp/root/</filename> и
        <filename>/var/tmp/root/root/</filename>, хотя могут быть и другие
        (зависит от того, когда вы это читаете).  Обязательно пользуйтесь
        командой <command>ls -a</command>, чтобы выявить их.</para>

      <para>Проще всего сделать это путём сравнения двух файлов при помощи
        команды &man.diff.1;:</para>

      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

      <para>Эта команда покажет разницу между вашим файлом
        <filename>/etc/shells</filename> и новым файлом
        <filename>/var/tmp/root/etc/shells</filename>.  Используйте это для
        определения того, переносить ли сделанные вами изменения или
        скопировать поверх вашего старого файла.</para>

      <tip>
        <title>Называйте новый корневой каталог
          (<filename>/var/tmp/root</filename>) по дате, чтобы вы смогли легко
          выявить разницу между версиями</title>

        <para>Частое перестроение системы означает также и частое обновление
          <filename>/etc</filename>, которое может быть несколько
          обременительным.</para>

        <para>Вы можете ускорить этот процесс, сохраняя копию последнего
          набора измененных файлов, которые вы перенесли в
          <filename>/etc</filename>.  Следующая процедура подаст вам одну
          идею о том, как это сделать.</para>

        <procedure>
          <step>
            <para>Выполните перестроение системы обычным образом.  Когда вы
              вам потребуется обновить <filename>/etc</filename> и другие
              каталоги, дайте целевому каталогу имя на основе текущей даты.
              Если вы делаете это 14 февраля 1998 года, то вы можете сделать
              следующее:</para>

            <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
          </step>

          <step>
            <para>Перенесите изменение из этого каталога, как это описано
              выше.</para>

            <para><emphasis>Не</emphasis> удаляйте каталог
              <filename>/var/tmp/root-19980214</filename> после окончания
              этого процесса.</para>
          </step>

          <step>
            <para>Когда вы сгрузите самую последнюю версию исходного кода и
              перестроите систему, выполните шаг 1.  Это даст вам новый
              каталог, который может называться
              <filename>/var/tmp/root-19980221</filename> (если вы ждете
              неделю между обновлениями).</para>
          </step>

          <step>
            <para>Теперь вы можете видеть изменения, которые были сделаны
              за прошедшую неделю, выполнив при помощи команды &man.diff.1;
              рекурсивное сравнение двух каталогов:</para>

            <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

            <para>Как правило, здесь содержится гораздо меньше отличий, чем
              между каталогами
              <filename>/var/tmp/root-19980221/etc</filename> и
              <filename>/etc</filename>.  Так как отличий меньше, то и легче
              перенести эти изменения в ваш каталог
              <filename>/etc</filename>.</para>
          </step>

          <step>
            <para>Теперь вы можете удалить более старый из двух каталогов
              <filename>/var/tmp/root-*</filename>:</para>

            <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
          </step>

          <step>
            <para>Повторяйте этот процесс всякий раз, когда вам нужно
              перенести изменения в каталог <filename>/etc</filename>.</para>
          </step>
        </procedure>

        <para>Для автоматической генерации имён каталогов можно
          использовать команду &man.date.1;:</para>

          <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
        </tip>
      </sect3>
    </sect2>

    <sect2 id="update-dev">
      <title>Обновите <filename>/dev</filename></title>

      <note>
        <indexterm><primary>DEVFS</primary></indexterm>

        <para>Если вы работаете с FreeBSD&nbsp;5.0 или более поздними версиями,
          то можете спокойно пропустить этот раздел.  В этих версиях
          &man.devfs.5; используется для выделения файлов устройств в режиме,
          прозрачном для пользователя.</para>

        <para>Если вы используете DEVFS, то этого можно не делать.</para>
      </note>

      <para>В большинстве случаев утилита &man.mergemaster.8; обнаружит, что
        необходимо обновить файлы устройств, и предложит сделать это
        автоматически.  Эти указания описывают, как обновить файлы устройств
        вручную.</para>

      <para>Для безопасности этот процесс делается в несколько шагов.</para>

      <procedure>
        <step>
          <para>Скопируйте <filename>/var/tmp/root/dev/MAKEDEV</filename> в
            <filename>/dev</filename>:</para>

          <screen>&prompt.root; <userinput>cp /var/tmp/root/dev/MAKEDEV /dev</userinput></screen>

          <indexterm>
            <primary><filename>MAKEDEV</filename></primary>
          </indexterm>

          <para>Если вы использовали &man.mergemaster.8; для обновления
            <filename>/etc</filename>, то ваш скрипт
            <filename>MAKEDEV</filename> уже должен быть обновлен, так что
            его не нужно проверять (утилитой &man.diff.1;) и копировать
            вручную в случае необходимости.</para>
        </step>

        <step>
          <para>Теперь выведите текущее содержимое вашего каталога
            <filename>/dev</filename>.  Этот список должен содержать права,
            владельцев, старшее и младшее числа каждого файла, но не должен
            содержать информацию о времени.  Проще всего это сделать,
            отрезав при помощи &man.awk.1; часть информации:</para>

          <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>ls -l | awk '{print $1, $2, $3, $4, $5, $6, $NF}' > /var/tmp/dev.out</userinput></screen>
        </step>

        <step>
          <para>Повторно создайте все файлы устройств:</para>

          <screen>&prompt.root; <userinput>sh MAKEDEV all</userinput></screen>
        </step>

        <step>
          <para>Создайте ещё один список содержимого каталога, на этот раз в
            <filename>/var/tmp/dev2.out</filename>.  Теперь просмотрите оба эти
            файла и поищите файлы устройств, которые вы забыли создать.  Таких
            быть не должно, но лишний раз удостовериться не помешает.</para>

          <screen>&prompt.root; <userinput>diff /var/tmp/dev.out /var/tmp/dev2.out</userinput></screen>

          <para>Скорее всего, вы заметите разногласия в именовании дисковых
            слайсов, что решается такими командами, как:</para>

          <screen>&prompt.root; <userinput>sh MAKEDEV sd0s1</userinput></screen>

          <para>для повторного создания устройств слайсов.  Точное название
            зависит от вашей системы и может отличаться от приведённого.</para>
        </step>
      </procedure>
    </sect2>

    <sect2>
      <title>Обновите <filename>/stand</filename></title>

      <note>
        <para>Этот шаг описан только для полноты.  Он может быть
          безболезненно опущен.  Если вы работаете с FreeBSD&nbsp;5.2 или
          более поздней версией, то для пользователей каталог
          <filename>/rescue</filename> автоматически обновляется до текущего
          состояния, а статически компилируемые выполнимые файлы во время
          выполнения команды <command>make installworld</command>, поэтому
          каталог <filename>/stand</filename> обновлять не нужно.</para>
      </note>

      <para>В целях полноты обновления вам может потребоваться обновить также
        файлы в каталоге <filename>/stand</filename>.  Эти файлы представляют
        собой жёсткие ссылки на выполнимый файл
        <filename>/stand/sysinstall</filename>.  Этот файл должен быть
        статически скомпонован, чтобы его работа не зависела от других
        файловых систем (в частности, от наличия смонтированной файловой
        системы <filename>/usr</filename>).</para>

      <screen>&prompt.root; <userinput>cd /usr/src/release/sysinstall</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Перезагрузка</title>

      <para>Теперь вы сделали всё.  После того, как вы проверили, что всё
        на месте, можете перегрузить систему.  Простая команда
        &man.shutdown.8; должна это сделать:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Завершение</title>

      <para>Теперь у вас имеется успешно обновлённая система &os;.
        Поздравляем!</para>

      <para>Если что-то работает неправильно, можно с лёгкостью перестроить
        конкретную часть системы.  Например, если вы случайно удалили файл
        <filename>/etc/magic</filename> в процессе обновления или переноса
        <filename>/etc</filename>, то команда &man.file.1; перестанет работать.
        В таком случае это можно исправить вот так:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Вопросы?</title>

      <qandaset>
        <qandaentry>
          <question>
            <para>Нужно ли полностью перестраивать систему при каждом
              изменении?</para>
          </question>

          <answer>
            <para>Простого ответа на этот вопрос нет, так как это зависит от
              характера изменения.  Например, если вы только что выполнили
              <application>CVSup</application>, и оказалось, что с момента
              последнего его запуска были изменены следующие файлы:</para>

            <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

            <para>то перестраивать всю систему незачем.  Вы можете просто
              перейти в соответствующий подкаталог и выдать команду
              <command>make all install</command>, этого будет достаточно.
              Однако, если меняется что-то важное, например,
              <filename>src/lib/libc/stdlib</filename>, то вы должны
              перестроить всю систему или по крайней мере те ее части, которые
              скомпонованы статически.</para>

            <para>В конце концов, выбор за вами.  Может быть вам нравится
              перестраивать систему, скажем, каждый вечер, а изменения
              скачивать ночью.  Или вы можете захотеть перестраивать только
              те вещи, которые менялись, но быть уверенным, что отслежены все
              изменения.</para>

            <para>И, конечно же, всё это зависит от того, как часто вы хотите
              делать обновление, и отслеживаете ли вы &os.stable; или
              &os.current;.</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>Компиляция прерывается с большим количеством ошибок по
              сигналу 11 (или с другим номером сигнала).  Что
              случилось?</para>
          </question>

          <indexterm><primary>сигнал 11</primary></indexterm>

          <answer>
            <para>Как правило, это говорит о проблемах с оборудованием.
              (Пере)построение системы является эффективным стресс-тестом для
              вашего оборудования и частенько выявляет проблемы с памятью.
              Обычно это проявляется в виде неожиданных сбоев компилятора
              или получения странных программных сигналов.</para>

            <para>Явным указателем на это является то, что при перезапуске
              процедуры построения она прекращается в различные моменты
              времени.</para>

            <para>В этом случае вы мало что можете сделать, разве что
              попробовать заменить комплектующие вашей машины для определения
              сбоящей компоненты.</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>Могу ли я удалить каталог <filename>/usr/obj</filename>
              после окончания?</para>
          </question>

          <answer>
            <para>Если отвечать коротко, то да.</para>

            <para>Каталог <filename>/usr/obj</filename> содержит все
              объектные файлы, которые создаются во время фазы компиляции.
              Обычно одним из первых шагов в процессе <quote>make world</quote>
              является удаление этого каталога.  В этом случае сохранение
              <filename>/usr/obj</filename> после окончания имеет мало смысла;
              вдобавок, он будет занимать большой объём дискового
              пространства (на данный момент около 340&nbsp;МБ).</para>

            <para>Однако если вы точно знаете, что делаете, то можете заставить
              процедуру <quote>make world</quote> пропустить этот шаг.  Это
              позволит последующие построения выполняться гораздо быстрее, так
              как большинство исходных текстов не нужно будет
              перекомпилировать.  Оборотной стороной медали этого подхода
              является вероятность появления некоторых проблем с зависимостями,
              что может привести к прерыванию построения по странным причинам.
              Это частенько вызывает шум в списках рассылки &os;, когда
              кто-либо жалуется на прерывание процесса построения, не обращая
              внимания на то, что он пытается срезать углы на
              повороте.</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>Могут ли быть продолжены прерванные процессы
              построения?</para>
          </question>

          <answer>
            <para>Это зависит от того, насколько далеко зашел процесс
              построения перед тем, как вы обнаружили проблему.</para>

            <para><emphasis>В общем случае</emphasis> (и это несложное и
              быстрое правило) процесс <quote>make world</quote> строит
              новые копии необходимых инструментальных средств (таких, как
              &man.gcc.1; и &man.make.1;) и системные библиотеки.  Затем эти
              средства и библиотеки устанавливаются.  Новые инструментальные
              средства и библиотеки затем используются для перестроения
              самих себя, и повторно устанавливаются.  Система в целом
              (теперь включая обычные пользовательские программы, такие,
              как &man.ls.1; или &man.grep.1;) теперь перестраивается с
              новыми системными файлами.</para>

            <para>Если вы на последнем шаге, и вы знаете это (потому что
              просматривали вывод, который сохраняете), то вы можете
              (достаточно безболезненно) выполнить команду:</para>

            <screen><emphasis>&hellip; исправление проблемы &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNOCLEAN all</userinput></screen>

            <para>При этом результат предыдущего запуска
              <quote>make world</quote> откатываться не будет.</para>

            <para>Если вы видите сообщение:</para>

            <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

            <para>в выводе команды <quote>make world</quote>, то делать так
              достаточно безопасно.</para>

            <para>Если этого сообщения не было, или вы в этом не уверены, то
              всегда лучше обезопасить себя, и начать построение с самого
              начала.</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>Как ускорить процесс построения системы?</para>
          </question>

          <answer>
            <itemizedlist>
              <listitem>
                <para>Работайте в однопользовательском режиме.</para>
              </listitem>

              <listitem>
                <para>Разместите каталоги <filename>/usr/src</filename> и
                  <filename>/usr/obj</filename> в отдельных файловых
                  системах, располагающихся на разных дисках.  Если это
                  возможно, то разместите эти диски на разных дисковых
                  контроллерах.</para>
              </listitem>

              <listitem>
                <para>Ещё лучше разместить эти файловые системы на нескольких
                  дисках при помощи устройства &man.ccd.4; (драйвер
                  объединённых дисков).</para>
              </listitem>

              <listitem>
                <para>Выключите генерацию профилирующего кода (установив
                  <quote>NOPROFILE=true</quote> в файле
                  <filename>/etc/make.conf</filename>).  Вам это скорее
                  всего никогда не понадобится.</para>
              </listitem>

              <listitem>
                <para>Также в <filename>/etc/make.conf</filename> установите
                  значение <makevar>CFLAGS</makevar> во что-то типа <option>-O
                  -pipe</option>.  Оптимизация <option>-O2</option> выполняется
                  гораздо медленнее, а разница между <option>-O</option> и
                  <option>-O2</option> обычно несущественна.
                  <option>-pipe</option> позволяет компилятору использовать для
                  связи вместо временных файлов программные каналы, что
                  уменьшает обращение к диску (за счет оперативной
                  памяти).</para>
              </listitem>

              <listitem>
                <para>Передайте утилите &man.make.1; параметр
                  <option>-j<replaceable>n</replaceable></option> для запуска
                  параллельно нескольких процессов.  Обычно это помогает вне
                  зависимости от того, сколько процессоров установлено в вашей
                  машине.</para>
              </listitem>

              <listitem>
                <para>Файловая система, на которой располагается каталог
                  <filename>/usr/src</filename>, может быть смонтирована (или
                  перемонтирована) с опцией <option>noatime</option>.  При этом
                  запись на диск информации о времени последнего доступа к
                  файлам будет отключена.  Скорее всего, вам эта информация и
                  не нужна.</para>

                <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

                <warning>
                  <para>В примере предполагается, что
                    <filename>/usr/src</filename> располагается на
                    собственной файловой системе.  Если это не так (то
                    есть он является частью, скажем,
                    <filename>/usr</filename>), то вам нужно использовать
                    точку монтирования той файловой системы, а не
                    <filename>/usr/src</filename>.</para>
                </warning>
              </listitem>

              <listitem>
                <para>Файловая система, на которой располагается
                  <filename>/usr/obj</filename>, может быть смонтирована (или
                  перемонтирована) с параметром <option>async</option>.  Это
                  приведёт к тому, что операции записи на диск будут
                  выполняться асинхронно.  Другими словами, запись будет
                  завершаться немедленно, но данные записываться на диск
                  несколькими секундами позже.  Это позволит объединять
                  операции записи и приведёт к значительному приросту
                  производительности.</para>

                <warning>
                  <para>Имейте в виду, что эта опция делает вашу файловую
                    систему менее устойчивой.  С этой опцией имеется больше
                    шансов, что при перезагрузке машины после неожиданного
                    сбоя при пропадании напряжения файловая система окажется
                    в невосстановимом состоянии.</para>

                  <para>Если каталог <filename>/usr/obj</filename> &mdash; это все,
                    что есть в этой файловой системе, то это не проблема.
                    Если на той же самой файловой системе имеются какие-то
                    важные данные, то проверьте давность ваших резервных
                    копий перед включением этой опции.</para>
                </warning>

                <screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

                <warning>
                  <para>Как и раньше, если каталог
                    <filename>/usr/obj</filename> располагается не на
                    собственной файловой системе, то в примере замените его
                    на имя соответствующей точки монтирования.</para>
                </warning>
              </listitem>
            </itemizedlist>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>Что мне делать, если что-то пошло не так?</para>
          </question>

          <answer>
            <para>Скрупулезно проверьте, чтобы в вашем окружении не было
              мешающих остатков от предыдущих построений.  Это достаточно
              просто.</para>

            <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

            <para>Да, команду <command>make cleandir</command> действительно
              нужно выполнять дважды.</para>

            <para>После этого повторите весь процесс снова, начиная с
              <command>make buildworld</command>.</para>

            <para>Если у вас все еще есть проблемы, пришлите текст ошибки и
              выдачу команды <command>uname -a</command> на адрес
              &a.questions;.  Будьте готовы ответить на другие вопросы о
              конфигурации вашей системы!</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
          <contrib>Текст предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Отслеживание исходных текстов для нескольких машин</title>

    <indexterm>
      <primary>NFS</primary>
      <secondary>installing multiple machines</secondary>
    </indexterm>
 
    <para>Если у вас множество машин, для которых вы хотите отслеживать одно 
      и то же дерево исходных текстов, то сгрузка кода и перестроение системы
      полностью выглядит как ненужная трата ресурсов: дискового пространства,
      пропускной способности сети и процессорного времени.  Так оно и есть, и
      решением является выделение одной машины, которая выполняет основной
      объём работы, в то время как остальные используют результаты работы
      посредством NFS.  В этом разделе описывается именно этот метод.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Подготовка</title>

      <para>Первым делом определите набор машин, на которых выполняется один
        и тот же набор бинарных программ, и мы будем называть его
        <emphasis>набором для построения</emphasis>.  Каждая машина может иметь
        собственное уникальное ядро, но они будут работать с одними и теми же
        программами пользователя.  Из этого набора выберите машину, которая
        будет являться <emphasis>машиной для построения</emphasis>.  Она станет
        машиной, на которой будут строиться ядро и всё окружение.  В идеальном
        случае с достаточно незагруженным CPU для выполнения команды
	<command>make world</command>.  Вам также потребуется выбрать машину,
        которая будет <emphasis>тестовой</emphasis> для проверки обновлений
        программного обеспечения прежде, чем оно будет запущено в промышленную
        эксплуатацию.  Это <emphasis>должна</emphasis> быть машина, которая
        может быть в нерабочем состоянии достаточно долго.  Это может быть
        машина для построения, но не обязательно.</para>

      <para>Все машины в этом наборе для построения должны монтировать каталоги
	<filename>/usr/obj</filename> и
	<filename>/usr/src</filename> с одной и той же машины и в одну и ту же
        точку монтирования.  В идеальном случае они располагаются на разных
        дисках машины построения, но они могут также монтироваться по NFS на
        этой машине.  Если у вас имеется несколько наборов для построения, то
	каталог <filename>/usr/src</filename> должен быть на машине построения,
        а по NFS он должен быть смонтирован на остальных.</para>

      <para>Наконец, удостоверьтесь в том, что файл
        <filename>/etc/make.conf</filename> на всех машинах набора для
        построения соответствует машине построения.  Это означает, что машина
        построения должна строить все части основного системного набора,
        которые будут устанавливаться на каждой машине из набора для
        построения.  Кроме того, у каждой машины построения должно быть задано
        имя ядра посредством переменной <makevar>KERNCONF</makevar> в файле
	<filename>/etc/make.conf</filename>, а машина построения должна
        перечислить их все в переменной <makevar>KERNCONF</makevar>, причём
        первым должно быть имя её собственного ядра.  Машина построения должна
        хранить конфигурационные файлы ядра каждой машины в каталоге
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>,
        если на ней будут строиться соответствующие ядра..</para>
    </sect2>

    <sect2>
      <title>Основные системные компоненты</title>

      <para>Теперь, когда всё это сделано, вы готовы к построению.  Постройте
        ядро и всё окружение так, как это описано в <xref
	linkend="make-buildworld"> на машине построения, но ничего не
        устанавливайте.  После того, как процесс построения завершится,
        перейдите к тестовой машине и установите только что построенное ядро.
        Если эта машина монтирует каталоги <filename>/usr/src</filename> и
	<filename>/usr/obj</filename> посредством NFS, то при перезагрузке в
        однопользовательский режим вам потребуется задействовать сеть и
        смонтировать их.  Самым простым способом сделать это является переход
        во многопользовательский режим и запуск команды <command>shutdown
        now</command> для перехода в однопользовательский режим.  После этого
        вы можете установить новое ядро и всё окружение, а затем выполнить
        команду <command>mergemaster</command> обычным образом.  После
        выполнения этих действий перезагрузитесь для возвращения к обычному
        режиму работы во многопользовательском режиме с этой машиной.</para>

      <para>После того, как вы убедитесь в нормальной работе всего на тестовой
        машине, проведите ту же самую процедуру для установки нового
        программного обеспечения на каждой из оставшихся машин из набора для
        построения.</para>
    </sect2>

    <sect2>
      <title>Порты</title>

      <para>Те же самые идеи могут использоваться и для дерева портов.  Первым
        критическим шагом является монтирование <filename>/usr/ports</filename>
        с одной и той же машины на всех компьютерах в наборе для построения.
        Затем вы можете корректно настроить <filename>/etc/make.conf</filename>
        для использования общего каталога с дистрибутивными файлами.  Вы должны
        задать переменную <makevar>DISTDIR</makevar> так, чтобы она указывала
        на общедоступный каталог, доступный тому пользователю, который
        отображается в пользователя <username>root</username> для ваших точек
        монтирования NFS.  Каждая машина
        должна задавать <makevar>WRKDIRPREFIX</makevar> так, чтобы она
        указывала на локальный каталог построения.  Наконец, если вы
        собираетесь строить и распространять пакаджи, до должны задать
        переменную <makevar>PACKAGES</makevar> так, чтобы она указывала на
        каталог, соответствующий <makevar>DISTDIR</makevar>.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
