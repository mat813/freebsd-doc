<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN" [
<!ENTITY date "$Date: 1998-06-23 15:15:01 $">
<!ENTITY title "FreeBSD Security Guide">
<!ENTITY % includes SYSTEM "includes.sgml"> %includes;
]>
<!-- $Id: security.sgml,v 1.2 1998-06-23 15:15:01 kuriyama Exp $ --> 
<!-- The FreeBSD Japanese Documentation Project --> 
<!-- Original revision: 1.8 -->

<HTML>
&header;

<H1>FreeBSD セキュリティガイド</H1>

<em>Last Updated: $Date: 1998-06-23 15:15:01 $ </em>

<P>このガイドは多くの FreeBSD セキュリティの達人がシステムを安全にしたり
安全なコードを書くために使っている Tips や Tricks をドキュメント化しようと
したものです. 外部の攻撃から FreeBSD システムを守るための数多くの方法と,
もしそういった攻撃が行われた時にいかに復旧すればいいのかということを学ぶ
ための手助けとなるようにデザインされています. また, システムプログラマが
よりセキュリティを意識し, セキュリティホールを作ってしまうようなことを初期
段階で防ぐための方法も載せてあります.

<P>このページについてのコメントや訂正の指摘はいつでも歓迎しています. もし
ここに載せたい変更がある時は, <a href="mailto:security-officer@freebsd.org">
FreeBSD セキュリティ担当者</a> までメールを送って下さい.

<H2>FreeBSD システムを安全にするための方法</H2>

<UL>
<LI>XXX このセクションを書く必要があります.
</UL>

<H2>セキュリティ問題から回復するための方法</H2>

<UL>
<LI>XXX このセクションも書く必要があります.
</UL>

<H2>プログラマのためのべきべからず集</H2>

<P><UL>
<LI><A NAME="#rule1"></A>どんな入力ソースも信用しないこと. つまり, コマンド
   ライン引数, 環境変数, 設定ファイル, 到着した UDP パケット, ホスト名参照,
   関数引数など, どれも信用してはいけません. そもそも, 受け取ったデータ長や
   内容が各プログラムや関数のコントロール外のものなら, プログラムや関数はそ
   のデータをコピーする時に注意をはらうべきです. この種のセキュリティ問題を
   挙げると:

   <P><UL>
   <LI><A NAME="#rule1_1"></A>データ境界を越えるような
   <a href="http://www.freebsd.org/cgi/man.cgi?strcpy(3)">
   strcpy(3)</a> や <a
   href="http://www.freebsd.org/cgi/man.cgi?sprintf(3)">
   sprintf(3)</a> 関数の呼び出し. もしデータ長が分かっているのなら,
   <a href="http://www.freebsd.org/cgi/man.cgi?strncpy(3)">
   strncpy(3)</a> や
   <a href="http://www.freebsd.org/cgi/man.cgi?snprintf(3)">
   snprintf(3)</a> 関数を使う ( あるいは, それが使えないのなら境界チェックを
   施した別の物を組み込む ) ようにして下さい. 実際,
   <a href="http://www.freebsd.org/cgi/man.cgi?gets(3)">gets(3)</a>
   や
   <a href="http://www.freebsd.org/cgi/man.cgi?sprintf(3)">
   sprintf(3)</a> は今後決して使われることはありません.

   <P><LI><A NAME="#rule1_2"></A>
   <a href="http://www.freebsd.org/cgi/man.cgi?strvis(3)">strvis(3)</a>
   や <a href="http://www.freebsd.org/cgi/man.cgi?getenv(3)">getenv(3)</a>
   の乱用に気をつける
   こと.
   <a href="http://www.freebsd.org/cgi/man.cgi?strvis(3)">strvis(3)</a>
   は間違ったコピー先文字列を簡単に作ってしまいますし,
   <a href="http://www.freebsd.org/cgi/man.cgi?getenv(3)">getenv(3)</a>
   は想定される長さをはるかに越える文字列を返すこともあります.
   これらはプログラムへの攻撃でしばしば使われる重要な方法の一つで, 
   環境変数を予想もしなかった値に設定してスタックや変数を上書きさせる
   のです. あなたの
   プログラムが環境変数を読んでいるのなら, 偏執的にならないといけません.

   <P><LI>
   <a href="http://www.freebsd.org/cgi/man.cgi?open(2)">open(2)</a>
   や
   <a href="http://www.freebsd.org/cgi/man.cgi?stat(2)">stat(2)</a>
   関数を見つけるたびに, "アクセスしようとしているファイルが
   シンボリックリンクだったらどうなるだろう？" と自問してください.

   <P><LI><A NAME="#rule1_3"></A>
   <a href="http://www.freebsd.org/cgi/man.cgi?mktemp(3)">
   mktemp(3)</a>, <a
   href="http://www.freebsd.org/cgi/man.cgi?tempnam(3)">
   tempnam</a>, <a
   href="http://www.freebsd.org/cgi/man.cgi?mkstemp(3)">
   mkstemp(3)</a>, などを使用しているところでは代わりに
   <a href="http://www.freebsd.org/cgi/man.cgi?mkstemp(3)">
   mkstemp(3)</a> が使われていることを確認して下さい.

   加えて, /tmp の中でアトミックになることはほとんどないということに気づ
   いて, /tmp 中の競合が発生していないか探してみて下さい:
	<UL>
	<LI>ディレクトリの作成. これは成功するか失敗するかのどちらかです.
	<LI>O_CREAT | O_EXCL モードでのファイルのオープン
	</UL>
   <a href="http://www.freebsd.org/cgi/man.cgi?mkstemp(3)">
   mkstemp(3)</a> はこういったことをあなたのために正しくやってのけてくれま
   す. そう, 競合を起こさないで正しい許可権でテンポラリファイルが作成される
   ことを保証するには mkstemp() を使わなければいけないのです.

   <P><LI><A NAME="#rule1_4"></A>攻撃者が適当な別のシステムからパケットを
   投げたり, パケットを受け取ったりするように強いることができるのなら,
   私達が受けるデータを完全にコントロールすることができますし, それらの
   いずれも信用できないものとなります.

   <P><LI><A NAME="#rule1_5"></A>2.1 と 2.2 における UID, EUID, SVUID の
   違いを理解して下さい. 私たちも理解していません. [XXX しかし Bruce と
   話し合った後で理解してここを埋めなければいけません]

   <P><LI><A NAME="#rule1_6"></A>設定ファイルが正しいフォーマットに
   なっている, あるいは関連ユーティリティで作成されている, などとは思って
   はいけません. 変なことをするチャンスさえあれば, ひねくれたクラッカーが
   きっとその変なことをしでかしてしまうでしょう: 端末名や言語文字列など
   パス名の中に '/' や '../../...' といったフリースタイルの文字が入る時
   はユーザの入力を信用してはいけません.

   root 権限で setuid がセットされているような状態のときはユーザから
   与えられる *どんな* パス名も信用してはいけません.

   <P><LI><A NAME="#rule1_7"></A>データの格納される方法に関してのセキュリティ
   ホールや弱点に気をつけて下さい. テンポラリファイルの許可権はどれも 600 に
   なっていないといけません.

   <P><LI><A NAME="#rule1_8"></A>高い権限で実行する可能性のあるプログラム
   からおきまりの問題のコードを見つけるのに grep してはいけません.
   <a href="http://www.freebsd.org/cgi/man.cgi?strcpy(3)">
   strcpy(3)</a> のような関数がオーバフローをおこすといったことよりも数
   多くのオーバーフローのケースがあるので, １行１行コードを追っていくよ
   うにしなければいけません.

   <P><LI><A NAME="#rule1_9"></A>必要のない（訳注 root などの）特権を使
   わないからといって, （侵入者に）悪用される可能性がなくなるわけではあ
   りません. 攻撃者は必要な実行コードをスタックに積んでから /bin/sh を
   実行しようとするかもしれません.
   </UL>

<P><LI><A NAME="#rule2"></A>UID を管理するようにして下さい. そう, できる
   だけはやく特権を完全に捨て去るのです.  EUID と UID とを切替える必要は
   ありません. 
   <a href="http://www.freebsd.org/cgi/man.cgi?setuid">setuid(2)</a>
   を使えるうちに使えばいいのです.

<P><LI><A NAME="#rule3"></A>エラーのあった設定ファイルの内容を絶対に
   画面に表示しないようにして下さい. 行番号, それから桁数が分かれば十分です.
   ライブラリと SUID/SGID が設定されているプログラムにこれらのことが言えます.

<P><LI><A NAME="#rule4"></A>セキュリティ問題に関しての, 現存するコードの
   レビューのための Tips:

   <P><UL>
   <LI><A NAME="#rule4_1"></A>セキュリティフィックスについてあなたが確信を
   持てないのなら, 目を通してもらうためにあなたが整えたコードをレビュー
   する人に送って下さい. 安全の名において, かなり厄介な問題を引き起こさ
   ないことを確信できないうちはコミットしてはいけません. :)

   <P><LI><A NAME="#rule4_2"></A>CVS コミットの権限のないものは, 変更の
   レビューを最後に行った人にその権限があることを確認すべきです. その人
   はレビューと最終バージョンのツリーへの取り込みの両方をすることになり
   ます.

   <P><LI><A NAME="#rule4_3"></A>レビューする人に変更点を送る時, 簡単に
   <a href="http://www.freebsd.org/cgi/man.cgi?patch(1)">patch(1)</a>
   を当てられるようにするために context か unidiff 形式の diff を使うよう
   にして下さい. ファイルまるごと送らないで下さい! Diff は簡単に読むことが
   できるし, (とくに複数の場所で同時に行われる変更の時) ローカルのソース
   に専念できます. 特定のインスタンスにともなうような特別な理由でもない
   限り, 共通の環境をベースにして作業を簡単にするために, どんな変更も
   3.0-current への変更とするようにしてください.

   <P><LI><A NAME="#rule4_4"></A>コードを変更をするたびに, レビューする
   人達に送る前に直接テストを行う (つまりビルドして該当するモジュールを
   実行する) ようにしてください. 明らかに壊れているものをレビューしたい
   と思う人はいません. ちゃんとテストするために 2.1, 2.2 や 3.0 上での
   アカウントが必要なら言って下さい - プロジェクトはその目的でこれらの環
   境を用意してあります.

   <P><LI><A NAME="#rule4_5"></A>コミットする方々へ:
   -current パッチが 2.2 や 2.1 ブランチにも合うように必ず心がけて下さい.

   <P><LI><A NAME="#rule4_6"></A>不必要にあなた好みのスタイルにコードを
   書き換えないで下さい - それはレビューする人にとって, 必要のない, より
   難解な仕事を作るだけです. それをするのに明確な技術上の理由がある時に
   だけ行うようにしてください.
   </UL>

<P><LI><A NAME="#rule5"></A>単一のハンドラで複雑な処理を行うような
   プログラムに気をつけて下さい. いろいろなライブラリ中の多くの関数は,
   そのような処理を安全に行えるほど充分にリエントラントではありません.

<P><LI><A NAME="#rule6"></A>
   <a href="http://www.freebsd.org/cgi/man.cgi?realloc(3)">
   realloc(3)</a> の使い方には細心の注意を払って下さい
   - 正しく使われていないことは, ないわけではなくむしろ頻繁に起こっている
   ことです.

<P><LI>固定長バッファを使う場合, バッファサイズが変更されたにもかかわらず
   コードが sizeof() を使っていないがために発生する問題を防ぐために,
   sizeof() を使用するようにして下さい. 例を挙げると:
<LISTING>
	char buf[1024];
	struct foo { ... };
	...
BAD:
	xxx(buf, 1024)
	xxx(yyy, sizeof(struct foo))
GOOD:
	xxx(buf, sizeof(buf))
	xxx(yyy, sizeof(yyy))
</LISTING>

<P><LI>"char foo[###]" を見つけるたびに, foo の使い方をチェックしてオーバー
   フローを起こさないことを確認して下さい. オーバーフローを回避できない
   (か, オーバーフローが起こり得る) ときは, 最低でもスタックを食い潰さない
   ようにするために malloc(3) でバッファ領域をとるようにして下さい.

<P><LI>できるだけ早い段階でファイル記述子をクローズするようにして下さい.
   これは標準入出力バッファの内容を捨て去ることよりも大切なことです.
   ライブラリルーチンの中で, あなたが開いたファイル記述子を常に閉じる
   ようにしてください。

<P>
</UL>

&footer;
</BODY>
</HTML>
